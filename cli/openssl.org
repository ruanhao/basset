# -*- mode: snippet -*-
#+TITLE:     Openssl
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 3



* 基本知识

** openssl 组成

- libcrypto: 加密库
- libssl: TLS/SSL 实现
- openssl: 命令行工具

** X509 格式

内容包含：

- 公钥及其有效期
- 证书合法拥有者
- 证书该如何被使用 （用来签名或是用来加密）
- CA 的信息
- CA 的签名

** Diffie-Hellman 交换过程


#+BEGIN_SRC plantuml :file img/openssl-dh.png
  client -> server  : p, g
  rnote over client : p, g, x
  rnote over server : p, g, y
  client -> server  : g^x%p
  server -> client  : g^y%p
  rnote over client : p, g, x, g^(xy)%p
  rnote over server : p, g, y, g^(xy)%p

#+END_SRC
#+NAME: dh
#+CAPTION: 交换过程示意图
#+RESULTS:

p：大素数；g：生成数；x：clnt_random；y：srv_random


** 算法种类

- 对称加密
  - DES  :: 56 bits
  - 3DES :: Tripple DES
  - AES  :: 128 bits

- 单向加密
  - MD5
  - SHA1, SHA192, SHA256, SHA384

- 公钥加密

  - DSA (仅用于签名)
  - RSA  (可用于加密或签名)

* 常见用法

** 查询可用子命令

=openssl ?=

** 测试各种加密算法的速度

=openssl speed [ciphername]=

** 加解密

*** 加密

  =openssl enc -des3 -a -in ./test-cipher -out test-cipher.des3=

*** 解密

  =openssl enc -des3 -d -a -in ./test-cipher.des3 -out test-cipher=

** 计算文件特征码（指纹）

=openssl dgst -md5 <filename>=

** 生成密码串

=openssl passwd -1 -salt <saltvalue>=

-1 表示 MD5-Based Password algorithm


** 制作自签署证书

自签署证书一般作为 CA 的证书，普通的证书由 CA 来签署，也可以按照该步骤制作自签署的普通证书（将自身作为 CA ）：

*** 第一步：生成密钥

   #+BEGIN_SRC sh
     openssl genrsa 2048 >ca.key.pem    ## 生成 2048 位私钥
   #+END_SRC

*** 第二步：生成自签署证书

   #+BEGIN_SRC sh
     openssl req -new -x509 -key ca.key.pem -out ca.cert.pem -days 365
   #+END_SRC

** 从私钥中提取公钥

=openssl rsa -in ca.key.pem -pubout=

** 查看证书内容

=openssl x509 -text -in cert.pem=


** 签署证书

*** 第一步：部署 CA 证书

   #+BEGIN_SRC sh
     mkdir -p $CATOP/private  ## $CATOP: ./demoCA
     cp ca.key.pem $CATOP/private/cakey.pem
     cp ca.cert.pem $CATOP/cacert.pem
   #+END_SRC

*** 第二步：生成 csr

#+BEGIN_SRC sh
  openssl req -new -key webserver.key -out webserver.csr
#+END_SRC

*** 第三步：签署 csr

   #+BEGIN_SRC sh
     openssl ca -in webserver.csr -out webserver.crt
   #+END_SRC

*** 自动化脚本（可设置证书的有效日期）

#+BEGIN_SRC sh
  #!/usr/bin/env bash
  # -*- coding: utf-8 -*-
  CATOP=./demoCA
  rm -rf $CATOP
  mkdir -p $CATOP/certs           #
  mkdir -p $CATOP/crl             # 存放 Certificate Revoke List
  mkdir -p $CATOP/newcerts        # 存放证书
  mkdir -p $CATOP/private         # 存放 CA private key
  touch $CATOP/index.txt          # CA log file
  openssl genrsa -out usc.key.pem 2048
  openssl req -new -key usc.key.pem -out usc.csr.pem \
              -subj "/C=US/ST=Califomia/L=Irvine\
                     /O=Cisco Systems, Inc./OU=Cisco Small Business/CN=Network Orchestrator"
  openssl ca -selfsign -keyfile usc.key.pem -startdate 20160901000000Z \
             -days 7300 -batch -in usc.csr.pem -out usc.cert.pem -create_serial
  rm -rf demoCA
#+END_SRC




** 证书格式转换

PEM 格式分为 =PKCS#1= 和 =PKCS#8= ：

|--------+-------------------------+-----------------------------|
| Format | Type                    | Header                      |
|--------+-------------------------+-----------------------------|
| PKCS#1 | RSAPublicKey            | BEGIN RSA PUBLIC KEY        |
| PKCS#1 | RSAPrivateKey           | BEGIN RSA PRIVATE KEY       |
| PKCS#8 | PrivateKeyInfo          | BEGIN PRIVATE KEY           |
| PKCS#8 | RSAPublicKey            | BEGIN PUBLIC KEY            |
| PKCS#8 | EncryptedPrivateKeyInfo | BEGIN ENCRYPTED PRIVATE KEY |
|--------+-------------------------+-----------------------------|



*** PKCS#1 => PKCS#8

  openssl 的 =genpkey= 指令会生成 =PKCS#8= 格式，而 =genrsa= 会生成 =PKCS#1= 格式。

**** 私钥
  #+BEGIN_SRC sh
    openssl pkcs8 -topk8 -inform pem -in key.pem -outform pem -nocrypt -out key.pkcs8.pem
  #+END_SRC

**** 公钥

#+BEGIN_SRC sh
  openssl rsa  -RSAPublicKey_in -in public_pkcs1.pem  -out public_pkcs8.pem
#+END_SRC


*** PKCS#8 => PKCS#1

**** 私钥

#+BEGIN_SRC sh
  openssl pkcs8 -in private_pkcs8.pem -nocrypt -out private_pkcs1.pem
#+END_SRC

**** 公钥

#+BEGIN_SRC sh
  openssl rsa -pubin -in public.pem -RSAPublicKey_out -out public_pkcs1.pem
#+END_SRC


*** PEM => PKCS#12

#+BEGIN_SRC sh
  openssl pkcs12 -export -in ./cert.pem -inkey ./key.pem -out hello.p12
#+END_SRC


*** PEM => DER

#+BEGIN_SRC sh
  openssl x509 -in cert.pem -outform der -out cert.der
#+END_SRC


*** DER => PEM

#+BEGIN_SRC sh
  openssl x509 -inform der -in cert.der -outform der -out cert.pem
#+END_SRC



** 同时生成密钥和证书

#+BEGIN_SRC sh
  openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout key.pem
#+END_SRC

** 查看服务器证书内容

#+BEGIN_SRC sh
  echo | openssl s_client -showcerts -connect 10.74.68.89:443 2>/dev/null | sed -n '/BEGIN CERTIFICATE/,/END CERTIFICATE/p'
#+END_SRC


** 建立 ssl 连接

#+BEGIN_SRC sh
  openssl s_client -connect <ip>:<port>
#+END_SRC


** 验证证书

#+BEGIN_SRC sh
  openssl verify -CAfile <(cat root.pem intermediate.pem) <cert_to_verify>.pem
#+END_SRC