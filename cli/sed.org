#+TITLE:     Sed
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 4
#+STARTUP:   showall


* 基本原理

*sed 只有贪婪模式*

** 元字符

*** 不使用扩展正则表达式

- 元字符

  =. * ^ $ [ ] \=

- 字面字符

  =( ) + ? | { } < >=

  有些字面字符在表达元字符时需要转义，比如 =\<abc= 表示以 abc 为首的词， =\>= 表示词尾

*** 使用扩展正则表达式 (-r)

- 元字符

  =. * ^ $ [ ] \ ( ) + ? | { }=



** 知识点

*** Patter Space

原理伪码:

#+BEGIN_SRC sh

foreach line in file {
    // 把行放入 panttern_space
    pattern_space = line;

    // 对每个 pattern space 执行 sed 命令
    pattern_space = EXEC(sed_cmd, pattern_space);

    // 如果没有指定 -n 则输出处理后的 pattern_space
    if ( sed_option.notInclude("-n") )  {
       print pattern_space;
    }
}

#+END_SRC


*** Address

**** 对于像 "addr1,addr2" 这种形式的地址匹配

如果 addr1 匹配，则匹配成功，“开关”打开，在该行上执行命令，此时不管 addr2 是否匹配，即使 addr2 在 addr1 这一行之前

接下来读入下一行，看 addr2 是否匹配:

- 如果 addr2 在 addr1 之前，则不匹配，不执行命令，关闭“开关”；
- 如果 addr2 匹配，则执行命令，同样开关“关闭”；
- 如果 addr2 在 addr1 之后，则一直处理到匹配为止，换句话说，如果 addr2 一直不匹配，则开关一直不关闭，因此会持续执行命令到最后一行

**** 地址形式

- number

  略

- first~step

  从first行开始，每隔step行执行一次命令

  #+BEGIN_SRC sh
  ## 从第一行起每隔两行
  sed -n '1~2p' input.file ## 输出奇数行
  #+END_SRC

- /regex/

  略

- 0,/regex/

  这种形式的地址对，默认第一个地址是匹配的，也就是匹配开关打开，直到找到匹配 /regex/ 的那行为止，匹配开关关闭。
  大多数情况下和 1, /regex/ 是一样的，除非 /regex/ 匹配文件的第一行，在这种时候，0, /regex/ 就在第一行就关闭了，而 1, /regex/ 会继续往下找匹配的行。

- addr1,+N

  从匹配的 addr1 行开始，连续 N 行，包括 addr1 这一行

  #+BEGIN_SRC sh
  ## 其中 +3 表示后面连续 3 行
  sed '/dog/,+3s/^/# /g' text.txt
  #+END_SRC

- addr1,~N

  从匹配的 addr1 行开始，直到某一行，该行的行号是 N 的倍数为止



**** 总结

a. 地址对 addr1, addr2 的匹配方式，从匹配 addr1 的那行开始，打开匹配开关，直到匹配 addr2 的那行结束，关闭匹配开关，
之后的行会忽略这个地址对，不再做匹配

b. 地址对 addr1, addr2 的匹配方式，假设 addr1 是 number ，即行号，如果新读入行的行号“大于” addr1，则匹配；小于 addr1，则不匹配

*** Cmd

cmd 可以是多个，它们可以用分号分开，可以用大括号括起来作为嵌套命令

#+BEGIN_SRC sh

## 对 3 行到第 6 行执行命令 /This/d
sed '3,6{/This/d}' pets.txt

## 对 3 行到第 6 行，匹配 /This/ 成功后，再匹配 /fish/，成功后执行 d 命令
sed '3,6{/This/{/fish/d}}' pets.txt

## 从第一行到最后一行，如果匹配到 This ，则删除之；如果前面有空格，则去除空格
sed '1,${/This/d;s/^ *//g}' pets.txt

#+END_SRC

**** 常用 Cmd

- n :: 将下一行的内容提前读入，并且将之前读入的行（在模式空间中的行）输出到屏幕，然后后续的命令会应用到新读入的行上

- N :: 将下一行的内容读取到当前模式空间，但是与 n 不一样的地方是 N 并没有直接输出当前模式空间中的行，
       而是把下一行追加到当前模式空间，两行之间用回车符 \n 连接

- a :: append，在后面追加一行

- i :: insert，在前面插入一行

- c :: 替换匹配行

- d :: 删除匹配行，同时不会执行接下来的命令，类似 break

- D :: 只会删除模式空间的第一行，而且删除后会重新在模式空间的内容上执行“整个”编辑命令，类似形成一个循环

- p :: 打印匹配行

- P :: 仅打印模式空间的第一行内容。很多情况下，P 命令都是用在 N 命令之后，D 命令之前的。
       这三个命令合起来，可以形成一个输入输出的循环，并且每次只打印一行：
       “读入一行后，N 继续读下一行，P 命令打印第一行，D 命令删除第一行，执行流程回到最开始重复该过程”

- y :: 字符按照一对一的方式从左到右进行转换

- q :: sed 程序退出，不再进行其它的处理

- = :: 打印行号

- l :: 同 p，同时打印控制字符

- I :: 忽略大小写


*** Hold Space

Hold Space 是一个和 Pattern Space 类似的变量空间，涉及到的命令有:

- g (get) ::  将 hold space 中的内容拷贝到 pattern space中，原来 pattern space 里的内容清除

- G ::  将 hold space 中的内容 append 到 pattern space\n 后

- h (hold) ::  将 pattern space 中的内容拷贝到 hold space 中，原来的 hold space 里的内容被清除

- H ::  将 pattern space 中的内容 append 到 hold space\n 后

- x (exchange) ::  交换 pattern space 和 hold space 的内容


* 常见用法

** 反序文件

#+BEGIN_SRC sh
  sed '1!G;h;$!d' t.txt
#+END_SRC

** 替换


*** 替换每一行的第一个

#+BEGIN_SRC sh
  sed 's/s/S/1' my.txt
#+END_SRC

*** 替换每一行的第二个

#+BEGIN_SRC sh
  sed 's/s/S/2' my.txt
#+END_SRC

*** 替换每一行的第三个及以后所有

#+BEGIN_SRC sh
  sed 's/s/S/3g' my.txt
#+END_SRC

** 使用匹配到的字符串

*** 使用 & 来当做被匹配的变量

#+BEGIN_SRC sh
  sed 's/my/[&]/g' my.txt
#+END_SRC

*** 使用圆括号

#+BEGIN_SRC sh
  sed 's/This is my \([^,]*\),.*is \(.*\)/\1:\2/g' my.txt
#+END_SRC


** 两行合并一行

#+BEGIN_SRC sh
  sed 'N;s/\n/ /' pets.txt
#+END_SRC

** 行 ( 前 / 后 ) 进行 ( 插入 / 追加 ) 一行内容

#+BEGIN_SRC sh
  ## 第 1 行前插入一行
  sed "1 i helloworld" my.txt

  ## 在最后一行后追加一行
  sed "$ a helloworld" my.txt

  ## 匹配到 /fish/ 后就追加一行
  sed "/fish/a helloworld" my.txt
#+END_SRC

** 替换匹配行

#+BEGIN_SRC sh
  ## 替换第二行
  sed "2 c helloworld" my.txt

  ## 替换匹配到的行
  sed "/fish/c helloworld" my.txt
#+END_SRC

** 字符转换

#+BEGIN_SRC sh
  sed 'y/abcde/ABCDE/' text.txt
#+END_SRC

** 压缩多行空行为一行

#+BEGIN_SRC sh
  sed '/^$/{N;/^\n$/D}' text.txt
  cat -s text.txt
#+END_SRC

** 每行后添加一空行

#+BEGIN_SRC sh
  sed G file.txt
#+END_SRC

** 删除偶数行

#+BEGIN_SRC sh
  sed 'n;d' file.txt
  sed '2~2d' file.txt
#+END_SRC

** 删除奇数行

#+BEGIN_SRC sh
  sed '2,$n;d' file.txt
#+END_SRC

** 忽略大小写匹配

#+BEGIN_SRC sh
  sed -n '/abc/I p' file.txt
#+END_SRC

** 不执行匹配

=[address[,address]][!]{cmd}=

** 匹配行之前添加空行

#+BEGIN_SRC sh
  sed '/regex/{x;p;x}' test.txt
#+END_SRC

** 匹配行之前之后添加空行

#+BEGIN_SRC sh
  sed '/regex/{x;p;x;G;}' test.txt
#+END_SRC

** 每一行后添加两行

#+BEGIN_SRC sh
  sed 'G;G'
#+END_SRC

** 每 5 行添加一个空行

#+BEGIN_SRC sh
  sed '0~5G' test.txt
#+END_SRC

** 打印匹配 /regex/ 之前的那一行

#+BEGIN_SRC sh
  sed -n '/regex/{g;1!p;};h'
#+END_SRC

** 打印匹配 /regex/ 之后的那一行

#+BEGIN_SRC sh
  sed -n '/regex/{n;p}' test.txt
#+END_SRC

** 打印长于 65 个字符的行

#+BEGIN_SRC sh
  sed -n '/^.{65}/p' test.txt
#+END_SRC



* 参考列表

[[http://kodango.com/][团子的小窝]]