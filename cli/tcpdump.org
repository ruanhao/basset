# -*- mode: snippet -*-
#+TITLE:     Tcpdump
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 4
#+STARTUP:   showall

* 基本语法


** 过滤主机

*** 指定源地址

  #+BEGIN_SRC bash
  tcpdump -i eth1 src host 192.168.1.1
  #+END_SRC

*** 指定目的地址

  #+BEGIN_SRC bash
  tcpdump -i eth1 dst host 192.168.1.1
  #+END_SRC


** 过滤端口

*** 指定源端口

#+BEGIN_SRC sh
tcpdump -i eth1 src port 25
#+END_SRC

*** 指定目的端口

#+BEGIN_SRC sh
tcpdump -i eth1 dst port 25
#+END_SRC


** 过滤网络

#+BEGIN_SRC sh
tcpdump -i eth1 net 192.168
tcpdump -i eth1 src net 192.168
tcpdump -i eth1 dst net 192.168
#+END_SRC


** 过滤协议

#+BEGIN_SRC sh
tcpdump -i eth1 arp
tcpdump -i eth1 ip
tcpdump -i eth1 tcp
tcpdump -i eth1 udp
tcpdump -i eth1 icmp
#+END_SRC


** 表达式


- 与 : && (and)
- 非 : !  (not)
- 或 : || (or)


#+BEGIN_SRC sh
  # 抓取所有经过 eth1 ，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据
  tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))'

  # 抓取所有经过 eth1 ，目标 MAC 地址是 00:01:02:03:04:05 的 ICMP 数据
  tcpdump -i eth1 '((icmp) and ((ether dst host 00:01:02:03:04:05)))'

  # 抓取所有经过 eth1 ，目的网络是 192.168 ，但目的主机不是 192.168.1.200 的 TCP 数据
  tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))'
#+END_SRC


* 包头过滤

** 基本语法

#+BEGIN_SRC sh
proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）
proto[x:y] & z = 0  : proto[x:y]和z的与操作为0
proto[x:y] & z !=0  : proto[x:y]和z的与操作不为0
proto[x:y] & z = z  : proto[x:y]和z的与操作为z
proto[x:y] = z      : proto[x:y]等于z
#+END_SRC

操作符 : >, <, >=, <=, =, !=


** IP

*** 过滤 IP Option

- 通常 IP 头是 20 字节，但 IP 头有选项设置，不能直接从偏移 21 字节处读取数据
- IP 头有个长度字段( IHL )可以知道头长度是否大于 20 字节
- IHL (4 bits) 表示 IP 头 32 bit 的块数, 通常为 5 ( = 5 * 32 bits = 160 bits or 20 bytes)

#+BEGIN_SRC sh
tcpdump -i eth1 'ip[0] & 0x0f > 5'
#+END_SRC


*** 过滤大于 x 字节的数据包

#+BEGIN_SRC sh
tcpdump -i eth1 'ip[2:2] > 600'
#+END_SRC


*** 过滤分片

**** 基本原理

当发送端的 MTU 大于到目的路径链路上的 MTU 时就会被分片

分片信息在 IP 头的第七和第八字节：

#+BEGIN_EXAMPLE
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |Flags|      Fragment Offset    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+END_EXAMPLE

- Bit 0:  保留，必须是0
- Bit 1:  (DF) 0 = 分片, 1 = 不分片
- Bit 2:  (MF) 0 = 最后的分片, 1 = 还有分片

=Fragment Offset= 字段只有在分片的时候才使用。

**** 过滤不分片的包

要抓带 DF 位标记的不分片的包，第七字节的值应该是： *01000000 = 64*

#+BEGIN_SRC sh
tcpdump -i eth1 'ip[6] = 64'
#+END_SRC

**** 过滤分片包

#+BEGIN_SRC sh
tcpdump -i eth1 '((ip[6:2] > 0) and (not ip[6] = 64))'
#+END_SRC

**** 测试分片

TCP 发送数据时，会将大于 MSS 的数据分段( segment 不叫分片)。

MSS 往往基于 MTU 计算出来，通常 *MSS = MTU-sizeof(IP Header)-sizeof(TCP Header) = 1500-20-20 = 1460* 。

这样，数据经过本地 TCP 层分段后，交给本地 IP 层，在本地 IP 层就不需要分片了。但是在下一跳路由 (Next Hop) 的邻居路由器上可能发生 IP 分片!

#+BEGIN_SRC sh
ping -M want -s 3000 192.168.1.1
#+END_SRC




** TCP

*** 过滤源端口

#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[0:2] > 1024'
tcpdump -i eth1 'portrange 21-23'
#+END_SRC

*** 过滤特殊标记

TCP 标记定义在 TCP 头的第十四个字节

#+BEGIN_EXAMPLE
   +-+-+-+-+-+-+-+-+
   |C|E|U|A|P|R|S|F|
   |W|C|R|C|S|S|Y|I|
   |R|E|G|K|H|T|N|N|
   +-+-+-+-+-+-+-+-+
#+END_EXAMPLE

**** 过滤 SYN 包
#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[13] = 2'
tcpdump -i eth1 'tcp[tcpflags] = tcp-syn'
#+END_SRC

**** 过滤 SYN-ACK 包
#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[13] & 2 = 2'
tcpdump -i eth1 'tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack != 0'
#+END_SRC

**** 过滤 PSH-ACK 包
#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[13] = 24'
#+END_SRC

**** 过滤 FIN 包 ( FIN 通常和 ACK 一起 )
#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[13] & 1 = 1'
#+END_SRC

**** 过滤 RST 包
#+BEGIN_SRC sh
tcpdump -i eth1 'tcp[13] & 4 = 4'
#+END_SRC

**** 握手特征码

#+BEGIN_EXAMPLE
SYN=1, FIN=0, RST=0, ACK=0 # 第一次握手
SYN=1, FIN=0, RST=0, ACK=1 # 第二次握手
SYN=0, FIN=0, RST=0, ACK=1 # ESTABLISHED
#+END_EXAMPLE


* 常见用法

** 抓 HTTP GET 数据

  #+BEGIN_SRC sh
  tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x47455420'
  # "GET "的十六进制是47455420
  # DATA Offset 单位为 32 bits = 4 bytes，所以需要右移2位(*4)
  #+END_SRC

** 指定抓包数量

  #+BEGIN_SRC sh
  time tcpdump -nn -i eth0 'tcp[tcpflags] = tcp-syn' -c 10000 > /dev/null
  ## 计算抓 10000 个 SYN 包花费多少时间，可以判断访问量大概是多少
  #+END_SRC

** 从 pcap 文件读取内容

  #+BEGIN_SRC sh
  tcpdump -nvvvs 0 -X -r data.pcap
  #+END_SRC

** 抓取 GRE 隧道数据

  #+BEGIN_SRC sh
  tcpdump 'protochain GRE'
  #+END_SRC
