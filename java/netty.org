#+TITLE:     Netty
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 内部原理

** Reactor 模型

#+HTML: <img src="https://images0.cnblogs.com/blog2015/434101/201503/112151380898648.jpg"/>

- =mainReactor=

  对应 bossGroup
- =subReactor=

  对应 workerGroup ，本质是 IO 线程池，负责 IO 事件
- =Thread Pool=

  对应用户业务的线程池（即不阻塞 IO 线程池）


* 1, Buffer

- 组合

  =ByteBuf message = Unpooled.wrappedBuffer(header, body);=

- 自动扩容

  #+BEGIN_SRC java
    ByteBuf b = Unpooled.buffer(1); // 在内部，缓冲区是被“懒”创建
    b.writeByte('1');               // 当第一次执行写操作，初始容量为 1 的缓冲区被创建
    b.writeByte('2');               // 当写入的字节数超过初始容量时，内部缓冲区自动分配更大的容量
  #+END_SRC

* 2，SSL/TLS

- 记录 Pre Master Secret

  #+BEGIN_SRC java

    private static final SslContext sslContext = SslContextBuilder
        .forClient()
        .sessionCacheSize(8192L)
        .sessionTimeout(60L)
        .trustManager(InsecureTrustManagerFactory.INSTANCE)
        .build();

    public void doConnect() {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap b = new Bootstrap();
        b.group(group)
            .channel(NioSocketChannel.class)
            .remoteAddress("127.0.0.1", 30443)
            .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        SSLEngine engine = sslContext.newEngine(ch.alloc());

                        Method initHandshakerMethod = engine.getClass().getDeclaredMethod("initHandshaker");
                        initHandshakerMethod.setAccessible(true);
                        initHandshakerMethod.invoke(engine);

                        Field handshakerField = engine.getClass().getDeclaredField("handshaker");
                        handshakerField.setAccessible(true);
                        Object handShakerObj = handshakerField.get(engine);

                        SslHandler sslHandler = new SslHandler(engine);
                        sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
                                @Override
                                public void operationComplete(Future<Channel> future) throws Exception {
                                    if (future.isSuccess()) {
                                        SSLSession session = engine.getSession();
                                        Field masterSecretField = session.getClass().getDeclaredField("masterSecret");
                                        masterSecretField.setAccessible(true);
                                        SecretKey k = (SecretKey)masterSecretField.get(session);
                                        String preMasterSecretString = BaseEncoding.base16().encode(k.getEncoded()).toLowerCase();

                                        Class<?> handshakerClass = Class.forName("sun.security.ssl.Handshaker");
                                        Field clientRandomField = handshakerClass.getDeclaredField("clnt_random");
                                        clientRandomField.setAccessible(true);
                                        Object clientRandomObj = clientRandomField.get(handShakerObj);
                                        Field randomBytesField = clientRandomObj.getClass().getDeclaredField("random_bytes");
                                        randomBytesField.setAccessible(true);
                                        byte[] randomBytes = (byte[])randomBytesField.get(clientRandomObj);
                                        String clientRandom = BaseEncoding.base16().encode(randomBytes).toLowerCase();
                                        /* this log trace can be used in SSLKEYLOGFILE understood by wireshark */
                                        log.info("CLIENT_RANDOM {} {}", clientRandom, preMasterSecretString);
                                    }
                                }
                            });

                        ch.pipeline().addLast(sslHandler);
                        ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
                                    // TODO
                                }
                            });
                    }
                });
        b.connect();
    }
  #+END_SRC


* 3, Channel

- 关闭 channel

  =channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);=

* 4, Bootstrap

- server

  #+BEGIN_SRC java
    EventLoopGroup bossGroup = new NioEventLoopGroup(1);
    EventLoopGroup workerGroup = new NioEventLoopGroup(16);
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .localAddress(new InetSocketAddress(40839)) // PORT
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            public void initChannel(SocketChannel ch) throws Exception {
                ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() { // HANDLER
                    @Override
                    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
                        ctx.writeAndFlush(Unpooled.copiedBuffer(new Date().toString() + "\n", Charsets.UTF_8));
                    }
                });
            }
        });
    b.bind();
  #+END_SRC

- client

  #+BEGIN_SRC java
    EventLoopGroup group = new NioEventLoopGroup();
    Bootstrap b = new Bootstrap();
    b.group(group)
        .channel(NioSocketChannel.class)
        .remoteAddress("127.0.0.1", 40839) // HOST and PORT
        .handler(new ChannelInitializer<SocketChannel>() {
                @Override
                public void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(myClientHandler); // HANDLER
                }
            });
    b.connect();
  #+END_SRC