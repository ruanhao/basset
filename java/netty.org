#+TITLE:     Netty
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 核心组件


** ByteBuf

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/05fig03_alt.jpg"/>

*** Heap/Direct

**** Heap Buffer

- 存储于堆空间（实际数据存放在字节数组中）
- 优点：快速创建与释放，并提供直接访问内部字节数组的方法
- 缺点：进行 I/O 操作时， *需要先将数据复制到直接缓冲区中* 再进行网络传输
- 多用于业务逻辑的实现


**** Direct Buffer

- 由操作系统在本地内存中分配空间，不占用堆空间
- 优点：I/O 性能好，可以实现零拷贝
- 缺点：分配与释放速度慢（可以通过 *内存池* 解决这个问题）
- 多用于 I/O 通信


**** 发送数据时的缓冲转换

If your data were contained in a heap-allocated buffer, the JVM would, in fact,
*copy your buffer to a direct buffer internally before sending it through the socket.*

#+BEGIN_SRC java

  @Override
  protected final Object filterOutboundMessage(Object msg) { // io.netty.channel.nio.AbstractNioByteChannel.filterOutboundMessage(Object)
      if (msg instanceof ByteBuf) {
          ByteBuf buf = (ByteBuf) msg;
          if (buf.isDirect()) {
              return msg;
          }

          return newDirectBuffer(buf);
      }

      if (msg instanceof FileRegion) {
          return msg;
      }

      throw new UnsupportedOperationException("unsupported message type: " +
                                              StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
  }

  /**
   ,* Returns an off-heap copy of the specified {@link ByteBuf}, and releases the original one.
   ,* Note that this method does not create an off-heap copy if the allocation / deallocation cost is too high,
   ,* but just returns the original {@link ByteBuf}..
   ,*/
  protected final ByteBuf newDirectBuffer(ByteBuf buf) { // io.netty.channel.nio.AbstractNioChannel.newDirectBuffer(ByteBuf)
      final int readableBytes = buf.readableBytes();
      if (readableBytes == 0) {
          ReferenceCountUtil.safeRelease(buf);
          return Unpooled.EMPTY_BUFFER;
      }

      final ByteBufAllocator alloc = alloc();
      if (alloc.isDirectBufferPooled()) {
          ByteBuf directBuf = alloc.directBuffer(readableBytes);
          directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
          ReferenceCountUtil.safeRelease(buf);
          return directBuf;
      }

      final ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();
      if (directBuf != null) {
          directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
          ReferenceCountUtil.safeRelease(buf);
          return directBuf;
      }

      // Allocating and deallocating an unpooled direct buffer is very expensive; give up.
      return buf;
  }
#+END_SRC



*** Derived Buffer

A /derived buffer/ provides a view of a =ByteBuf= that represents its contents in a specialized way. \\
Such views are created by the following methods:

- duplicate()
- slice()
- slice(int, int)
- Unpooled.unmodifiableBuffer(...)
- order(ByteOrder)
- readSlice(int)

Each returns a new =ByteBuf= instance *with its own reader, writer, and marker indices*.

The internal storage is *shared* just as in a JDK =ByteBuffer=.

*** Arena

#+HTML: <img src="https://caorong.github.io/post_images/2016-11-26-23-46-26.png"/>


*** 自旋锁在引用计数实现中的应用

=AbstractReferenceCountedByteBuf:retain0(int increment)= (v4.0.15)

#+BEGIN_SRC java
  public ByteBuf retain(int increment) {
      if (increment <= 0) {
          throw new IllegalArgumentException("increment: " + increment + " (expected: > 0)");
      }

      for (;;) {
          int refCnt = this.refCnt;
          if (refCnt == 0) {
              throw new IllegalReferenceCountException(0, increment);
          }
          if (refCnt > Integer.MAX_VALUE - increment) {
              throw new IllegalReferenceCountException(refCnt, increment);
          }
          if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) { // CAS operation
              break;
          }
      }
      return this;
  }
#+END_SRC



*** 在 Pipeline 中的创建与释放

**** 初始 ByteBuf 创建

参见 =io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read()=

**** 最终 ByteBuf 释放

参见:

- =TailContext.userEventTriggered(ChannelHandlerContext, Object)=
- =HeadContext.write(ChannelHandlerContext, Object, ChannelPromise)=


** EventLoop/EventLoopGroup

*** 类继承关系

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/07fig02_alt.jpg"/>


*** 线程模型

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig01.jpg"/></br>

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig04_alt.jpg"/>

[[file:img/netty_eventloop.png]]

- An =EventLoopGroup= contains one or more =EventLoops=
- An =EventLoop= is bound to a *single Thread* for its lifetime
- All I/O events processed by an EventLoop are handled on its dedicated =Thread=
- A =Channel= is registered for its lifetime *with a single EventLoop* (eliminates the need for synchronization)
- A single =EventLoop= may be assigned to one or more =Channels=

**** NioEventLoop 执行逻辑

#+HTML: <img src="https://caorong.github.io/post_images/2016-11-25-01-23-15.png"/>


**** Selector.wakeup()

java 的 Selector 在原生的 select api 之上 增加了个 =Selector.wakeup()= ，目的是唤醒阻塞在 =select()= 的线程。(*通过写入一个字节*)

在下述时刻需要被唤醒：

1. 注册了新的 channel 或者事件
2. channel 关闭， 取消注册
3. 优先级更高的事件触发（如定时器事件），希望及时处理


**** Epoll bug 修复

#+BEGIN_SRC java
  for(;;){
      int selectedKeys = selector.select(timeoutMillis); // select with timeout
      selectCnt ++;
      // 由于 select 阻塞 而等待了 timeoutMillis 毫秒， 说明阻塞了，没有 bug
      if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
          selectCnt = 1;
      } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
                 selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
          // 在小于 timeoutMillis 毫秒的时间内 select 的次数超过了 阀值(512) 次
          rebuildSelector();
          selector = this.selector;

          selector.selectNow();// Select again
          selectCnt = 1;
          break;
      }
  }
#+END_SRC


**** Reactor 模型

#+HTML: <img src="http://static.oschina.net/uploads/space/2013/1125/130828_uKWD_190591.jpeg"/>

- mainReactor 对应 bossGroup
- subReactor 对应 workerGroup ，本质是 *IO 线程池* ，负责 IO 事件
- Thread Pool 对应用户业务的线程池（即不阻塞 IO 线程池）



** Channel

*** 类继承关系

#+BEGIN_SRC plantuml :file img/channel_classes.png :eval never-export
  interface Channel

  interface Comparable
  interface ChannelOutboundInvoker
  interface AttributeMap

  interface ServerChannel
  interface ChannelPipeline
  interface ChannelConfig

  interface EventLoop

  abstract class AbstractChannel


  Channel .up.|> Comparable
  Channel .up.|> ChannelOutboundInvoker
  Channel .up.|> AttributeMap

  ServerChannel .up.|> Channel
  AbstractChannel .up.|> Channel

  Channel *-down-> ChannelPipeline
  Channel *-down-> ChannelConfig
  Channel *-down-> EventLoop




#+END_SRC

#+RESULTS:
[[file:img/channel_classes.png]]


*** Selecting and processing state changes

The possible state changes are:

- A new =Channel= was accepted and is ready. (OP_ACCEPT)
- A =Channel= connection was completed. (OP_CONNECT)
- A =Channel= has data that is ready for reading. (OP_READ)
- A =Channel= is available for writing data. (OP_WRITE)


#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/04fig02_alt.jpg"/>


** ChannelHandler/ChannelPipeline

#+BEGIN_EXAMPLE
                                              I/O Request via Channel or ChannelHandlerContext
                                                        |
    +---------------------------------------------------+---------------+
    |                           ChannelPipeline         |               |
    |                                                  \|/              |
    |    +---------------------+            +-----------+----------+    |
    |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  .               |
    |               .                                   .               |
    | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
    |        [ method call]                       [method call]         |
    |               .                                   .               |
    |               .                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    +---------------+-----------------------------------+---------------+
                    |                                  \|/
    +---------------+-----------------------------------+---------------+
    |               |                                   |               |
    |       [ Socket.read() ]                    [ Socket.write() ]     |
    |                                                                   |
    |  Netty Internal I/O Threads (Transport Implementation)            |
    +-------------------------------------------------------------------+

#+END_EXAMPLE

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig03_alt.jpg"/>

*** 类继承关系

#+BEGIN_SRC plantuml :file img/channelhandler_classes.png :eval never-export
  interface ChannelHandler {
      void handlerAdded(ChannelHandlerContext ctx) throws Exception;
      void handlerRemoved(ChannelHandlerContext ctx) throws Exception;
  }

  interface ChannelInboundHandler {
      void channelRegistered(ChannelHandlerContext ctx) throws Exception;
      void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
      void channelActive(ChannelHandlerContext ctx) throws Exception;
      void channelInactive(ChannelHandlerContext ctx) throws Exception;
      void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;
      void channelReadComplete(ChannelHandlerContext ctx) throws Exception;
      void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
      void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;
      void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
  }

  interface ChannelOutboundHandler {
      void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;
      void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception;
      void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void read(ChannelHandlerContext ctx) throws Exception;
      void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;
      void flush(ChannelHandlerContext ctx) throws Exception;
  }

  abstract class ChannelHandlerAdapter
  class ChannelInboundHandlerAdapter
  class ChannelOutboundHandlerAdapter

  ChannelInboundHandler -up-> ChannelHandler
  ChannelOutboundHandler -up-> ChannelHandler

  ChannelHandlerAdapter .up.|> ChannelHandler

  ChannelInboundHandlerAdapter .up.|> ChannelInboundHandler
  ChannelInboundHandlerAdapter -up-> ChannelHandlerAdapter

  ChannelOutboundHandlerAdapter .up.|> ChannelOutboundHandler
  ChannelOutboundHandlerAdapter -up-> ChannelHandlerAdapter


#+END_SRC

#+RESULTS:
[[file:img/channelhandler_classes.png]]


*** ChannelHandlerContext

A =ChannelHandlerContext= represents an association between a =ChannelHandler= and a =ChannelPipeline= and is created whenever
a =ChannelHandler= is added to a =ChannelPipeline=.

The =ChannelHandlerContext= associated with a =ChannelHandler= never changes, so it's safe to cache a reference to it.

**** Propagation via Channel/ChannelPipeline

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/06fig05_alt.jpg"/>

**** Propagation via ChannelHandlerContext

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/06fig06_alt.jpg"/>

*** Propagation Methods

**** Inbound

- ChannelHandlerContext.fireChannelRegistered()
- ChannelHandlerContext.fireChannelActive()
- ChannelHandlerContext.fireChannelRead(Object)
- ChannelHandlerContext.fireChannelReadComplete()
- ChannelHandlerContext.fireExceptionCaught(Throwable)
- ChannelHandlerContext.fireUserEventTriggered(Object)
- ChannelHandlerContext.fireChannelWritabilityChanged()
- ChannelHandlerContext.fireChannelInactive()
- ChannelHandlerContext.fireChannelUnregistered()

**** Outbound

- ChannelHandlerContext.bind(SocketAddress, ChannelPromise)
- ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)
- ChannelHandlerContext.write(Object, ChannelPromise)
- ChannelHandlerContext.flush()
- ChannelHandlerContext.read()
- ChannelHandlerContext.disconnect(ChannelPromise)
- ChannelHandlerContext.close(ChannelPromise)
- ChannelHandlerContext.deregister(ChannelPromise)









** ChannelFuture

- Each of Netty's outbound I/O operations returns a =ChannelFuture=

*** 类继承关系

#+HTML: <img src="https://image-static.segmentfault.com/261/392/2613926792-5a688f9f53f61"/>


* 代码示例

** ChannelHandler

*** 使用业务线程池

#+BEGIN_SRC java
   static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);

   ChannelPipeline pipeline = ch.pipeline();

   pipeline.addLast("decoder", new MyProtocolDecoder());
   pipeline.addLast("encoder", new MyProtocolEncoder());

   // Tell the pipeline to run MyBusinessLogicHandler's event handler methods
   // in a different thread than an I/O thread so that the I/O thread is not blocked by
   // a time-consuming task.
   // If your business logic is fully asynchronous or finished very quickly, you don't
   // need to specify a group.
   pipeline.addLast(group, "handler", new MyBusinessLogicHandler());
#+END_SRC


*** 常用编解码器

- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/delimiterbasedframe][DelimiterBased]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/lengthfieldbasedframe][LengthFieldBased]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/httpcodec][HttpCodec]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/idlestate][IdleState]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/messagetobyte][MessageToByte]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/replayingdecoder][ReplayingDecoder]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/websocket][WebSocket]]

** TLS

*** Pre Master Secret

  #+BEGIN_SRC java

    private static final SslContext sslContext = SslContextBuilder
        .forClient()
        .sessionCacheSize(8192L)
        .sessionTimeout(60L)
        .trustManager(InsecureTrustManagerFactory.INSTANCE)
        .build();

    public void doConnect() {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap b = new Bootstrap();
        b.group(group)
            .channel(NioSocketChannel.class)
            .remoteAddress("127.0.0.1", 30443)
            .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        SSLEngine engine = sslContext.newEngine(ch.alloc());

                        Method initHandshakerMethod = engine.getClass().getDeclaredMethod("initHandshaker");
                        initHandshakerMethod.setAccessible(true);
                        initHandshakerMethod.invoke(engine);

                        Field handshakerField = engine.getClass().getDeclaredField("handshaker");
                        handshakerField.setAccessible(true);
                        Object handShakerObj = handshakerField.get(engine);

                        SslHandler sslHandler = new SslHandler(engine);
                        sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
                                @Override
                                public void operationComplete(Future<Channel> future) throws Exception {
                                    if (future.isSuccess()) {
                                        SSLSession session = engine.getSession();
                                        Field masterSecretField = session.getClass().getDeclaredField("masterSecret");
                                        masterSecretField.setAccessible(true);
                                        SecretKey k = (SecretKey)masterSecretField.get(session);
                                        String preMasterSecretString = BaseEncoding.base16().encode(k.getEncoded()).toLowerCase();

                                        Class<?> handshakerClass = Class.forName("sun.security.ssl.Handshaker");
                                        Field clientRandomField = handshakerClass.getDeclaredField("clnt_random");
                                        clientRandomField.setAccessible(true);
                                        Object clientRandomObj = clientRandomField.get(handShakerObj);
                                        Field randomBytesField = clientRandomObj.getClass().getDeclaredField("random_bytes");
                                        randomBytesField.setAccessible(true);
                                        byte[] randomBytes = (byte[])randomBytesField.get(clientRandomObj);
                                        String clientRandom = BaseEncoding.base16().encode(randomBytes).toLowerCase();
                                        /* this log trace can be used in SSLKEYLOGFILE understood by wireshark */
                                        log.info("CLIENT_RANDOM {} {}", clientRandom, preMasterSecretString);
                                    }
                                }
                            });

                        ch.pipeline().addLast(sslHandler);
                        ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
                                    // TODO
                                }
                            });
                    }
                });
        b.connect();
    }
  #+END_SRC



* 参考资料

** EventLoop

- [[https://caorong.github.io/2016/12/24/head-first-netty-1/][深入浅出Netty - EventLoop, EventLoopGroup]]

** ByteBuf

- [[https://caorong.github.io/2017/01/16/head-first-netty-3/][深入浅出Netty - ByteBuf 和 ByteBufPool]]
- [[https://blog.lovezhy.cc/2018/10/03/netty%E5%86%85%E5%AD%98%E6%B1%A0%E5%AE%9E%E7%8E%B0/][Netty内存池实现]]
- [[https://www.jianshu.com/p/ce7c6f5cb5f6][Netty 内存管理: PooledByteBufAllocator & PoolArena 代码探险]]
- [[https://www.jianshu.com/p/ed43572052ae][Netty 内存管理探险: PoolArena 分配之谜]]
- [[https://www.jianshu.com/p/499bd48ef101][Netty 内存管理探险: PoolArena 统计之BUG和解决]]