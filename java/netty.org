#+TITLE:     Netty
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 核心组件

** EventLoop

*** 类继承关系

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/07fig02_alt.jpg"/>

*** 线程模型

[[file:img/netty_eventloop.png]]


- 一个 EventLoopGroup 中包含一个或多个 EventLoop
- 一个 EventLoop 在整个生命周期中 *只会绑定一个 Thread*
- 所有由 EventLoop 处理的 I/O 事件都将在与其关联的 Thread 上进行处理
- 一个 Channel 在整个生命周期中 *只会注册在一个 EventLoop 上* （保证线程安全）
- 一个 EventLoop 在运行过程中，会被分配给一个或者多个 Channel

**** Reactor 模型

#+HTML: <img src="http://static.oschina.net/uploads/space/2013/1125/130828_uKWD_190591.jpeg"/>

- mainReactor 对应 bossGroup
- subReactor 对应 workerGroup ，本质是 *IO 线程池* ，负责 IO 事件
- Thread Pool 对应用户业务的线程池（即不阻塞 IO 线程池）



** ChannelPipeline

#+BEGIN_EXAMPLE
                                              I/O Request via Channel or ChannelHandlerContext
                                                        |
    +---------------------------------------------------+---------------+
    |                           ChannelPipeline         |               |
    |                                                  \|/              |
    |    +---------------------+            +-----------+----------+    |
    |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  .               |
    |               .                                   .               |
    | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
    |        [ method call]                       [method call]         |
    |               .                                   .               |
    |               .                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    +---------------+-----------------------------------+---------------+
                    |                                  \|/
    +---------------+-----------------------------------+---------------+
    |               |                                   |               |
    |       [ Socket.read() ]                    [ Socket.write() ]     |
    |                                                                   |
    |  Netty Internal I/O Threads (Transport Implementation)            |
    +-------------------------------------------------------------------+

#+END_EXAMPLE

*** Propagation Methods

**** Inbound

- ChannelHandlerContext.fireChannelRegistered()
- ChannelHandlerContext.fireChannelActive()
- ChannelHandlerContext.fireChannelRead(Object)
- ChannelHandlerContext.fireChannelReadComplete()
- ChannelHandlerContext.fireExceptionCaught(Throwable)
- ChannelHandlerContext.fireUserEventTriggered(Object)
- ChannelHandlerContext.fireChannelWritabilityChanged()
- ChannelHandlerContext.fireChannelInactive()
- ChannelHandlerContext.fireChannelUnregistered()

**** Outbound

- ChannelHandlerContext.bind(SocketAddress, ChannelPromise)
- ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)
- ChannelHandlerContext.write(Object, ChannelPromise)
- ChannelHandlerContext.flush()
- ChannelHandlerContext.read()
- ChannelHandlerContext.disconnect(ChannelPromise)
- ChannelHandlerContext.close(ChannelPromise)
- ChannelHandlerContext.deregister(ChannelPromise)









** ChannelFuture

*** 类继承关系

#+HTML: <img src="https://image-static.segmentfault.com/261/392/2613926792-5a688f9f53f61"/>

* 代码示例

** ChannelHandler

*** 使用业务线程池

#+BEGIN_SRC java
   static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);

   ChannelPipeline pipeline = ch.pipeline();

   pipeline.addLast("decoder", new MyProtocolDecoder());
   pipeline.addLast("encoder", new MyProtocolEncoder());

   // Tell the pipeline to run MyBusinessLogicHandler's event handler methods
   // in a different thread than an I/O thread so that the I/O thread is not blocked by
   // a time-consuming task.
   // If your business logic is fully asynchronous or finished very quickly, you don't
   // need to specify a group.
   pipeline.addLast(group, "handler", new MyBusinessLogicHandler());
#+END_SRC


** TLS

*** Pre Master Secret

  #+BEGIN_SRC java

    private static final SslContext sslContext = SslContextBuilder
        .forClient()
        .sessionCacheSize(8192L)
        .sessionTimeout(60L)
        .trustManager(InsecureTrustManagerFactory.INSTANCE)
        .build();

    public void doConnect() {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap b = new Bootstrap();
        b.group(group)
            .channel(NioSocketChannel.class)
            .remoteAddress("127.0.0.1", 30443)
            .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        SSLEngine engine = sslContext.newEngine(ch.alloc());

                        Method initHandshakerMethod = engine.getClass().getDeclaredMethod("initHandshaker");
                        initHandshakerMethod.setAccessible(true);
                        initHandshakerMethod.invoke(engine);

                        Field handshakerField = engine.getClass().getDeclaredField("handshaker");
                        handshakerField.setAccessible(true);
                        Object handShakerObj = handshakerField.get(engine);

                        SslHandler sslHandler = new SslHandler(engine);
                        sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
                                @Override
                                public void operationComplete(Future<Channel> future) throws Exception {
                                    if (future.isSuccess()) {
                                        SSLSession session = engine.getSession();
                                        Field masterSecretField = session.getClass().getDeclaredField("masterSecret");
                                        masterSecretField.setAccessible(true);
                                        SecretKey k = (SecretKey)masterSecretField.get(session);
                                        String preMasterSecretString = BaseEncoding.base16().encode(k.getEncoded()).toLowerCase();

                                        Class<?> handshakerClass = Class.forName("sun.security.ssl.Handshaker");
                                        Field clientRandomField = handshakerClass.getDeclaredField("clnt_random");
                                        clientRandomField.setAccessible(true);
                                        Object clientRandomObj = clientRandomField.get(handShakerObj);
                                        Field randomBytesField = clientRandomObj.getClass().getDeclaredField("random_bytes");
                                        randomBytesField.setAccessible(true);
                                        byte[] randomBytes = (byte[])randomBytesField.get(clientRandomObj);
                                        String clientRandom = BaseEncoding.base16().encode(randomBytes).toLowerCase();
                                        /* this log trace can be used in SSLKEYLOGFILE understood by wireshark */
                                        log.info("CLIENT_RANDOM {} {}", clientRandom, preMasterSecretString);
                                    }
                                }
                            });

                        ch.pipeline().addLast(sslHandler);
                        ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
                                    // TODO
                                }
                            });
                    }
                });
        b.connect();
    }
  #+END_SRC



* 参考资料

- [[https://caorong.github.io/2016/12/24/head-first-netty-1/][深入浅出Netty - EventLoop, EventLoopGroup]]