#+TITLE:     Netty
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 5
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 基本概念

** IO 模型

*** BIO

[[file:img/netty-bio.png]]


*** NIO

同步非阻塞，服务器实现模式(Reactor)为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，
多路复用器轮询到连接有 I/O 请求就进行处理。

[[file:img/netty-nio.png]]

[[file:img/netty-nio2.png]]


*** AIO

异步非阻塞，AIO 引入异步通道的概念，采用了 *Proactor* 模式，简化了程序编写，有效的请求才启动线程，\\
它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。


** Selector

[[file:img/netty-selector.png]]

- *Netty 的 IO 线程 NioEventLoop 聚合了 Selector* ，可以同时并发处理成百上千个客户端连接
- 当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务
- 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道
- 由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起
一个 I/O 线程可以并发处理 N 个客户端连接和读写操作

*** 空轮询 Bug

[[https://www.cnblogs.com/qiumingcheng/p/9481528.html][jdk1.6空轮询Bug的原因及解决方法]]


** 零拷贝

零拷贝指的是从操作系统角度看，没有 cpu 拷贝。

Java 程序中，常用的零拷贝方式有 =mmap(内存映射)= 和 =sendFile=

参考：[[https://www.youtube.com/watch?v=uKIfBgcMQAs&list=PLmOn9nNkQxJH02M10mFnBW0yPRnLmRSMo&index=33][零拷贝原理剖析]]

*** 传统 I/O

[[file:img/netty-zero-trandition.png]]


*** mmap

通过内存映射，将 *文件映射到内核缓冲区 ，用户空间可以共享内核空间的数据* 。可以减少内核空间到用户空间的拷贝次数。

[[file:img/netty-zero-mmap.png]]


*** sendFile

Linux 2.1 版本提供了 =sendFile= 函数，其基本原理为：数据不经过用户态，直接从内核缓冲区进入到 =Socket Buffer= ，\\
同时，由于和用户态完全无关，就减少了一次上下文切换。

[[file:img/netty-zero-sendfile.png]]


Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 =Socket buffer= 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。

[[file:img/netty-zero-sendfile2.png]]

这里其实有一次 cpu 拷贝：kernel buffer -> socket buffer ，但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略。


* 核心组件


** ByteBuf

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/05fig03_alt.jpg"/>

*** Heap/Direct

**** Heap Buffer

- 存储于堆空间（实际数据存放在字节数组中）
- 优点：快速创建与释放，并提供直接访问内部字节数组的方法
- 缺点：进行 I/O 操作时， *需要先将数据复制到直接缓冲区中* 再进行网络传输
- 多用于业务逻辑的实现


**** Direct Buffer

- 由操作系统在本地内存中分配空间，不占用堆空间
- 优点：I/O 性能好，可以实现零拷贝
- 缺点：分配与释放速度慢（可以通过 *内存池* 解决这个问题）
- 多用于 I/O 通信


**** 发送数据时的缓冲转换

If your data were contained in a heap-allocated buffer, the JVM would, in fact,
*copy your buffer to a direct buffer internally before sending it through the socket.*

#+BEGIN_SRC java

  @Override
  protected final Object filterOutboundMessage(Object msg) { // io.netty.channel.nio.AbstractNioByteChannel.filterOutboundMessage(Object)
      if (msg instanceof ByteBuf) {
          ByteBuf buf = (ByteBuf) msg;
          if (buf.isDirect()) {
              return msg;
          }

          return newDirectBuffer(buf);
      }

      if (msg instanceof FileRegion) {
          return msg;
      }

      throw new UnsupportedOperationException("unsupported message type: " +
                                              StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
  }

  /**
   ,* Returns an off-heap copy of the specified {@link ByteBuf}, and releases the original one.
   ,* Note that this method does not create an off-heap copy if the allocation / deallocation cost is too high,
   ,* but just returns the original {@link ByteBuf}..
   ,*/
  protected final ByteBuf newDirectBuffer(ByteBuf buf) { // io.netty.channel.nio.AbstractNioChannel.newDirectBuffer(ByteBuf)
      final int readableBytes = buf.readableBytes();
      if (readableBytes == 0) {
          ReferenceCountUtil.safeRelease(buf);
          return Unpooled.EMPTY_BUFFER;
      }

      final ByteBufAllocator alloc = alloc();
      if (alloc.isDirectBufferPooled()) {
          ByteBuf directBuf = alloc.directBuffer(readableBytes);
          directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
          ReferenceCountUtil.safeRelease(buf);
          return directBuf;
      }

      final ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();
      if (directBuf != null) {
          directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
          ReferenceCountUtil.safeRelease(buf);
          return directBuf;
      }

      // Allocating and deallocating an unpooled direct buffer is very expensive; give up.
      return buf;
  }
#+END_SRC



*** Derived Buffer

A /derived buffer/ provides a view of a =ByteBuf= that represents its contents in a specialized way. \\
Such views are created by the following methods:

- duplicate()
- slice()
- slice(int, int)
- Unpooled.unmodifiableBuffer(...)
- order(ByteOrder)
- readSlice(int)

Each returns a new =ByteBuf= instance *with its own reader, writer, and marker indices*.

The internal storage is *shared* just as in a JDK =ByteBuffer=.

*** Arena

#+HTML: <img src="https://caorong.github.io/post_images/2016-11-26-23-46-26.png"/>


*** 自旋锁在引用计数实现中的应用

=AbstractReferenceCountedByteBuf:retain0(int increment)= (v4.0.15)

#+BEGIN_SRC java
  public ByteBuf retain(int increment) {
      if (increment <= 0) {
          throw new IllegalArgumentException("increment: " + increment + " (expected: > 0)");
      }

      for (;;) {
          int refCnt = this.refCnt;
          if (refCnt == 0) {
              throw new IllegalReferenceCountException(0, increment);
          }
          if (refCnt > Integer.MAX_VALUE - increment) {
              throw new IllegalReferenceCountException(refCnt, increment);
          }
          if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) { // CAS operation
              break;
          }
      }
      return this;
  }
#+END_SRC



*** 在 Pipeline 中的创建与释放

**** 初始 ByteBuf 创建

参见 =io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read()=

**** 最终 ByteBuf 释放

参见:

- =TailContext.userEventTriggered(ChannelHandlerContext, Object)=
- =HeadContext.write(ChannelHandlerContext, Object, ChannelPromise)=


** EventLoop/EventLoopGroup

*** 类继承关系

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/07fig02_alt.jpg"/>


*** 线程模型

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig01.jpg"/></br>

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig04_alt.jpg"/>

[[file:img/netty_eventloop.png]]

- An =EventLoopGroup= contains one or more =EventLoops=
- An =EventLoop= is bound to a *single Thread* for its lifetime
- All I/O events processed by an EventLoop are handled on its dedicated =Thread=
- A =Channel= is registered for its lifetime *with a single EventLoop* (eliminates the need for synchronization)
- A single =EventLoop= may be assigned to one or more =Channels=

**** NioEventLoop 执行逻辑

#+HTML: <img src="https://caorong.github.io/post_images/2016-11-25-01-23-15.png"/>


**** Selector.wakeup()

java 的 Selector 在原生的 select api 之上 增加了个 =Selector.wakeup()= ，目的是唤醒阻塞在 =select()= 的线程。(*通过写入一个字节*)

在下述时刻需要被唤醒：

1. 注册了新的 channel 或者事件
2. channel 关闭， 取消注册
3. 优先级更高的事件触发（如定时器事件），希望及时处理


**** Epoll bug 修复

#+BEGIN_SRC java
  for(;;){
      int selectedKeys = selector.select(timeoutMillis); // select with timeout
      selectCnt ++;
      // 由于 select 阻塞 而等待了 timeoutMillis 毫秒， 说明阻塞了，没有 bug
      if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
          selectCnt = 1;
      } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
                 selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
          // 在小于 timeoutMillis 毫秒的时间内 select 的次数超过了 阀值(512) 次
          rebuildSelector();
          selector = this.selector;

          selector.selectNow();// Select again
          selectCnt = 1;
          break;
      }
  }
#+END_SRC


**** Reactor 模型

#+HTML: <img src="http://static.oschina.net/uploads/space/2013/1125/130828_uKWD_190591.jpeg"/>

- mainReactor 对应 bossGroup
- subReactor 对应 workerGroup ，本质是 *IO 线程池* ，负责 IO 事件
- Thread Pool 对应用户业务的线程池（即不阻塞 IO 线程池）

Reactor 模式中核心组成:

- Reactor

  在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应
- Handlers

  处理程序执行 I/O 事件要完成的实际事件


根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：

- 单 Reactor 单线程
- 单 Reactor 多线程
- 主从 Reactor 多线程


***** 单 Reactor 单线程

[[file:img/netty-reactor1.png]]

***** 单 Reactor 多线程

[[file:img/netty-reactor2.png]]

- 优点

  可以充分的利用多核cpu的处理能力
- 缺点

  多线程数据共享和访问比较复杂，Reactor 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈


***** 主从 Reactor 多线程

file:img/netty-reactor3.png

- 优点

  父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。\\
父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。
- 缺点

  编程复杂度较高

Nginx ，Memcached 和 Netty 都是基于主从多线程模型。

参考：[[https://www.youtube.com/watch?v=fCFGxmj_8w8&list=PLmOn9nNkQxJH02M10mFnBW0yPRnLmRSMo&index=41][主从Reactor模式]]


***** Netty 模型

file:img/netty-reactor4.png


- Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写
- BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup
- NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop
- NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector ，用于监听绑定在其上的 socket 的网络通讯
- NioEventLoopGroup 可以有多个线程，即可以含有多个 NioEventLoop
- 每个 BossNioEventLoop 循环执行的步骤有:
  - 轮询 accept 事件
  - 处理 accept 事件，与 client 建立连接，生成 NioScocketChannel ，并将其注册到某个 worker NIOEventLoop 上的 selector
  - 处理任务队列的任务，即 =runAllTasks=
- 每个 WorkerNIOEventLoop 循环执行的步骤
  - 轮询 read/write 事件
  - 处理 i/o 事件，即 read/write 事件，在对应 NioScocketChannel 处理
  - 处理任务队列的任务，即 =runAllTasks=
- 每个 WorkerNIOEventLoop 处理业务时，会使用pipeline(管道)，pipeline 中包含了 channel，即通过 pipeline 可以获取到对应通道，管道中维护了很多处理器


*** 任务队列

EventLoop 拥有 2 种任务队列:

**** 自定义的普通任务

这类任务将提交该 channel 对应的 EventLoop 的 =taskQueue= 中：

#+BEGIN_SRC java
  ctx.channel().eventLoop().execute(new Runnable() {
          @Override
          public void run() {
              // 耗时任务
          }
      });

#+END_SRC


**** 自定义定时任务

该任务是提交到 =scheduledTaskQueue= 中:

#+BEGIN_SRC java
  ctx.channel().eventLoop().schedule(new Runnable() {
          @Override
          public void run() {
              // TODO
          }
      }, 5, TimeUnit.SECONDS);
#+END_SRC




** Channel

*** 类继承关系

#+BEGIN_SRC plantuml :file img/channel_classes.png :eval never-export
  interface Channel

  interface Comparable
  interface ChannelOutboundInvoker
  interface AttributeMap

  interface ServerChannel
  interface ChannelPipeline
  interface ChannelConfig

  interface EventLoop

  abstract class AbstractChannel


  Channel .up.|> Comparable
  Channel .up.|> ChannelOutboundInvoker
  Channel .up.|> AttributeMap

  ServerChannel .up.|> Channel
  AbstractChannel .up.|> Channel

  Channel *-down-> ChannelPipeline
  Channel *-down-> ChannelConfig
  Channel *-down-> EventLoop




#+END_SRC

#+RESULTS:
[[file:img/channel_classes.png]]


*** Selecting and processing state changes

The possible state changes are:

- A new =Channel= was accepted and is ready. (OP_ACCEPT)
- A =Channel= connection was completed. (OP_CONNECT)
- A =Channel= has data that is ready for reading. (OP_READ)
- A =Channel= is available for writing data. (OP_WRITE)


#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/04fig02_alt.jpg"/>


** ChannelHandler/ChannelPipeline

#+BEGIN_EXAMPLE
                                              I/O Request via Channel or ChannelHandlerContext
                                                        |
    +---------------------------------------------------+---------------+
    |                           ChannelPipeline         |               |
    |                                                  \|/              |
    |    +---------------------+            +-----------+----------+    |
    |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  .               |
    |               .                                   .               |
    | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
    |        [ method call]                       [method call]         |
    |               .                                   .               |
    |               .                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    |               |                                  \|/              |
    |    +----------+----------+            +-----------+----------+    |
    |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
    |    +----------+----------+            +-----------+----------+    |
    |              /|\                                  |               |
    +---------------+-----------------------------------+---------------+
                    |                                  \|/
    +---------------+-----------------------------------+---------------+
    |               |                                   |               |
    |       [ Socket.read() ]                    [ Socket.write() ]     |
    |                                                                   |
    |  Netty Internal I/O Threads (Transport Implementation)            |
    +-------------------------------------------------------------------+

#+END_EXAMPLE

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/03fig03_alt.jpg"/>

*** 类继承关系

#+BEGIN_SRC plantuml :file img/channelhandler_classes.png :eval never-export
  interface ChannelHandler {
      void handlerAdded(ChannelHandlerContext ctx) throws Exception;
      void handlerRemoved(ChannelHandlerContext ctx) throws Exception;
  }

  interface ChannelInboundHandler {
      void channelRegistered(ChannelHandlerContext ctx) throws Exception;
      void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
      void channelActive(ChannelHandlerContext ctx) throws Exception;
      void channelInactive(ChannelHandlerContext ctx) throws Exception;
      void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;
      void channelReadComplete(ChannelHandlerContext ctx) throws Exception;
      void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
      void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;
      void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
  }

  interface ChannelOutboundHandler {
      void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;
      void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception;
      void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
      void read(ChannelHandlerContext ctx) throws Exception;
      void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;
      void flush(ChannelHandlerContext ctx) throws Exception;
  }

  abstract class ChannelHandlerAdapter
  class ChannelInboundHandlerAdapter
  class ChannelOutboundHandlerAdapter

  ChannelInboundHandler -up-> ChannelHandler
  ChannelOutboundHandler -up-> ChannelHandler

  ChannelHandlerAdapter .up.|> ChannelHandler

  ChannelInboundHandlerAdapter .up.|> ChannelInboundHandler
  ChannelInboundHandlerAdapter -up-> ChannelHandlerAdapter

  ChannelOutboundHandlerAdapter .up.|> ChannelOutboundHandler
  ChannelOutboundHandlerAdapter -up-> ChannelHandlerAdapter


#+END_SRC

#+RESULTS:
[[file:img/channelhandler_classes.png]]


*** ChannelHandlerContext

A =ChannelHandlerContext= represents an association between a =ChannelHandler= and a =ChannelPipeline= and is created whenever
a =ChannelHandler= is added to a =ChannelPipeline=.

The =ChannelHandlerContext= associated with a =ChannelHandler= never changes, so it's safe to cache a reference to it.

**** Propagation via Channel/ChannelPipeline

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/06fig05_alt.jpg"/>

**** Propagation via ChannelHandlerContext

#+HTML: <img src="https://dpzbhybb2pdcj.cloudfront.net/maurer/Figures/06fig06_alt.jpg"/>

*** Propagation Methods

**** Inbound

- ChannelHandlerContext.fireChannelRegistered()
- ChannelHandlerContext.fireChannelActive()
- ChannelHandlerContext.fireChannelRead(Object)
- ChannelHandlerContext.fireChannelReadComplete()
- ChannelHandlerContext.fireExceptionCaught(Throwable)
- ChannelHandlerContext.fireUserEventTriggered(Object)
- ChannelHandlerContext.fireChannelWritabilityChanged()
- ChannelHandlerContext.fireChannelInactive()
- ChannelHandlerContext.fireChannelUnregistered()

**** Outbound

- ChannelHandlerContext.bind(SocketAddress, ChannelPromise)
- ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)
- ChannelHandlerContext.write(Object, ChannelPromise)
- ChannelHandlerContext.flush()
- ChannelHandlerContext.read()
- ChannelHandlerContext.disconnect(ChannelPromise)
- ChannelHandlerContext.close(ChannelPromise)
- ChannelHandlerContext.deregister(ChannelPromise)









** ChannelFuture

- Each of Netty's outbound I/O operations returns a =ChannelFuture=

*** 类继承关系

#+HTML: <img src="https://image-static.segmentfault.com/261/392/2613926792-5a688f9f53f61"/>


* 代码示例

** ChannelHandler

*** 使用业务线程池

#+BEGIN_SRC java
   static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);

   ChannelPipeline pipeline = ch.pipeline();

   pipeline.addLast("decoder", new MyProtocolDecoder());
   pipeline.addLast("encoder", new MyProtocolEncoder());

   // Tell the pipeline to run MyBusinessLogicHandler's event handler methods
   // in a different thread than an I/O thread so that the I/O thread is not blocked by
   // a time-consuming task.
   // If your business logic is fully asynchronous or finished very quickly, you don't
   // need to specify a group.
   pipeline.addLast(group, "handler", new MyBusinessLogicHandler());
#+END_SRC


*** 常用编解码器

- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/delimiterbasedframe][DelimiterBased]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/lengthfieldbasedframe][LengthFieldBased]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/httpcodec][HttpCodec]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/idlestate][IdleState]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/messagetobyte][MessageToByte]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/replayingdecoder][ReplayingDecoder]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/main/java/com/hao/notes/netty/channelhandler/websocket][WebSocket]]

** TLS

*** Pre Master Secret

  #+BEGIN_SRC java

    private static final SslContext sslContext = SslContextBuilder
        .forClient()
        .sessionCacheSize(8192L)
        .sessionTimeout(60L)
        .trustManager(InsecureTrustManagerFactory.INSTANCE)
        .build();

    public void doConnect() {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap b = new Bootstrap();
        b.group(group)
            .channel(NioSocketChannel.class)
            .remoteAddress("127.0.0.1", 30443)
            .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        SSLEngine engine = sslContext.newEngine(ch.alloc());

                        Method initHandshakerMethod = engine.getClass().getDeclaredMethod("initHandshaker");
                        initHandshakerMethod.setAccessible(true);
                        initHandshakerMethod.invoke(engine);

                        Field handshakerField = engine.getClass().getDeclaredField("handshaker");
                        handshakerField.setAccessible(true);
                        Object handShakerObj = handshakerField.get(engine);

                        SslHandler sslHandler = new SslHandler(engine);
                        sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
                                @Override
                                public void operationComplete(Future<Channel> future) throws Exception {
                                    if (future.isSuccess()) {
                                        SSLSession session = engine.getSession();
                                        Field masterSecretField = session.getClass().getDeclaredField("masterSecret");
                                        masterSecretField.setAccessible(true);
                                        SecretKey k = (SecretKey)masterSecretField.get(session);
                                        String preMasterSecretString = BaseEncoding.base16().encode(k.getEncoded()).toLowerCase();

                                        Class<?> handshakerClass = Class.forName("sun.security.ssl.Handshaker");
                                        Field clientRandomField = handshakerClass.getDeclaredField("clnt_random");
                                        clientRandomField.setAccessible(true);
                                        Object clientRandomObj = clientRandomField.get(handShakerObj);
                                        Field randomBytesField = clientRandomObj.getClass().getDeclaredField("random_bytes");
                                        randomBytesField.setAccessible(true);
                                        byte[] randomBytes = (byte[])randomBytesField.get(clientRandomObj);
                                        String clientRandom = BaseEncoding.base16().encode(randomBytes).toLowerCase();
                                        /* this log trace can be used in SSLKEYLOGFILE understood by wireshark */
                                        log.info("CLIENT_RANDOM {} {}", clientRandom, preMasterSecretString);
                                    }
                                }
                            });

                        ch.pipeline().addLast(sslHandler);
                        ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
                                    // TODO
                                }
                            });
                    }
                });
        b.connect();
    }
  #+END_SRC



* 参考资料

** EventLoop

- [[https://caorong.github.io/2016/12/24/head-first-netty-1/][深入浅出Netty - EventLoop, EventLoopGroup]]

** ByteBuf

- [[https://caorong.github.io/2016/08/27/netty-hole/][使用 PooledByteBuf，一定要注意 allocate 和 release 是同一个线程]]
- [[https://caorong.github.io/2017/01/16/head-first-netty-3/][深入浅出Netty - ByteBuf 和 ByteBufPool]]
- [[https://blog.lovezhy.cc/2018/10/03/netty%E5%86%85%E5%AD%98%E6%B1%A0%E5%AE%9E%E7%8E%B0/][Netty内存池实现]]
- [[https://www.jianshu.com/p/ce7c6f5cb5f6][Netty 内存管理: PooledByteBufAllocator & PoolArena 代码探险]]
- [[https://www.jianshu.com/p/ed43572052ae][Netty 内存管理探险: PoolArena 分配之谜]]
- [[https://www.jianshu.com/p/499bd48ef101][Netty 内存管理探险: PoolArena 统计之BUG和解决]]