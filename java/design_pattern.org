#+TITLE:     设计模式
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 3
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 结构型模式

** 装饰者模式

*** 模式定义

#+BEGIN_EXAMPLE
  动态地将责任附加到对象上。当需要扩展时，使用该模式比使用继承更有弹性。
#+END_EXAMPLE

- 装饰者和被装饰者对象拥有相同的超类型
- 装饰者可以在所委托被装饰者的行为前后，加上自己的行为，已达到特定的目的
- 可以在运行时动态地，不限量的使用合适的装饰者来装饰对象



*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/decorator.gif"/>


*** Participants

- Component   (LibraryItem)
  - defines the interface for objects that can have responsibilities added to them dynamically.
- ConcreteComponent   (Book, Video)
  - defines an object to which additional responsibilities can be attached.
- Decorator   (Decorator)
  - maintains a reference to a Component object and defines an interface that conforms to Component's interface.
- ConcreteDecorator   (Borrowable)
  - adds responsibilities to the component.


* 行为型模式

** 观察者模式

*** 模式定义

定义了对象间一对多的依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/observer.gif"/>


*** Participants

- Subject  (Stock)
  - knows its observers. Any number of Observer objects may observe a subject
  - provides an interface for attaching and detaching Observer objects.
- ConcreteSubject  (IBM)
  - stores state of interest to ConcreteObserver
  - sends a notification to its observers when its state changes
- Observer  (IInvestor)
  - defines an updating interface for objects that should be notified of changes in a subject.
- ConcreteObserver  (Investor)
  - maintains a reference to a ConcreteSubject object
  - stores state that should stay consistent with the subject's
  - implements the Observer updating interface to keep its state consistent with the subject's




** 策略模式

*** 模式定义

策略模式封装了了算法族（行为族），使它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/strategy.gif"/>

*** Participants

- Strategy  (SortStrategy)
  - declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a ConcreteStrategy
- ConcreteStrategy  (QuickSort, ShellSort, MergeSort)
  - implements the algorithm using the Strategy interface
- Context  (SortedList)
  - is configured with a ConcreteStrategy object
  - maintains a reference to a Strategy object
  - may define an interface that lets Strategy access its data.




* 创建型模式

** 单例模式

*** 模式定义

确保一个类只有一个实例，并提供一个全局访问点。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/singleton.gif"/>


*** Participants

- Singleton   (LoadBalancer)
  - defines an Instance operation that lets clients access its unique instance. Instance is a class operation.
  - responsible for creating and maintaining its own unique instance.

*** 代码示例

**** Eagely

#+BEGIN_SRC java
  public class Singleton {
      private static Singleton instance = new Singleton();

      private Singleton() {}

      public static Singleton getInstance() {
          return instance;
      }
  }
#+END_SRC


**** Lazy

#+BEGIN_SRC java
  public class Singleton {
      private volatile static Singleton instance;

      private Singleton() {}

      public static Singleton getInstance() {
          if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }

              }
          }
          return instance;
      }
  }
#+END_SRC

** 工厂方法模式

*** 模式定义

定义了一个创建对象的接口，由子类决定要实例化哪个具体类。该模式将实例化类的任务委托给子类。

换句话说，工厂方法模式把简单工厂的内部逻辑判断移到了客户端代码来进行。 *如要新增功能，不用修改工厂类，修改客户端即可* 。


*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/factory.gif"/>

- 创建者（Creator）类
  抽象类，定义一个 *抽象的工厂方法* ，子类实现此方法制造产品。创建者通常会包含依赖于抽象产品的代码，而这些抽象产品由子类制造。创建者不需要知道具体产品类型。


*** Participants

- Product  (Page)
  - defines the interface of objects the factory method creates
- ConcreteProduct  (SkillsPage, EducationPage, ExperiencePage)
  - implements the Product interface
- Creator  (Document)
  - declares the factory method, which returns an object of type Product. Creator may also define a default implementation of the factory method that returns a default ConcreteProduct object.
  - may call the factory method to create a Product object.
- ConcreteCreator  (Report, Resume)
  - overrides the factory method to return an instance of a ConcreteProduct.



** 抽象工厂模式

*** 模式定义

提供一个接口，用于创建一个 *创建对象的家族* 。

换句话说，该模式的任务是定义一个负责创建 *一组* 产品的接口。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/abstract.gif"/>

*** Participants


- AbstractFactory  (ContinentFactory)
  - declares an interface for operations that create abstract products
- ConcreteFactory   (AfricaFactory, AmericaFactory)
  - implements the operations to create concrete product objects
- AbstractProduct   (Herbivore, Carnivore)
  - declares an interface for a type of product object
- Product  (Wildebeest, Lion, Bison, Wolf)
  - defines a product object to be created by the corresponding concrete factory
  - implements the AbstractProduct interface
- Client  (AnimalWorld)
  - uses interfaces declared by AbstractFactory and AbstractProduct classes
