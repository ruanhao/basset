#+TITLE:     设计模式
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 2
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 各类模式设计目的

- 装饰者模式   :: 不改变接口，但加入责任
- 状态模式     :: 封装了基于状态的行为，并使用委托在行为之间切换
- 迭代器模式   :: 在对象的集合之中游走，不暴露集合的实现
- 适配器模式   :: 将一个接口转成另一个接口
- 外观模式     :: 让接口更简单
- 模板方法模式 :: 子类决定如何实现算法中的步骤
- 策略模式     :: 封装可互换的行为，然后使用委托来决定要采用哪一个行为
- 工厂方法模式 :: 由子类决定实例化哪个具体类
- 观察者模式   :: 让对象能在状态改变时被通知
- 组合模式     :: 用一致性的方式处理对象集合和单个对象
- 单件模式     :: 有且只有一个对象被创建
- 抽象工厂模式 :: 允许客户创建对象的家族，而无需指定他们的具体类
- 命令模式     :: 封装请求称为对象




* 结构型模式

** 蝇量模式

*** 定义

用来提供许多“虚拟实例”

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/flyweight.gif"/>


**** Participants

- Flyweight   (Character)
  - declares an interface through which flyweights can receive and act on extrinsic state.
- ConcreteFlyweight   (CharacterA, CharacterB, ..., CharacterZ)
  - implements the Flyweight interface and adds storage for intrinsic state, if any. A ConcreteFlyweight object must be sharable. Any state it stores must be intrinsic, that is, it must be independent of the ConcreteFlyweight object's context.
- UnsharedConcreteFlyweight   ( not used )
  - not all Flyweight subclasses need to be shared. The Flyweight interface enables sharing, but it doesn't enforce it. It is common for UnsharedConcreteFlyweight objects to have ConcreteFlyweight objects as children at some level in the flyweight object structure (as the Row and Column classes have).
- FlyweightFactory   (CharacterFactory)
  - creates and manages flyweight objects
  - ensures that flyweight are shared properly. When a client requests a flyweight, the FlyweightFactory objects assets an existing instance or creates one, if none exists.
- Client   (FlyweightApp)
  - maintains a reference to flyweight(s).
  - computes or stores the extrinsic state of flyweight(s).


** 桥接模式

*** 定义

抽象和实现相互解耦。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/bridge.gif"/>

**** Participants

- Abstraction   (BusinessObject)
  - defines the abstraction's interface.
  - maintains a reference to an object of type Implementor.
- RefinedAbstraction   (CustomersBusinessObject)
  - extends the interface defined by Abstraction.
- Implementor   (DataObject)
  - defines the interface for implementation classes. This interface doesn't have to correspond exactly to Abstraction's interface; in fact the two interfaces can be quite different. Typically the Implementation interface provides only primitive operations, and Abstraction defines higher-level operations based on these primitives.
- ConcreteImplementor   (CustomersDataObject)
  - implements the Implementor interface and defines its concrete implementation.


** 适配器模式

*** 定义

将一个类的接口，转换成客户期望的另一个接口。让原本接口不兼容的类可以合作无间。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/adapter.gif"/>


**** Participants

- Target   (ChemicalCompound)
  - defines the domain-specific interface that Client uses.
- Adapter   (Compound)
  - adapts the interface Adaptee to the Target interface.
- Adaptee   (ChemicalDatabank)
  - defines an existing interface that needs adapting.
- Client   (AdapterApp)
  - collaborates with objects conforming to the Target interface.


** 装饰者模式

*** 定义

#+BEGIN_EXAMPLE
  动态地将责任附加到对象上。当需要扩展时，使用该模式比使用继承更有弹性。
#+END_EXAMPLE

- 装饰者和被装饰者对象拥有相同的超类型
- 装饰者可以在所委托被装饰者的行为前后，加上自己的行为，已达到特定的目的
- 可以在运行时动态地，不限量的使用合适的装饰者来装饰对象



*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/decorator.gif"/>


**** Participants

- Component   (LibraryItem)
  - defines the interface for objects that can have responsibilities added to them dynamically.
- ConcreteComponent   (Book, Video)
  - defines an object to which additional responsibilities can be attached.
- Decorator   (Decorator)
  - maintains a reference to a Component object and defines an interface that conforms to Component's interface.
- ConcreteDecorator   (Borrowable)
  - adds responsibilities to the component.


** 外观模式

*** 定义

提供一个统一的接口，用来访问子系统中的一群接口。

外观定义了一个高层接口，让子系统更容易使用，即 *简化接口* 。


*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/facade.gif"/>


**** Participants

- Facade   (MortgageApplication)
  - knows which subsystem classes are responsible for a request.
  - delegates client requests to appropriate subsystem objects.
- Subsystem classes   (Bank, Credit, Loan)
  - implement subsystem functionality.
  - handle work assigned by the Facade object.
  - have no knowledge of the facade and keep no reference to it.







** 组合模式

*** 定义

允许将对象组合成树形结构来表现“整体/部分“层次结构， 树里面包含了组合以及个别对象。

组合能让客户以一致的方式处理个别对象以及对象组合，即忽略对象组合和个别对象之间的差别。



*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/composite.gif"/>


**** Participants

- Component   (DrawingElement)
  - declares the interface for objects in the composition.
  - implements default behavior for the interface common to all classes, as appropriate.
  - declares an interface for accessing and managing its child components.
  - (optional) defines an interface for accessing a component's parent in the recursive structure, and implements it if that's appropriate.
- Leaf   (PrimitiveElement)
  - represents leaf objects in the composition. A leaf has no children.
  - defines behavior for primitive objects in the composition.
- Composite   (CompositeElement)
  - defines behavior for components having children.
  - stores child components.
  - implements child-related operations in the Component interface.
- Client  (CompositeApp)
  - manipulates objects in the composition through the Component interface.



** 代理模式

*** 定义

为另一个对象提供一个替身或占位符以控制对这个对象的访问。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/proxy.gif"/>

**** Participants

- Proxy   (MathProxy)
  - maintains a reference that lets the proxy access the real subject. Proxy may refer to a Subject if the RealSubject and Subject interfaces are the same.
  - provides an interface identical to Subject's so that a proxy can be substituted for for the real subject.
  - controls access to the real subject and may be responsible for creating and deleting it.
  - other responsibilites depend on the kind of proxy:
    - *remote proxies* are responsible for encoding a request and its arguments and for sending the encoded request to the real subject in a different address space.
    - *virtual proxies* may cache additional information about the real subject so that they can postpone accessing it. For example, the ImageProxy from the Motivation caches the real images's extent.
    - *protection proxies* check that the caller has the access permissions required to perform a request.
- Subject   (IMath)
  - defines the common interface for RealSubject and Proxy so that a Proxy can be used anywhere a RealSubject is expected.
- RealSubject   (Math)
  - defines the real object that the proxy represents.


* 行为型模式

** 解释器模式

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/interpreter.gif"/>


**** Participants

- AbstractExpression  (Expression)
  - declares an interface for executing an operation
- TerminalExpression  ( ThousandExpression, HundredExpression, TenExpression, OneExpression )
  - implements an Interpret operation associated with terminal symbols in the grammar.
  - an instance is required for every terminal symbol in the sentence.
- NonterminalExpression  ( not used )
  - one such class is required for every rule R ::= R1R2...Rn in the grammar
  - maintains instance variables of type AbstractExpression for each of the symbols R1 through Rn.
  - implements an Interpret operation for nonterminal symbols in the grammar. Interpret typically calls itself recursively on the variables representing R1 through Rn.
- Context  (Context)
  - contains information that is global to the interpreter
- Client  (InterpreterApp)
  - builds (or is given) an abstract syntax tree representing a particular sentence in the language that the grammar defines. The abstract syntax tree is assembled from instances of the NonterminalExpression and TerminalExpression classes
  - invokes the Interpret operation


** 命令模式

*** 定义

将 =请求= 封装成对象，当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/command.gif"/>

**** Participants

- Command  (Command)
  - declares an interface for executing an operation
- ConcreteCommand  (CalculatorCommand)
  - defines a binding between a Receiver object and an action
  - implements Execute by invoking the corresponding operation(s) on Receiver
- Client  (CommandApp)
  - creates a ConcreteCommand object and sets its receiver
- Invoker  (User)
  - asks the command to carry out the request
- Receiver  (Calculator)
  - knows how to perform the operations associated with carrying out the request.

*** 命令模式与策略模式的区别

- 策略模式是通过不同的算法做同一件事情，而命令模式则是通过不同的命令做不同的事情，常含有接收者。设计目标不同
- 命令模式含有不同的命令，隐藏接收者执行细节，做不同的事情；而策略模式含有不同的算法，做相同的事情
- 命令模式含有接收者，策略模式不含有
- 命令模式中的命令可以单独运行




** 观察者模式

*** 定义

定义了对象间一对多的依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/observer.gif"/>


**** Participants

- Subject  (Stock)
  - knows its observers. Any number of Observer objects may observe a subject
  - provides an interface for attaching and detaching Observer objects.
- ConcreteSubject  (IBM)
  - stores state of interest to ConcreteObserver
  - sends a notification to its observers when its state changes
- Observer  (IInvestor)
  - defines an updating interface for objects that should be notified of changes in a subject.
- ConcreteObserver  (Investor)
  - maintains a reference to a ConcreteSubject object
  - stores state that should stay consistent with the subject's
  - implements the Observer updating interface to keep its state consistent with the subject's




** 策略模式

*** 定义

策略模式封装了了算法族（行为族），使它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

策略模式是使用继承的一种弹性替代方案。


*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/strategy.gif"/>

**** Participants

- Strategy  (SortStrategy)
  - declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a ConcreteStrategy
- ConcreteStrategy  (QuickSort, ShellSort, MergeSort)
  - implements the algorithm using the Strategy interface
- Context  (SortedList)
  - is configured with a ConcreteStrategy object
  - maintains a reference to a Strategy object
  - may define an interface that lets Strategy access its data.




** 模板方法模式

*** 定义

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。


*** 代码示例

#+BEGIN_SRC java
  public abstract class TemplateMethodClass {
      void final templateMethod() {
          primitiveOperation1();
          primitiveOperation2();
          concreteOperation();
          hook();
      }

      abstract void primitiveOperation1();

      abstract void primitiveOperation2();

      final void concreteOperation() {}

      void hook() {}

  }
#+END_SRC


** 迭代器模式

*** 定义

提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/iterator.gif"/>

**** Participants

- Iterator  (AbstractIterator)
  - defines an interface for accessing and traversing elements.
- ConcreteIterator  (Iterator)
  - implements the Iterator interface.
  - keeps track of the current position in the traversal of the aggregate.
- Aggregate  (AbstractCollection)
  - defines an interface for creating an Iterator object
- ConcreteAggregate  (Collection)
  - implements the Iterator creation interface to return an instance of the proper ConcreteIterator


** 责任链模式

*** 定义

让一个以上的对象有机会能够处理某个请求。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/chain.gif"/>

**** Participants

- Handler   (Approver)
  - defines an interface for handling the requests
  - (optional) implements the successor link
- ConcreteHandler   (Director, VicePresident, President)
  - handles requests it is responsible for
  - can access its successor
  - if the ConcreteHandler can handle the request, it does so; otherwise it forwards the request to its successor
- Client   (ChainApp)
  - initiates the request to a ConcreteHandler object on the chain


** 中介者模式

*** 定义

集中管理相关对象之间负责的沟通和控制方式。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/mediator.gif"/>

**** Participants

- Mediator  (IChatroom)
  - defines an interface for communicating with Colleague objects
- ConcreteMediator  (Chatroom)
  - implements cooperative behavior by coordinating Colleague objects
  - knows and maintains its colleagues
- Colleague classes  (Participant)
  - each Colleague class knows its Mediator object
  - each colleague communicates with its mediator whenever it would have otherwise communicated with another colleague


** 备忘录模式

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/memento.gif"/>


**** Participant

- Memento  (Memento)
  - stores internal state of the Originator object. The memento may store as much or as little of the originator's internal state as necessary at its originator's discretion.
  - protect against access by objects of other than the originator. Mementos have effectively two interfaces. Caretaker sees a narrow interface to the Memento -- it can only pass the memento to the other objects. Originator, in contrast, sees a wide interface, one that lets it access all the data necessary to restore itself to its previous state. Ideally, only the originator that produces the memento would be permitted to access the memento's internal state.
- Originator  (SalesProspect)
  - creates a memento containing a snapshot of its current internal state.
  - uses the memento to restore its internal state
- Caretaker  (Caretaker)
  - is responsible for the memento's safekeeping
  - never operates on or examines the contents of a memento.


** 访问者模式

*** 定义

当想要为一个对象的组合增加新的能力，且封装并不重要时，使用该模式。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/visitor.gif"/>


**** Participant

- Visitor  (Visitor)
  - declares a Visit operation for each class of ConcreteElement in the object structure. The operation's name and signature identifies the class that sends the Visit request to the visitor. That lets the visitor determine the concrete class of the element being visited. Then the visitor can access the elements directly through its particular interface
- ConcreteVisitor  (IncomeVisitor, VacationVisitor)
  - implements each operation declared by Visitor. Each operation implements a fragment of the algorithm defined for the corresponding class or object in the structure. ConcreteVisitor provides the context for the algorithm and stores its local state. This state often accumulates results during the traversal of the structure.
- Element  (Element)
  - defines an Accept operation that takes a visitor as an argument.
- ConcreteElement  (Employee)
  - implements an Accept operation that takes a visitor as an argument
- ObjectStructure  (Employees)
  - can enumerate its elements
  - may provide a high-level interface to allow the visitor to visit its elements
  - may either be a Composite (pattern) or a collection such as a list or a set


** 状态模式

*** 定义

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/state.gif"/>


**** Participants

- Context  (Account)
  - defines the interface of interest to clients
  - maintains an instance of a ConcreteState subclass that defines the current state.
- State  (State)
  - defines an interface for encapsulating the behavior associated with a particular state of the Context.
- Concrete State  (RedState, SilverState, GoldState)
  - each subclass implements a behavior associated with a state of Context



* 创建型模式

** 单例模式

*** 定义

确保一个类只有一个实例，并提供一个全局访问点。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/singleton.gif"/>


**** Participants

- Singleton   (LoadBalancer)
  - defines an Instance operation that lets clients access its unique instance. Instance is a class operation.
  - responsible for creating and maintaining its own unique instance.

*** 代码示例

**** Eagely

#+BEGIN_SRC java
  public class Singleton {
      private static Singleton instance = new Singleton();

      private Singleton() {}

      public static Singleton getInstance() {
          return instance;
      }
  }
#+END_SRC


**** Lazy

#+BEGIN_SRC java
  public class Singleton {
      private volatile static Singleton instance;

      private Singleton() {}

      public static Singleton getInstance() {
          if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }

              }
          }
          return instance;
      }
  }
#+END_SRC



** 生成器模式

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/builder.gif"/>

**** Participants

- Builder  (VehicleBuilder)
  - specifies an abstract interface for creating parts of a Product object
- ConcreteBuilder  (MotorCycleBuilder, CarBuilder, ScooterBuilder)
  - constructs and assembles parts of the product by implementing the Builder interface
  - defines and keeps track of the representation it creates
  - provides an interface for retrieving the product
- Director  (Shop)
  - constructs an object using the Builder interface
- Product  (Vehicle)
  - represents the complex object under construction. ConcreteBuilder builds the product's internal representation and defines the process by which it's assembled
  - includes classes that define the constituent parts, including interfaces for assembling the parts into the final result


** 工厂方法模式

*** 定义

定义了一个创建对象的接口，由子类决定要实例化哪个具体类。该模式将实例化类的任务委托给子类。

换句话说，工厂方法模式把简单工厂的内部逻辑判断移到了客户端代码来进行。 *如要新增功能，不用修改工厂类，修改客户端即可* 。


*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/factory.gif"/>

- 创建者（Creator）类
  抽象类，定义一个 *抽象的工厂方法* ，子类实现此方法制造产品。创建者通常会包含依赖于抽象产品的代码，而这些抽象产品由子类制造。创建者不需要知道具体产品类型。


**** Participants

- Product  (Page)
  - defines the interface of objects the factory method creates
- ConcreteProduct  (SkillsPage, EducationPage, ExperiencePage)
  - implements the Product interface
- Creator  (Document)
  - declares the factory method, which returns an object of type Product. Creator may also define a default implementation of the factory method that returns a default ConcreteProduct object.
  - may call the factory method to create a Product object.
- ConcreteCreator  (Report, Resume)
  - overrides the factory method to return an instance of a ConcreteProduct.



** 原型模式

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/prototype.gif"/>


**** Participants

- Prototype  (ColorPrototype)
  - declares an interface for cloning itself
- ConcretePrototype  (Color)
  - implements an operation for cloning itself
- Client  (ColorManager)
  - creates a new object by asking a prototype to clone itself


** 抽象工厂模式

*** 定义

提供一个接口，用于创建一个 *创建对象的家族* 。

换句话说，该模式的任务是定义一个负责创建 *一组* 产品的接口。

*** UML

#+HTML: <img src="https://www.dofactory.com/images/diagrams/net/abstract.gif"/>

**** Participants


- AbstractFactory  (ContinentFactory)
  - declares an interface for operations that create abstract products
- ConcreteFactory   (AfricaFactory, AmericaFactory)
  - implements the operations to create concrete product objects
- AbstractProduct   (Herbivore, Carnivore)
  - declares an interface for a type of product object
- Product  (Wildebeest, Lion, Bison, Wolf)
  - defines a product object to be created by the corresponding concrete factory
  - implements the AbstractProduct interface
- Client  (AnimalWorld)
  - uses interfaces declared by AbstractFactory and AbstractProduct classes





* 传送门

[[https://www.dofactory.com/net/design-patterns][doFactory]]