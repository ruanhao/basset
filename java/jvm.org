#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 内存模型

** volatile

解决内存可见性问题，不解决原子性问题

参考: [[https://www.youtube.com/watch?v=9afATopOwr8&list=PLmOn9nNkQxJEi-V3CqOaOyTruYhTViQDc&index=4][04 Redis String类型命令操作(20:00)]]

[[file:img/os-mem-model.png]]
file:img/java-mem-model.png


** synchronized

首先将工作缓存清空（若有改动，先写入主存然后清空），因此线程将从主存中加载变量到工作缓存中。

参考: [[https://www.youtube.com/watch?v=9afATopOwr8&list=PLmOn9nNkQxJEi-V3CqOaOyTruYhTViQDc&index=4][04 Redis String类型命令操作(32:33)]]

* JVM 参数

** 参数设置规律


- =-XX:+<option>=
  开启 option 选项
- =-XX:-<option>=
  关闭 option 选项
- =-XX:<option>=<value>=
  将 option 选项的值设为 value



** 跟踪参数

#+BEGIN_SRC
-XX:+PrintGCDetails ## 程序结束后打印堆信息
-XX:+PrintGCTimeStamps
-XX:+PrintGC ## 打开GC打印开关，运行时如发生GC，则打印相关信息

-Xloggc:/var/log/gc.log ## 指定GC log的位置

-XX:+PrintHeapAtGC ## 每次GC后，打印堆信息

-XX:+TraceClassLoading ## 监控类的加载

-XX:+PrintClassHistogram ## 按下Ctrl+Break，打印所有类的使用情况

-Xmx20m -Xms5m ## 指定最大堆和最小堆的大小

-Xmn ## 设置新生代大小
-XX:newRatio ## 新生代(eden区和2个幸存区[from区和to区])和老年代（不包含永久区）的比值
             ## 4表示 新生代:老年代=1:4，即年轻代占堆区1/5
-XX:SurvivorRatio ## 设置2个幸存区和eden的比值
                  ## 8表示2个Survivor:eden=2:8

## 官方推荐新生代占堆的3/8，幸存代占新生代的1/10

-XX:PermSize -XX:MaxPermSize ## 设置永久区的初始空间和最大空间
                             ## 表示一个系统可以容纳多少个类型

-Xss ## 栈大小分配

#+END_SRC

** Runtime Info

#+BEGIN_SRC java
  System.out.print("Xmx=");
  System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

  System.out.print("free mem=");
  System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

  System.out.print("total mem=");
  System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");

#+END_SRC
