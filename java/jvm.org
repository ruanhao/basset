#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

** ClassLoader

类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件。然后JVM来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。有三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器（或者叫作Application类加载器）。*每种类加载器都有设定好从哪里加载类*

*** Bootstrap

Bootstrap类加载器负责加载rt.jar中的JDK类文件，它是所有类加载器的父加载器。Bootstrap类加载器没有任何父类加载器，如果你调用String.class.getClassLoader()，会返回null，任何基于此的代码会抛出NUllPointerException异常。Bootstrap加载器被称为初始类加载器。


*** Extension

而Extension将加载类的请求先委托给它的父加载器，也就是Bootstrap，如果没有成功加载的话，再从jre/lib/ext目录下或者java.ext.dirs系统属性定义的目录下加载类。Extension加载器由sun.misc.Launcher$ExtClassLoader实现。


*** System

第三种默认的加载器就是System类加载器（又叫作Application类加载器）了。它负责从classpath环境变量中加载某些应用相关的类，classpath环境变量通常由-classpath或-cp命令行选项来定义，或者是JAR中的Manifest的classpath属性。Application类加载器是Extension类加载器的子加载器。通过sun.misc.Launcher$AppClassLoader实现。


*** Summary

除了Bootstrap类加载器是大部分由C来写的，其他的类加载器都是通过java.lang.ClassLoader来实现的。

下面是三种类加载器加载类文件的地方：

- Bootstrap类加载器   - JRE/lib/rt.jar

- Extension类加载器   - JRE/lib/ext或者java.ext.dirs指向的目录

- Application类加载器 - CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.


** 跟踪参数

#+BEGIN_SRC
-XX:+PrintGCDetails ## 程序结束后打印堆信息
-XX:+PrintGCTimeStamps
-XX:+PrintGC ## 打开GC打印开关，运行时如发生GC，则打印相关信息

-Xloggc:/var/log/gc.log ## 指定GC log的位置

-XX:+PrintHeapAtGC ## 每次GC后，打印堆信息

-XX:+TraceClassLoading ## 监控类的加载

-XX:+PrintClassHistogram ## 按下Ctrl+Break，打印所有类的使用情况

-Xmx20m -Xms5m ## 指定最大堆和最小堆的大小

-Xmn ## 设置新生代大小
-XX:newRatio ## 新生代(eden区和2个幸存区[from区和to区])和老年代（不包含永久区）的比值
             ## 4表示 新生代:老年代=1:4，即年轻代占堆区1/5
-XX:SurvivorRatio ## 设置2个幸存区和eden的比值
                  ## 8表示2个Survivor:eden=2:8

## 官方推荐新生代占堆的3/8，幸存代占新生代的1/10

-XX:PermSize -XX:MaxPermSize ## 设置永久区的初始空间和最大空间
                             ## 表示一个系统可以容纳多少个类型

-Xss ## 栈大小分配

#+END_SRC

** Runtime Info

#+BEGIN_SRC java
  System.out.print("Xmx=");
  System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

  System.out.print("free mem=");
  System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

  System.out.print("total mem=");
  System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");

#+END_SRC
