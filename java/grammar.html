<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-06-05 Tue 15:51 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Grammar</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Hao Ruan">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
<link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Grammar</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4c07cdf">1. Stream</a>
<ul>
<li><a href="#org89bab75">1.1. 基本原理</a></li>
<li><a href="#org54f7830">1.2. 示例代码</a>
<ul>
<li><a href="#orgffc1f5f">1.2.1. 筛选</a>
<ul>
<li><a href="#orga1c9428">1.2.1.1. 谓词筛选</a></li>
<li><a href="#org04c98e3">1.2.1.2. 筛选各异</a></li>
<li><a href="#org9c7fa90">1.2.1.3. 截短</a></li>
<li><a href="#orge27a094">1.2.1.4. 跳过</a></li>
</ul>
</li>
<li><a href="#org6d9a355">1.2.2. 映射</a>
<ul>
<li><a href="#org31a8066">1.2.2.1. 基本映射</a></li>
<li><a href="#org7434526">1.2.2.2. 扁平化流</a></li>
</ul>
</li>
<li><a href="#orgd08fee0">1.2.3. 归约</a>
<ul>
<li><a href="#orge5d3c88">1.2.3.1. 求和</a></li>
<li><a href="#org1bb8ed8">1.2.3.2. 计算最大值</a></li>
<li><a href="#org489af1f">1.2.3.3. 计算平均值</a></li>
</ul>
</li>
<li><a href="#org9380ad4">1.2.4. 数值流</a></li>
<li><a href="#org8f1b5fa">1.2.5. 构造流</a>
<ul>
<li><a href="#org1e2c93b">1.2.5.1. 由值创建流</a></li>
<li><a href="#org1c23911">1.2.5.2. 由数组创建流</a></li>
<li><a href="#org8c50561">1.2.5.3. 由文件生成流</a></li>
<li><a href="#orge2402b4">1.2.5.4. 由函数生成流 （创建无限流）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge41f0a4">2. Collection</a>
<ul>
<li><a href="#orgd96ee38">2.1. 基本原理</a>
<ul>
<li><a href="#orgdbf643e">2.1.1. 收集器</a></li>
</ul>
</li>
<li><a href="#org9405303">2.2. 示例代码</a>
<ul>
<li><a href="#orgec911f8">2.2.1. stream 操作</a></li>
<li><a href="#org83ec614">2.2.2. 聚合</a></li>
<li><a href="#org5ee5c59">2.2.3. 分组</a></li>
<li><a href="#org1159091">2.2.4. 分区</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orged76c19">3. Lambda</a>
<ul>
<li><a href="#org5a926c1">3.1. 知识点</a>
<ul>
<li><a href="#org663ca4f">3.1.1. 谓词（Predicate）</a></li>
<li><a href="#org439b29d">3.1.2. 函数式接口（Functional Interface）</a></li>
<li><a href="#org2559485">3.1.3. 常见函数式接口</a></li>
<li><a href="#org99ec167">3.1.4. 方法引用</a></li>
<li><a href="#org1ba5de4">3.1.5. 构造方法引用</a></li>
<li><a href="#orge2e15a8">3.1.6. 类型检查与推断</a></li>
<li><a href="#orgda08c36">3.1.7. 特殊的 void 兼容规则</a></li>
</ul>
</li>
<li><a href="#orgd362c17">3.2. 示例代码</a>
<ul>
<li><a href="#org0a17f77">3.2.1. 方法引用</a></li>
<li><a href="#orgaefdc8d">3.2.2. 构造方法引用</a></li>
<li><a href="#org7dd9917">3.2.3. 排序</a></li>
<li><a href="#orgaeb9ba5">3.2.4. 谓词复合 (negate, and, or)</a></li>
<li><a href="#orgd8f6fe6">3.2.5. 函数复合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9fd843a">4. Optional</a>
<ul>
<li><a href="#org0492ed8">4.1. 基本原理</a></li>
<li><a href="#orgec382c4">4.2. 代码示例</a>
<ul>
<li><a href="#org71fee27">4.2.1. 类三元操作符</a></li>
<li><a href="#org66a2f78">4.2.2. 避免在 Null 对象上调用 stream()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4c07cdf">1. Stream</a>
<ul>
<li><a href="#org89bab75">1.1. 基本原理</a></li>
<li><a href="#org54f7830">1.2. 示例代码</a>
<ul>
<li><a href="#orgffc1f5f">1.2.1. 筛选</a>
<ul>
<li><a href="#orga1c9428">1.2.1.1. 谓词筛选</a></li>
<li><a href="#org04c98e3">1.2.1.2. 筛选各异</a></li>
<li><a href="#org9c7fa90">1.2.1.3. 截短</a></li>
<li><a href="#orge27a094">1.2.1.4. 跳过</a></li>
</ul>
</li>
<li><a href="#org6d9a355">1.2.2. 映射</a>
<ul>
<li><a href="#org31a8066">1.2.2.1. 基本映射</a></li>
<li><a href="#org7434526">1.2.2.2. 扁平化流</a></li>
</ul>
</li>
<li><a href="#orgd08fee0">1.2.3. 归约</a>
<ul>
<li><a href="#orge5d3c88">1.2.3.1. 求和</a></li>
<li><a href="#org1bb8ed8">1.2.3.2. 计算最大值</a></li>
<li><a href="#org489af1f">1.2.3.3. 计算平均值</a></li>
</ul>
</li>
<li><a href="#org9380ad4">1.2.4. 数值流</a></li>
<li><a href="#org8f1b5fa">1.2.5. 构造流</a>
<ul>
<li><a href="#org1e2c93b">1.2.5.1. 由值创建流</a></li>
<li><a href="#org1c23911">1.2.5.2. 由数组创建流</a></li>
<li><a href="#org8c50561">1.2.5.3. 由文件生成流</a></li>
<li><a href="#orge2402b4">1.2.5.4. 由函数生成流 （创建无限流）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge41f0a4">2. Collection</a>
<ul>
<li><a href="#orgd96ee38">2.1. 基本原理</a>
<ul>
<li><a href="#orgdbf643e">2.1.1. 收集器</a></li>
</ul>
</li>
<li><a href="#org9405303">2.2. 示例代码</a>
<ul>
<li><a href="#orgec911f8">2.2.1. stream 操作</a></li>
<li><a href="#org83ec614">2.2.2. 聚合</a></li>
<li><a href="#org5ee5c59">2.2.3. 分组</a></li>
<li><a href="#org1159091">2.2.4. 分区</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orged76c19">3. Lambda</a>
<ul>
<li><a href="#org5a926c1">3.1. 知识点</a>
<ul>
<li><a href="#org663ca4f">3.1.1. 谓词（Predicate）</a></li>
<li><a href="#org439b29d">3.1.2. 函数式接口（Functional Interface）</a></li>
<li><a href="#org2559485">3.1.3. 常见函数式接口</a></li>
<li><a href="#org99ec167">3.1.4. 方法引用</a></li>
<li><a href="#org1ba5de4">3.1.5. 构造方法引用</a></li>
<li><a href="#orge2e15a8">3.1.6. 类型检查与推断</a></li>
<li><a href="#orgda08c36">3.1.7. 特殊的 void 兼容规则</a></li>
</ul>
</li>
<li><a href="#orgd362c17">3.2. 示例代码</a>
<ul>
<li><a href="#org0a17f77">3.2.1. 方法引用</a></li>
<li><a href="#orgaefdc8d">3.2.2. 构造方法引用</a></li>
<li><a href="#org7dd9917">3.2.3. 排序</a></li>
<li><a href="#orgaeb9ba5">3.2.4. 谓词复合 (negate, and, or)</a></li>
<li><a href="#orgd8f6fe6">3.2.5. 函数复合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9fd843a">4. Optional</a>
<ul>
<li><a href="#org0492ed8">4.1. 基本原理</a></li>
<li><a href="#orgec382c4">4.2. 代码示例</a>
<ul>
<li><a href="#org71fee27">4.2.1. 类三元操作符</a></li>
<li><a href="#org66a2f78">4.2.2. 避免在 Null 对象上调用 stream()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="meta">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Author</td>
<td class="org-left">Hao Ruan (haoru@cisco.com)</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">2018-06-05 15:51:28</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-org4c07cdf" class="outline-2">
<h2 id="org4c07cdf"><span class="section-number-2">1</span> Stream</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org89bab75" class="outline-3">
<h3 id="org89bab75"><span class="section-number-3">1.1</span> 基本原理</h3>
<div class="outline-text-3" id="text-1-1">
<p>
流的使用一般包括三件事:
</p>

<ul class="org-ul">
<li>一个数据源（如集合）来执行一个查询</li>
<li>一个中间操作链，形成一条流的流水线</li>
<li>一个终端操作，执行流水线，并能生成结果</li>
</ul>
</div>
</div>


<div id="outline-container-org54f7830" class="outline-3">
<h3 id="org54f7830"><span class="section-number-3">1.2</span> 示例代码</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgffc1f5f" class="outline-4">
<h4 id="orgffc1f5f"><span class="section-number-4">1.2.1</span> 筛选</h4>
<div class="outline-text-4" id="text-1-2-1">
</div>
<div id="outline-container-orga1c9428" class="outline-5">
<h5 id="orga1c9428"><span class="section-number-5">1.2.1.1</span> 谓词筛选</h5>
<div class="outline-text-5" id="text-1-2-1-1">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">vegetarianMenu</span> = menu.stream()
    .filter(Dish::isVegetarian)
    .collect(toList());
</pre>
</div>
</div>
</div>


<div id="outline-container-org04c98e3" class="outline-5">
<h5 id="org04c98e3"><span class="section-number-5">1.2.1.2</span> 筛选各异</h5>
<div class="outline-text-5" id="text-1-2-1-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">numbers</span> = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
number.stream()
    .filter(i -&gt; i % 2 == 0)
    .distinct()
    .forEach(System.out::println);
</pre>
</div>
</div>
</div>


<div id="outline-container-org9c7fa90" class="outline-5">
<h5 id="org9c7fa90"><span class="section-number-5">1.2.1.3</span> 截短</h5>
<div class="outline-text-5" id="text-1-2-1-3">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">dishes</span> = menu.stream()
    .filter(d -&gt; d.getCalories() &gt; 300)
    .limit(3)
    .collect(toList());
</pre>
</div>
</div>
</div>

<div id="outline-container-orge27a094" class="outline-5">
<h5 id="orge27a094"><span class="section-number-5">1.2.1.4</span> 跳过</h5>
<div class="outline-text-5" id="text-1-2-1-4">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">dishes</span> = menu.stream()
    .filter(d -&gt; d.getCalories() &gt; 300)
    .skip(2)
    .collect(toList());
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org6d9a355" class="outline-4">
<h4 id="org6d9a355"><span class="section-number-4">1.2.2</span> 映射</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-org31a8066" class="outline-5">
<h5 id="org31a8066"><span class="section-number-5">1.2.2.1</span> 基本映射</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">dishNames</span> = menu.stream()
    .map(Dish::getName)
    .collect(toList());
</pre>
</div>
</div>
</div>

<div id="outline-container-org7434526" class="outline-5">
<h5 id="org7434526"><span class="section-number-5">1.2.2.2</span> 扁平化流</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">uniqueCharacters</span> =
    words.stream()
    .map(w -&gt; w.split(<span style="color: #00afaf;">""</span>))
    .flatMap(Arrays::stream)    <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">Arrays.stream() &#30340;&#26041;&#27861;&#21487;&#20197;&#25509;&#21463;&#19968;&#20010;&#25968;&#32452;&#24182;&#20135;&#29983;&#19968;&#20010;&#27969;</span>
                                <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#23558;&#21508;&#20010;&#29983;&#25104;&#27969;&#25153;&#24179;&#21270;&#20026;&#21333;&#20010;&#27969;</span>
    .distinct()
    .collect(Collectors.toList());
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd08fee0" class="outline-4">
<h4 id="orgd08fee0"><span class="section-number-4">1.2.3</span> 归约</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
此类查询需要将流中所有元素反复结合起来，得到一个值。这样的查询可以被归类为归约操作（将流归约成一个值）。
</p>

<p>
用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（流）反复折叠成一个小方块，而这就是折叠操作的结果。
</p>
</div>

<div id="outline-container-orge5d3c88" class="outline-5">
<h5 id="orge5d3c88"><span class="section-number-5">1.2.3.1</span> 求和</h5>
<div class="outline-text-5" id="text-1-2-3-1">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">BinaryOperator&lt;T&gt; &#29992;&#26469;&#23558;&#20004;&#20010;&#20803;&#32032;&#32467;&#21512;&#36215;&#26469;&#20135;&#29983;&#19968;&#20010;&#26032;&#20540;</span>
<span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = numbers.stream().reduce(0, (a, b) -&gt; a + b);
<span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = numbers.stream().reduce(0, Integer::sum);


<span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">reduce &#36824;&#26377;&#19968;&#20010;&#37325;&#36733;&#30340;&#21464;&#20307;&#65292;&#23427;&#19981;&#25509;&#21463;&#21021;&#22987;&#20540;&#65292;&#20294;&#26159;&#20250;&#36820;&#22238;&#19968;&#20010;Optional&#23545;&#35937;</span>
<span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#22240;&#20026;&#27969;&#20013;&#21487;&#33021;&#27809;&#26377;&#20219;&#20309;&#20803;&#32032;&#30340;&#24773;&#20917;&#65292;reduce &#25805;&#20316;&#23601;&#26080;&#27861;&#36820;&#22238;&#20854;&#21644;&#65292;&#22240;&#20026;&#23427;&#27809;&#26377;&#21021;&#22987;&#20540;</span>
<span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#36825;&#23601;&#26159;&#20026;&#20160;&#20040;&#32467;&#26524;&#34987;&#21253;&#35065;&#22312;&#19968;&#20010; Optional &#23545;&#35937;&#37324;&#65292;&#20197;&#34920;&#26126;&#21644;&#21487;&#33021;&#19981;&#23384;&#22312;</span>
<span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">sum</span> = numbers.stream().reduce((a, b) -&gt; (a + b));
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bb8ed8" class="outline-5">
<h5 id="org1bb8ed8"><span class="section-number-5">1.2.3.2</span> 计算最大值</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">max</span> = numbers.stream().reduce(Integer::max);
</pre>
</div>
</div>
</div>

<div id="outline-container-org489af1f" class="outline-5">
<h5 id="org489af1f"><span class="section-number-5">1.2.3.3</span> 计算平均值</h5>
<div class="outline-text-5" id="text-1-2-3-3">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">double</span> <span style="color: #0087ff;">avgCalories</span> = menu.stream().collect(averagingInt(Dish::getCalories));
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org9380ad4" class="outline-4">
<h4 id="org9380ad4"><span class="section-number-4">1.2.4</span> 数值流</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
<code>IntStream</code> 中的 <code>map</code> 方法只能为流中的每个元素返回另一个 <code>int</code> ，
如果这不是你想要的，可以用 <code>IntStream</code> 的 <code>mapToObj</code> 方法改写它，这个方法会返回一个对象值流。
</p>

<p>
或者使用 <code>boxed</code> 方法先转换为 <code>Stream&lt;Integer&gt;</code> 。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">IntStream</span> <span style="color: #0087ff;">evenNumbers</span> = IntStream.range(1, 100);
<span style="color: #af8700;">IntStream</span> <span style="color: #0087ff;">evenNumbers</span> = IntStream.rangeClosed(1, 100);
</pre>
</div>
</div>
</div>


<div id="outline-container-org8f1b5fa" class="outline-4">
<h4 id="org8f1b5fa"><span class="section-number-4">1.2.5</span> 构造流</h4>
<div class="outline-text-4" id="text-1-2-5">
</div>
<div id="outline-container-org1e2c93b" class="outline-5">
<h5 id="org1e2c93b"><span class="section-number-5">1.2.5.1</span> 由值创建流</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Stream</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">stream</span> = Stream.of(<span style="color: #00afaf;">"Java 8 "</span>, <span style="color: #00afaf;">"Lambdas "</span>, <span style="color: #00afaf;">"In "</span>, <span style="color: #00afaf;">"Action"</span>);
<span style="color: #af8700;">Stream</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">emptyStream</span> = Stream.empty();
</pre>
</div>
</div>
</div>


<div id="outline-container-org1c23911" class="outline-5">
<h5 id="org1c23911"><span class="section-number-5">1.2.5.2</span> 由数组创建流</h5>
<div class="outline-text-5" id="text-1-2-5-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">int</span>[] <span style="color: #0087ff;">numbers</span> = {2, 3, 5, 7, 11, 13};
<span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = Arrays.stream(numbers).sum();
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c50561" class="outline-5">
<h5 id="org8c50561"><span class="section-number-5">1.2.5.3</span> 由文件生成流</h5>
<div class="outline-text-5" id="text-1-2-5-3">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Stream</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">lines</span> = Files.lines(Paths.get(<span style="color: #00afaf;">"data.txt"</span>), Charset.defaultCharset());
</pre>
</div>
</div>
</div>

<div id="outline-container-orge2402b4" class="outline-5">
<h5 id="orge2402b4"><span class="section-number-5">1.2.5.4</span> 由函数生成流 （创建无限流）</h5>
<div class="outline-text-5" id="text-1-2-5-4">
<p>
Stream API 提供了两个静态方法来从函数生成流: <code>Stream.iterate</code> 和 <code>Stream.generate</code> ，这两个操作可以创建所谓的无限流，
</p>

<p>
由 <code>iterate</code> 和 <code>generate</code> 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。
一般来说，应该使用 <code>limit(n)</code> 来对这种流加以限制，以避免打印无穷多个值。
</p>

<div class="org-src-container">
<pre class="src src-java">Stream.iterate(0, n -&gt; n + 2)
    .limit(10)
    .forEach(System.out::println);

Stream.generate(Math::random)
    .limit(5)
    .forEach(System.out::println);

<span style="color: #af8700;">IntStream</span> <span style="color: #0087ff;">ones</span> = IntStream.generate(() -&gt; 1);

</pre>
</div>
</div>
</div>
</div>
</div>
</div>















<div id="outline-container-orge41f0a4" class="outline-2">
<h2 id="orge41f0a4"><span class="section-number-2">2</span> Collection</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgd96ee38" class="outline-3">
<h3 id="orgd96ee38"><span class="section-number-3">2.1</span> 基本原理</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgdbf643e" class="outline-4">
<h4 id="orgdbf643e"><span class="section-number-4">2.1.1</span> 收集器</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
即 Collectors 类提供的工厂方法（例如 groupingBy )所创建的对象。主要提供三个功能:
</p>

<ul class="org-ul">
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org9405303" class="outline-3">
<h3 id="org9405303"><span class="section-number-3">2.2</span> 示例代码</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f8700;">import</span> <span style="color: #5f8700;">static</span> <span style="color: #00afaf;">java</span>.<span style="color: #00afaf;">util</span>.<span style="color: #00afaf;">Comparator</span>.*;
<span style="color: #5f8700;">import</span> <span style="color: #5f8700;">static</span> <span style="color: #00afaf;">java</span>.<span style="color: #00afaf;">util</span>.<span style="color: #00afaf;">stream</span>.<span style="color: #00afaf;">Collectors</span>.*;

<span style="color: #00afaf;">@AllArgsConstructor</span>
<span style="color: #5f8700;">class</span> <span style="color: #af8700;">Dish</span> {

    <span style="color: #00afaf;">@Getter</span> <span style="color: #5f8700;">private</span> <span style="color: #5f8700;">final</span> <span style="color: #af8700;">String</span> <span style="color: #0087ff;">name</span>;
    <span style="color: #00afaf;">@Getter</span> <span style="color: #5f8700;">private</span> <span style="color: #5f8700;">final</span> <span style="color: #af8700;">boolean</span> <span style="color: #0087ff;">vegetarian</span>;
    <span style="color: #00afaf;">@Getter</span> <span style="color: #5f8700;">private</span> <span style="color: #5f8700;">final</span> <span style="color: #af8700;">int</span> <span style="color: #0087ff;">calories</span>;
    <span style="color: #00afaf;">@Getter</span> <span style="color: #5f8700;">private</span> <span style="color: #5f8700;">final</span> <span style="color: #af8700;">Type</span> <span style="color: #0087ff;">type</span>;

    <span style="color: #5f8700;">public</span> <span style="color: #5f8700;">enum</span> <span style="color: #af8700;">Type</span> { <span style="color: #0087ff;">MEAT</span>, <span style="color: #0087ff;">FISH</span>, <span style="color: #0087ff;">OTHER</span> }

    <span style="color: #5f8700;">public</span> <span style="color: #5f8700;">enum</span> <span style="color: #af8700;">CaloricLevel</span> { <span style="color: #0087ff;">DIET</span>, <span style="color: #0087ff;">NORMAL</span>, <span style="color: #0087ff;">FAT</span> }
}


<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">menu</span> =
    Arrays.asList(<span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"pork"</span>, <span style="color: #00afaf;">false</span>, 800, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.MEAT),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"beef"</span>, <span style="color: #00afaf;">false</span>, 700, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.MEAT),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"chicken"</span>, <span style="color: #00afaf;">false</span>, 400, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.MEAT),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"french fries"</span>, <span style="color: #00afaf;">true</span>, 530, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.OTHER),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"rice"</span>, <span style="color: #00afaf;">true</span>, 350, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.OTHER),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"season fruit"</span>, <span style="color: #00afaf;">true</span>, 120, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.OTHER),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"pizza"</span>, <span style="color: #00afaf;">true</span>, 550, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.OTHER),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"prawns"</span>, <span style="color: #00afaf;">false</span>, 300, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.FISH),
                  <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Dish</span>(<span style="color: #00afaf;">"salmon"</span>, <span style="color: #00afaf;">false</span>, 450, <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">Type</span>.FISH));



<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getThreeHighCaloricDishNames</span>() {
    menu.stream()
        .sorted(comparing(Dish::getCalories).reversed())
        .limit(3)
        .map(d -&gt; d.getName())
        .forEach(System.out::println);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getDistinctDishType</span>() {
    menu.stream()
        .map(d -&gt; d.getType())
        .distinct()
        .forEach(System.out::println);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getAllCalories0</span>() {
    <span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = menu.stream()
        .map(Dish::getCalories)
        .reduce(0, Integer::sum);
    System.out.println(sum);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getAllCalories1</span>() {
    <span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = menu.stream()
        .mapToInt(Dish::getCalories)
        .sum();
    System.out.println(sum);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getMaxCalorie</span>() {
    <span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">maxOp</span> = menu.stream()
        .map(Dish::getCalories)
        .reduce(Integer::max);
    System.out.println(maxOp.orElse(0));
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getMaxCalorieDish</span>() {
    <span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">maxOp</span> = menu.stream()
        .collect(maxBy(comparingInt(Dish::getCalories)));
    maxOp.ifPresent(System.out::println);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getTotalNumberOfDish</span>() {
    <span style="color: #af8700;">long</span> <span style="color: #0087ff;">total</span> = menu.stream()
        .collect(counting());
    System.out.println(total);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getAllCalories2</span>() {
    <span style="color: #af8700;">int</span> <span style="color: #0087ff;">sum</span> = menu.stream()
        .collect(summingInt(Dish::getCalories));
    System.out.println(sum);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getAverageCalorie</span>() {
    <span style="color: #af8700;">double</span> <span style="color: #0087ff;">avg</span> = menu.stream()
        .collect(averagingInt(Dish::getCalories));
    System.out.println(avg);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getStatistics</span>() {
    <span style="color: #af8700;">IntSummaryStatistics</span> <span style="color: #0087ff;">s</span> = menu.stream()
        .collect(summarizingInt(Dish::getCalories));
    System.out.println(s);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getShortMenu</span>() {
    <span style="color: #af8700;">String</span> <span style="color: #0087ff;">j</span> = menu.stream()
        .map(Dish::getName)
        .collect(joining(<span style="color: #00afaf;">", "</span>));
    System.out.println(j);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">groupByCaloricLevel</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">CaloricLevel</span>, <span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt;&gt; <span style="color: #0087ff;">dishesByCaloricLevel</span> =
        menu.stream().collect( groupingBy(dish -&gt; {
                    <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 400)
                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.DIET;
                    <span style="color: #5f8700;">else</span> <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 700)
                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.NORMAL;
                    <span style="color: #5f8700;">else</span>
                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.FAT;
                } ));
    System.out.println(dishesByCaloricLevel);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">groupByDishesAndTypeCaloricLevel</span>() {
    Map&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">CaloricLevel</span>, <span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt;&gt;&gt; <span style="color: #af8700;">dishesByTypeCaloricLevel</span> =
        menu.stream()
        .collect(groupingBy(Dish::getType,
                            groupingBy(dish -&gt; {
                                    <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 400)
                                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.DIET;
                                    <span style="color: #5f8700;">else</span> <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 700)
                                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.NORMAL;
                                    <span style="color: #5f8700;">else</span>
                                        <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.FAT;
                                }  )
                            )
                 );
    System.out.println(dishesByTypeCaloricLevel);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getTotalNumberOfDishByType</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>,<span style="color: #af8700;">Long</span>&gt; <span style="color: #0087ff;">typesCount</span> =
        menu.stream()
        .collect(groupingBy(Dish::getType,
                            counting()));
    System.out.println(typesCount);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getMostCaloricByType0</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Dish</span>&gt;&gt; <span style="color: #0087ff;">mostCaloricByType</span> =
        menu.stream()
        .collect(groupingBy(Dish::getType,
                            maxBy(comparingInt(Dish::getCalories))));
    System.out.println(mostCaloricByType);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getMostCaloricByType1</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Dish</span>&gt; <span style="color: #0087ff;">mostCaloricByType</span> =
        menu.stream()
        .collect(groupingBy(Dish::getType,
                            collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                                              Optional::get)
                            ));
    System.out.println(mostCaloricByType);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getCaloricLevelsByType</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Set</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">CaloricLevel</span>&gt;&gt; <span style="color: #0087ff;">caloricLevelsByType</span> =
        menu.stream().collect(groupingBy(Dish::getType,
                                         mapping( dish -&gt; {
                                                 <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 400)
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.DIET;
                                                 <span style="color: #5f8700;">else</span> <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 700)
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.NORMAL;
                                                 <span style="color: #5f8700;">else</span>
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.FAT;
                                             },
                                             toSet())));
    System.out.println(caloricLevelsByType);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getCaloricLevelsByType1</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Set</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">CaloricLevel</span>&gt;&gt; <span style="color: #0087ff;">caloricLevelsByType</span> =
        menu.stream().collect(groupingBy(Dish::getType,
                                         mapping( dish -&gt; {
                                                 <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 400)
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.DIET;
                                                 <span style="color: #5f8700;">else</span> <span style="color: #5f8700;">if</span> (dish.getCalories() &lt;= 700)
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.NORMAL;
                                                 <span style="color: #5f8700;">else</span>
                                                     <span style="color: #5f8700;">return</span> <span style="color: #00afaf;">Dish</span>.<span style="color: #00afaf;">CaloricLevel</span>.FAT;
                                             },
                                             toCollection(HashSet::<span style="color: #5f8700;">new</span>))));
    System.out.println(caloricLevelsByType);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getTotalCaloriesByType</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #00afaf;">Dish</span>.<span style="color: #af8700;">Type</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">totalCaloriesByType</span> =
        menu.stream().collect(groupingBy(Dish::getType,
                                         summingInt(Dish::getCalories)));
    System.out.println(totalCaloriesByType);
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getVegetarianDishes</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #af8700;">Boolean</span>, <span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">Dish</span>&gt;&gt; <span style="color: #0087ff;">partitionedMenu</span> =
        menu.stream().collect(partitioningBy(Dish::isVegetarian));
    System.out.println(partitionedMenu.get(<span style="color: #00afaf;">true</span>));
}

<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">getMostCaloricPartitionedByVegetarian</span>() {
    <span style="color: #af8700;">Map</span>&lt;<span style="color: #af8700;">Boolean</span>, <span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">mostCaloricPartitionedByVegetarian</span> =
        menu.stream().collect(partitioningBy(Dish::isVegetarian,
                                             collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                                                               op -&gt; op.get().getName())));
    System.out.println(mostCaloricPartitionedByVegetarian);
}




</pre>
</div>
</div>


<div id="outline-container-orgec911f8" class="outline-4">
<h4 id="orgec911f8"><span class="section-number-4">2.2.1</span> stream 操作</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">
<pre class="src src-java">System.out.println(<span style="color: #00afaf;">"===== getThreeHighCaloricDishNames (sort) ====="</span>);
getThreeHighCaloricDishNames();
System.out.println(<span style="color: #00afaf;">"===== getDistinctDishType (distinct) ====="</span>);
getDistinctDishType();
System.out.println(<span style="color: #00afaf;">"===== getAllCalories (reduce) ====="</span>);
getAllCalories0();
System.out.println(<span style="color: #00afaf;">"===== getAllCalories (mapToInt) ====="</span>);
getAllCalories1();
System.out.println(<span style="color: #00afaf;">"===== getMaxCalorie (reduce) ====="</span>);
getMaxCalorie();
</pre>
</div>

<pre class="example">
===== getThreeHighCaloricDishNames (sort) =====
pork
beef
pizza
===== getDistinctDishType (distinct) =====
MEAT
OTHER
FISH
===== getAllCalories (reduce) =====
4200
===== getAllCalories (mapToInt) =====
4200
===== getMaxCalorie (reduce) =====
800
</pre>
</div>
</div>


<div id="outline-container-org83ec614" class="outline-4">
<h4 id="org83ec614"><span class="section-number-4">2.2.2</span> 聚合</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">
<pre class="src src-java">System.out.println(<span style="color: #00afaf;">"===== getTotalNumberOfDish (counting) ====="</span>);
getTotalNumberOfDish();
System.out.println(<span style="color: #00afaf;">"===== getMaxCalorie (maxBy) ====="</span>);
getMaxCalorieDish();
System.out.println(<span style="color: #00afaf;">"===== getAllCalories (summingInt) ====="</span>);
getAllCalories2();
System.out.println(<span style="color: #00afaf;">"===== getAverageCalorie (averagingInt) ====="</span>);
getAverageCalorie();
System.out.println(<span style="color: #00afaf;">"===== getStatistics (summarizingInt) ====="</span>);
getStatistics();
System.out.println(<span style="color: #00afaf;">"===== getShortMenu (joining) ====="</span>);
getShortMenu();
</pre>
</div>

<pre class="example">
===== getTotalNumberOfDish (counting) =====
9
===== getMaxCalorie (maxBy) =====
com.cisco.ruan.nio.Dish@27bc2616
===== getAllCalories (summingInt) =====
4200
===== getAverageCalorie (averagingInt) =====
466.6666666666667
===== getStatistics (summarizingInt) =====
IntSummaryStatistics{count=9, sum=4200, min=120, average=466.666667, max=800}
===== getShortMenu (joining) =====
pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon
</pre>
</div>
</div>


<div id="outline-container-org5ee5c59" class="outline-4">
<h4 id="org5ee5c59"><span class="section-number-4">2.2.3</span> 分组</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">
<pre class="src src-java">System.out.println(<span style="color: #00afaf;">"===== groupByCaloricLevel (groupingBy) ====="</span>);
groupByCaloricLevel();
System.out.println(<span style="color: #00afaf;">"===== groupByDishesAndTypeCaloricLevel (multi-level groupingBy) ====="</span>);
groupByDishesAndTypeCaloricLevel();
System.out.println(<span style="color: #00afaf;">"===== groupByDishesAndTypeCaloricLevel (counting on substream) ====="</span>);
getTotalNumberOfDishByType();
System.out.println(<span style="color: #00afaf;">"===== getMostCaloricByType (maxBy on substream) ====="</span>);
getMostCaloricByType0();
System.out.println(<span style="color: #00afaf;">"===== getMostCaloricByType (collectingAndThen) ====="</span>);
getMostCaloricByType1();
System.out.println(<span style="color: #00afaf;">"===== getTotalCaloriesByType (summingInt on substream) ====="</span>);
getTotalCaloriesByType();
System.out.println(<span style="color: #00afaf;">"===== getCaloricLevelsByType (mapping on substream and collect in set) ====="</span>);
getCaloricLevelsByType();
System.out.println(<span style="color: #00afaf;">"===== getCaloricLevelsByType (mapping on substream and collect in hashset) ====="</span>);
getCaloricLevelsByType1();
</pre>
</div>

<pre class="example">
===== groupByCaloricLevel (groupingBy) =====
{NORMAL=[com.cisco.ruan.nio.Dish@179d3b25, com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@5d099f62, com.cisco.ruan.nio.Dish@37f8bb67], DIET=[com.cisco.ruan.nio.Dish@49c2faae, com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0, com.cisco.ruan.nio.Dish@439f5b3d], FAT=[com.cisco.ruan.nio.Dish@27bc2616]}
===== groupByDishesAndTypeCaloricLevel (multi-level groupingBy) =====
{OTHER={NORMAL=[com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@5d099f62], DIET=[com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0]}, FISH={NORMAL=[com.cisco.ruan.nio.Dish@37f8bb67], DIET=[com.cisco.ruan.nio.Dish@439f5b3d]}, MEAT={NORMAL=[com.cisco.ruan.nio.Dish@179d3b25], DIET=[com.cisco.ruan.nio.Dish@49c2faae], FAT=[com.cisco.ruan.nio.Dish@27bc2616]}}
===== groupByDishesAndTypeCaloricLevel (counting on substream) =====
{OTHER=4, FISH=2, MEAT=3}
===== getMostCaloricByType (maxBy on substream) =====
{OTHER=Optional[com.cisco.ruan.nio.Dish@5d099f62], FISH=Optional[com.cisco.ruan.nio.Dish@37f8bb67], MEAT=Optional[com.cisco.ruan.nio.Dish@27bc2616]}
===== getMostCaloricByType (collectingAndThen) =====
{OTHER=com.cisco.ruan.nio.Dish@5d099f62, FISH=com.cisco.ruan.nio.Dish@37f8bb67, MEAT=com.cisco.ruan.nio.Dish@27bc2616}
===== getTotalCaloriesByType (summingInt on substream) =====
{OTHER=1550, FISH=750, MEAT=1900}
===== getCaloricLevelsByType (mapping on substream and collect in set) =====
{OTHER=[NORMAL, DIET], FISH=[NORMAL, DIET], MEAT=[NORMAL, DIET, FAT]}
===== getCaloricLevelsByType (mapping on substream and collect in hashset) =====
{OTHER=[NORMAL, DIET], FISH=[NORMAL, DIET], MEAT=[NORMAL, DIET, FAT]}
</pre>
</div>
</div>

<div id="outline-container-org1159091" class="outline-4">
<h4 id="org1159091"><span class="section-number-4">2.2.4</span> 分区</h4>
<div class="outline-text-4" id="text-2-2-4">
<div class="org-src-container">
<pre class="src src-java">System.out.println(<span style="color: #00afaf;">"===== getVegetarianDishes (partitioningBy) ====="</span>);
getVegetarianDishes();
System.out.println(<span style="color: #00afaf;">"===== getMostCaloricPartitionedByVegetarian (multi-level partitioningBy) ====="</span>);
getMostCaloricPartitionedByVegetarian();
</pre>
</div>


<pre class="example">
===== getVegetarianDishes (partitioningBy) =====
[com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0, com.cisco.ruan.nio.Dish@5d099f62]
===== getMostCaloricPartitionedByVegetarian (multi-level partitioningBy) =====
{false=pork, true=pizza}
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orged76c19" class="outline-2">
<h2 id="orged76c19"><span class="section-number-2">3</span> Lambda</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org5a926c1" class="outline-3">
<h3 id="org5a926c1"><span class="section-number-3">3.1</span> 知识点</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org663ca4f" class="outline-4">
<h4 id="org663ca4f"><span class="section-number-4">3.1.1</span> 谓词（Predicate）</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
返回 boolean 的函数
</p>
</div>
</div>


<div id="outline-container-org439b29d" class="outline-4">
<h4 id="org439b29d"><span class="section-number-4">3.1.2</span> 函数式接口（Functional Interface）</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
只有一个 <b>抽象</b> 方法的接口，这种类型的接口也称为 SAM 接口，即 Single Abstract Method interfaces ，主要用在 Lambda 表达式
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">interface</span> <span style="color: #af8700;">MyService</span> {

    <span style="color: #af8700;">void</span> <span style="color: #0087ff;">test</span>(<span style="color: #af8700;">String</span> <span style="color: #0087ff;">s</span>); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#19968;&#20010;&#25277;&#35937;&#26041;&#27861;</span>

    <span style="color: #5f8700;">default</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">defaultWork</span>() {
        <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#20989;&#25968;&#24335;&#25509;&#21475;&#37324;&#21487;&#20197;&#21253;&#21547;&#40664;&#35748;&#26041;&#27861;</span>
    }

    <span style="color: #5f8700;">static</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">printHello</span>(){
        <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#20989;&#25968;&#24335;&#25509;&#21475;&#37324;&#21487;&#20197;&#21253;&#21547;&#38745;&#24577;&#26041;&#27861;</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2559485" class="outline-4">
<h4 id="org2559485"><span class="section-number-4">3.1.3</span> 常见函数式接口</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li><p>
Comparable (T, T) -&gt; int
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Comparator</span>&lt;<span style="color: #af8700;">T</span>&gt; {
    <span style="color: #af8700;">int</span> <span style="color: #0087ff;">compare</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">o1</span>, <span style="color: #af8700;">T</span> <span style="color: #0087ff;">o2</span>);
}
</pre>
</div></li>

<li><p>
Runnable () -&gt; void
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Runnable</span> {
    <span style="color: #5f8700;">public</span> <span style="color: #5f8700;">abstract</span> <span style="color: #af8700;">void</span> <span style="color: #0087ff;">run</span>();
}
</pre>
</div></li>

<li><p>
Callable () -&gt; T
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Callable</span>&lt;<span style="color: #af8700;">V</span>&gt; {
    <span style="color: #af8700;">V</span> <span style="color: #0087ff;">call</span>() <span style="color: #5f8700;">throws</span> <span style="color: #af8700;">Exception</span>;
}
</pre>
</div></li>

<li><p>
Predicate (T) -&gt; boolean
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Predicate</span>&lt;<span style="color: #af8700;">T</span>&gt;{
    <span style="color: #af8700;">boolean</span> <span style="color: #0087ff;">test</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>);
}
</pre>
</div></li>

<li><p>
BiPredicate (T, U) -&gt; boolean
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">BiPredicate</span>&lt;<span style="color: #af8700;">T</span>, <span style="color: #af8700;">U</span>&gt; {
    <span style="color: #af8700;">boolean</span> <span style="color: #0087ff;">test</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>, <span style="color: #af8700;">U</span> <span style="color: #0087ff;">u</span>);
}
</pre>
</div></li>

<li><p>
Consumer (T) -&gt; void
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Consumer</span>&lt;<span style="color: #af8700;">T</span>&gt;{
    <span style="color: #af8700;">void</span> <span style="color: #0087ff;">accept</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>);
}
</pre>
</div></li>

<li><p>
BiConsumer (T, U) -&gt; void
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">BiConsumer</span>&lt;<span style="color: #af8700;">T</span>, <span style="color: #af8700;">U</span>&gt; {
    <span style="color: #af8700;">void</span> <span style="color: #0087ff;">accept</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>, <span style="color: #af8700;">U</span> <span style="color: #0087ff;">u</span>);
}
</pre>
</div></li>

<li><p>
Function (T) -&gt; R
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">T</span>, <span style="color: #af8700;">R</span>&gt;{
    <span style="color: #af8700;">R</span> <span style="color: #0087ff;">apply</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>);
}
</pre>
</div></li>

<li><p>
UnaryOperator (T) -&gt; T
</p>

<p>
Function&lt;T, T&gt;
</p></li>

<li><p>
BiFunction (T, U) -&gt; R
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">BiFunction</span>&lt;<span style="color: #af8700;">T</span>, <span style="color: #af8700;">U</span>, <span style="color: #af8700;">R</span>&gt; {
    <span style="color: #af8700;">R</span> <span style="color: #0087ff;">apply</span>(<span style="color: #af8700;">T</span> <span style="color: #0087ff;">t</span>, <span style="color: #af8700;">U</span> <span style="color: #0087ff;">u</span>);
}
</pre>
</div></li>

<li><p>
BinaryOperator (T, T) -&gt; T
</p>

<p>
BiBunction&lt;T, T, T&gt;
</p></li>

<li><p>
Supplier () -&gt; T
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">@FunctionalInterface</span>
<span style="color: #5f8700;">public</span> <span style="color: #5f8700;">interface</span> <span style="color: #af8700;">Supplier</span>&lt;<span style="color: #af8700;">T</span>&gt; {
    <span style="color: #af8700;">T</span> <span style="color: #0087ff;">get</span>();
}
</pre>
</div></li>
</ul>
</div>
</div>



<div id="outline-container-org99ec167" class="outline-4">
<h4 id="org99ec167"><span class="section-number-4">3.1.4</span> 方法引用</h4>
<div class="outline-text-4" id="text-3-1-4">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">方法引用</td>
<td class="org-left">Lambda 表达式</td>
</tr>

<tr>
<td class="org-left">ClassName::staticMethod</td>
<td class="org-left">(args) -&gt; ClassName.staticMethod(args)</td>
</tr>

<tr>
<td class="org-left">ClassName::instanceMethod</td>
<td class="org-left">(ins, args) -&gt; ins.instanceMethod(args)</td>
</tr>

<tr>
<td class="org-left">expr::instanceMethod</td>
<td class="org-left">(args) -&gt; expr.instanceMethod(args)</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org1ba5de4" class="outline-4">
<h4 id="org1ba5de4"><span class="section-number-4">3.1.5</span> 构造方法引用</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
对于一个现有构造函数，可以利用它的名称和关键字 new 来创建它的一个引用: ClassName::new <br>
它的功能与指向静态方法的引用类似
</p>
</div>
</div>


<div id="outline-container-orge2e15a8" class="outline-4">
<h4 id="orge2e15a8"><span class="section-number-4">3.1.6</span> 类型检查与推断</h4>
<div class="outline-text-4" id="text-3-1-6">
<ul class="org-ul">
<li>Lambda 的类型是从使用 Lambda 的上下文推断出来的</li>
<li>同一个 Lambda 表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容</li>
<li>Java 编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式</li>
</ul>
</div>
</div>


<div id="outline-container-orgda08c36" class="outline-4">
<h4 id="orgda08c36"><span class="section-number-4">3.1.7</span> 特殊的 void 兼容规则</h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
如果一个 Lambda 的主体是一个语句表达式，它就和一个返回 void 的函数描述符兼容。<br>
例如，以下两行都是合法的，尽管 List 的 add 方法返回了一个 boolean ，而不是 Consumer 上下文 (T -&gt; void) 所要求的 void :
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Predicate</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">p</span> = s -&gt; list.add(s);

<span style="color: #af8700;">Consumer</span>&lt;<span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">b</span> = s -&gt; list.add(s);
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd362c17" class="outline-3">
<h3 id="orgd362c17"><span class="section-number-3">3.2</span> 示例代码</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org0a17f77" class="outline-4">
<h4 id="org0a17f77"><span class="section-number-4">3.2.1</span> 方法引用</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">
<pre class="src src-java">str.sort((s1, s2) -&gt; s1.compareToIgnoreCase(s2)); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
str.sort(String::compareToIgnoreCase);

<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">String</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">stringToInteger</span> =
    (String <span style="color: #af8700;">s</span>) -&gt; Integer.parseInt(s); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">String</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">stringToInteger</span> = Integer::parseInt;

<span style="color: #af8700;">BiPredicate</span>&lt;<span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">String</span>&gt;, <span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">contains</span> =
    (list, element) -&gt; list.contains(element); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
<span style="color: #af8700;">BiPredicate</span>&lt;<span style="color: #af8700;">List</span>&lt;<span style="color: #af8700;">String</span>&gt;, <span style="color: #af8700;">String</span>&gt; <span style="color: #0087ff;">contains</span> = List::contains;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaefdc8d" class="outline-4">
<h4 id="orgaefdc8d"><span class="section-number-4">3.2.2</span> 构造方法引用</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Supplier</span>&lt;<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">a</span> = () -&gt; <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Apple</span>(); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
<span style="color: #af8700;">Supplier</span>&lt;<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">a</span> = Apple::<span style="color: #5f8700;">new</span>;

<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>,<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">a</span> = (weight) -&gt; <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Apple</span>(weight); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>,<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">a</span> = Apple::<span style="color: #5f8700;">new</span>;

<span style="color: #af8700;">BiFunction</span>&lt;<span style="color: #af8700;">String</span>, <span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">c3</span> =
    (color, weight) -&gt; <span style="color: #5f8700;">new</span> <span style="color: #af8700;">Apple</span>(color, weight); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">=&gt;</span>
<span style="color: #af8700;">BiFunction</span>&lt;<span style="color: #af8700;">String</span>, <span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">c3</span> = Apple::<span style="color: #5f8700;">new</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org7dd9917" class="outline-4">
<h4 id="org7dd9917"><span class="section-number-4">3.2.3</span> 排序</h4>
<div class="outline-text-4" id="text-3-2-3">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">Comparator &#20855;&#26377;&#19968;&#20010;&#21483;&#20316; comparing &#30340;&#38745;&#24577;&#36741;&#21161;&#26041;&#27861;&#65292;</span>
<span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#23427;&#21487;&#20197;&#25509;&#21463;&#19968;&#20010; Function &#26469;&#25552;&#21462; Comparable &#38190;&#20540;&#65292;&#24182;&#29983;&#25104;&#19968;&#20010; Comparator &#23545;&#35937;</span>
<span style="color: #5f8700;">import</span> <span style="color: #5f8700;">static</span> <span style="color: #00afaf;">java</span>.<span style="color: #00afaf;">util</span>.Comparator.<span style="color: #af8700;">comparing</span>;
inventories.sort(comparing((a) -&gt; a.getWeight()));
inventories.sort(comparing(Apple::getWeight));

inventories.sort(comparing(Apple::getWeight).reversed()); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#36870;&#24207;</span>

inventories.sort(comparing(Apple::getWeight).thenComparing(Apple::getColour)); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">&#27604;&#36739;&#22120;&#38142;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaeb9ba5" class="outline-4">
<h4 id="orgaeb9ba5"><span class="section-number-4">3.2.4</span> 谓词复合 (negate, and, or)</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。
</p>

<p>
<code>a.or(b).and(c)</code> 可以看作 <code>(a || b) &amp;&amp; c</code>
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #af8700;">Predicate</span>&lt;<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">notRedApple</span> = redApple.negate();

<span style="color: #af8700;">Predicate</span>&lt;<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">redAndHeavyApple</span> =
    redApple.and(a -&gt; a.getWeight() &gt; 150);

<span style="color: #af8700;">Predicate</span>&lt;<span style="color: #af8700;">Apple</span>&gt; <span style="color: #0087ff;">redAndHeavyAppleOrGreen</span> =
    redApple.and(a -&gt; a.getWeight() &gt; 150)
    .or(a -&gt; <span style="color: #00afaf;">"green"</span>.equals(a.getColor()));
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8f6fe6" class="outline-4">
<h4 id="orgd8f6fe6"><span class="section-number-4">3.2.5</span> 函数复合</h4>
<div class="outline-text-4" id="text-3-2-5">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">andThen: g(f(x))</span>
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">f</span> = x -&gt; x + 1;
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">g</span> = x -&gt; x * 2;
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">h</span> = f.andThen(g);
<span style="color: #af8700;">int</span> <span style="color: #0087ff;">result</span> = h.apply(1); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">4</span>

<span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">compose: f(g(x))</span>
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">f</span> = x -&gt; x + 1;
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">g</span> = x -&gt; x * 2;
<span style="color: #af8700;">Function</span>&lt;<span style="color: #af8700;">Integer</span>, <span style="color: #af8700;">Integer</span>&gt; <span style="color: #0087ff;">h</span> = f.compose(g);
<span style="color: #af8700;">int</span> <span style="color: #0087ff;">result</span> = h.apply(1); <span style="color: #585858; font-style: italic;">// </span><span style="color: #585858; font-style: italic;">3</span>
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-org9fd843a" class="outline-2">
<h2 id="org9fd843a"><span class="section-number-2">4</span> Optional</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org0492ed8" class="outline-3">
<h3 id="org0492ed8"><span class="section-number-3">4.1</span> 基本原理</h3>
<div class="outline-text-3" id="text-4-1">
<p>
不推荐使用基础类型的 Optional ，因为基础类型的 Optional 不支持map，flatMap 以及 filter 方法，
而这些却是 Optional 类最有用的方法。
</p>
</div>
</div>


<div id="outline-container-orgec382c4" class="outline-3">
<h3 id="orgec382c4"><span class="section-number-3">4.2</span> 代码示例</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org71fee27" class="outline-4">
<h4 id="org71fee27"><span class="section-number-4">4.2.1</span> 类三元操作符</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
以不解包的方式组合两个 Optional 对象，用一行语句实现条件判断的结构：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f8700;">public</span> <span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Insurance</span>&gt; <span style="color: #0087ff;">nullSafeFindCheapestInsurance</span>(<span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Person</span>&gt; <span style="color: #0087ff;">person</span>, <span style="color: #af8700;">Optional</span>&lt;<span style="color: #af8700;">Car</span>&gt; <span style="color: #0087ff;">car</span>) {
    <span style="color: #5f8700;">return</span> person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p, c)));
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org66a2f78" class="outline-4">
<h4 id="org66a2f78"><span class="section-number-4">4.2.2</span> 避免在 Null 对象上调用 stream()</h4>
<div class="outline-text-4" id="text-4-2-2">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00afaf;">org</span>.<span style="color: #00afaf;">apache</span>.<span style="color: #00afaf;">commons</span>.<span style="color: #00afaf;">collections4</span>.CollectionUtils.emptyIfNull(list)
    .stream()
    .filter(...);
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>