#+TITLE:     Stream
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 1, 基本原理

流的使用一般包括三件事:

- 一个数据源（如集合）来执行一个查询
- 一个中间操作链，形成一条流的流水线
- 一个终端操作，执行流水线，并能生成结果

* 2, 示例代码

** 2.1, 筛选

#+BEGIN_SRC java
  // 谓词筛选
  List<Dish> vegetarianMenu = menu.stream()
      .filter(Dish::isVegetarian)
      .collect(toList());

  // 筛选各异
  List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
  number.stream()
      .filter(i -> i % 2 == 0)
      .distinct()
      .forEach(System.out::println);

  // 截短
  List<Dish> dishes = menu.stream()
      .filter(d -> d.getCalories() > 300)
      .limit(3)
      .collect(toList());

  // 跳过
  List<Dish> dishes = menu.stream()
      .filter(d -> d.getCalories() > 300)
      .skip(2)
      .collect(toList());
#+END_SRC

** 2.2, 映射

#+BEGIN_SRC java
  List<String> dishNames = menu.stream()
      .map(Dish::getName)
      .collect(toList());

  // 扁平化流
  List<String> uniqueCharacters =
      words.stream()
      .map(w -> w.split(""))
      .flatMap(Arrays::stream)    // Arrays.stream() 的方法可以接受一个数组并产生一个流
                                  // 将各个生成流扁平化为单个流
      .distinct()
      .collect(Collectors.toList());
#+END_SRC

** 2.3, 归约

此类查询需要将流中所有元素反复结合起来，得到一个值。这样的查询可以被归类为归约操作（将流归约成一个值）。\\
用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（流）反复折叠成一个小方块，而这就是折叠操作的结果。

#+BEGIN_SRC java
  // 求和
  int sum = numbers.stream().reduce(0, (a, b) -> a + b); // BinaryOperator<T> 用来将两个元素结合起来产生一个新值
  int sum = numbers.stream().reduce(0, Integer::sum);


  // reduce 还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象
  // 因为流中可能没有任何元素的情况，reduce 操作就无法返回其和，因为它没有初始值
  // 这就是为什么结果被包裹在一个 Optional 对象里，以表明和可能不存在
  Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));

  // 计算最大值
  Optional<Integer> max = numbers.stream().reduce(Integer::max);
#+END_SRC

** 2.4, 数值流

IntStream 中的 map 方法只能为流中的每个元素返回另一个 int ，如果这不是你想要的，可以用 IntStream 的 mapToObj 方法改写它，这个方法会返回一个对象值流。\\
或者使用 boxed 方法先转换为 Stream<Integer>

#+BEGIN_SRC java
  IntStream evenNumbers = IntStream.range(1, 100);
  IntStream evenNumbers = IntStream.rangeClosed(1, 100);
#+END_SRC

** 2.5, 构造流

#+BEGIN_SRC java
  // 由值创建流
  Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
  Stream<String> emptyStream = Stream.empty();

  // 由数组创建流
  int[] numbers = {2, 3, 5, 7, 11, 13};
  int sum = Arrays.stream(numbers).sum();

  // 由文件生成流
  Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset());

  // 由函数生成流 （创建无限流）
  /*
    Stream API 提供了两个静态方法来从函数生成流: Stream.iterate 和 Stream.generate ，这两个操作可以创建所谓的无限流
    由 iterate 和 generate 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去
    一般来说，应该使用 limit(n) 来对这种流加以限制，以避免打印无穷多个值
  ,*/
  Stream.iterate(0, n -> n + 2)
      .limit(10)
      .forEach(System.out::println);

  Stream.generate(Math::random)
      .limit(5)
      .forEach(System.out::println);

  IntStream ones = IntStream.generate(() -> 1);

#+END_SRC