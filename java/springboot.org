#+TITLE:     SpingBoot
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* 工具

** JacksonXML

*** 示例数据

#+BEGIN_SRC xml
  <root k6="6">
      <k1>str</k1>
      <k-2>2</k-2>
      <k3>
          <ki>1</ki>
          <ki>2</ki>
      </k3>
      <k5>5-1</k5>
      <k5>5-2</k5>
      <k9><![CDATA[中<a>文]]></k9>
  </root>
#+END_SRC


*** pom 配置

#+BEGIN_SRC xml
  <dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
  </dependency>
#+END_SRC


*** DTO

#+BEGIN_SRC java
  import java.util.*;
  import com.fasterxml.jackson.dataformat.xml.annotation.*;
  import lombok.Data;


  @Data
  @JacksonXmlRootElement(localName="root")
  public class RootXml {

      private String k1;

      @JacksonXmlProperty(localName="k-2")
      private Integer k2;

      @JacksonXmlProperty(localName="k3")
      @JacksonXmlElementWrapper(useWrapping=true)
      private Collection<String> kis;

      @JacksonXmlElementWrapper(useWrapping=false)
      private Collection<String> k5;

      @JacksonXmlProperty(isAttribute=true)
      private Integer k6;

      @JacksonXmlCData(value=true) // 序列化时是否总是使用 CDATA 块
      private String k9;
  }
#+END_SRC

*** Controller

#+BEGIN_SRC java
  @PostMapping(path="/xml", consumes=MediaType.APPLICATION_XML_VALUE)
  public void test(@RequestBody RootXml xml) {

  }
#+END_SRC




** MapStruct

*** pom 配置

**** properties

#+BEGIN_SRC xml
  <properties>
    <org.mapstruct.version>1.2.0.Final</org.mapstruct.version>
  </properties>
#+END_SRC

**** dependency

#+BEGIN_SRC xml
  <!-- 针对 swagger 的 workaround -->
  <dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <exclusions>
      <exclusion>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
      </exclusion>
    </exclusions>
  </dependency>

  <dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-jdk8</artifactId> <!-- use mapstruct-jdk8 for Java 8 or higher -->
    <version>${org.mapstruct.version}</version>
  </dependency>

  <dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>${org.mapstruct.version}</version>
    <scope>provided</scope>
  </dependency>
#+END_SRC

**** plugin

#+BEGIN_SRC xml
  <!-- 兼容 lombok -->
  <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
  </plugin>
#+END_SRC


*** Mapper 接口

#+BEGIN_SRC java
  @Mapper(unmappedTargetPolicy=ReportingPolicy.IGNORE)
  public interface ClassAMapper {

      ClassAMapper MAPPER = Mappers.getMapper( ClassAMapper.class );

      @Mappings({
              @Mapping(source="id", target="ID"),
              @Mapping(source="name", target="NAME")
      })
      ClassA from(ClassB obj);

      default ClassA from(ClassC obj) {
          // Custmization
      }
  }
#+END_SRC


*** 调用

#+BEGIN_SRC java
  ClassB objB = new ClassB();
  ClassC objC = new ClassC();
  ClassA.MAPPER.from(objB);
  ClassA.MAPPER.from(objC);
#+END_SRC


** MapperFactory

*** 配置

#+BEGIN_SRC xml
  <dependency>
    <groupId>ma.glasnost.orika</groupId>
    <artifactId>orika-core</artifactId>
    <version>1.5.2</version><!-- or latest version -->
  </dependency>
#+END_SRC


#+BEGIN_SRC java
  @Configuration
  public class MapperConfig extends ConfigurableMapper {

      @Bean
      public MapperFactory mapperFactory(){
          MapperFactory factory = new DefaultMapperFactory.Builder().build();
          factory.classMap(NetworkDto.class, Network.class)
              .field("group.id", "groupId")
              .mapNulls(false)
              .byDefault()
              .register();
          return factory;
      }
  }
#+END_SRC

*** 使用

#+BEGIN_SRC java
  class NetworkBo {

      @Autowired
      private MapperFactory mapperFactory;

      public void handle() {
          NetworkDto dto = ...;
          Network network = ...;
          mapperFactory.getMapperFacade().map(dto, network);
      }
  }

#+END_SRC


*** 传送门

- [[https://orika-mapper.github.io/orika-docs/advanced-mappings.html][高级映射配置]]

* 实践

** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-restful-service][Restful Service (MVC)]]

*** WebApplicationInitializer

实现 =WebApplicationInitializer= 接口便可以实现等同于对 =web.xml= 进行配置

*** Controller

#+BEGIN_SRC java
  @RestController
  @RequestMapping("/{userId}/bookmarks")
  class BookmarkRestController {

      @PostMapping
      ResponseEntity<?> add(@PathVariable String userId, @RequestBody Bookmark input) {
          return ResponseEntity.noContent().build();
      }
  }
#+END_SRC


*** HttpMessageConverter

对每个 HTTP 请求，Spring MVC 将遍历所有配置的 HttpMessageConverter 对象，
直到找到一个合适的对象可以将返回的 POJO 转换成 Accept header 中指定的 content type 。

Spring Boot 会自动组装一个可以转换成 JSON 类型的 HttpMessageConverter 对象。

HttpMessageConverter 工作于两个方向：
- 请求（ content-type => Java object ）
- 响应（ Java object => content-type ）


*** 异常处理

**** 异常级别

正常情况下，任何未被处理的异常将导致服务器返回 HTTP 500 Response 。
自定义的异常可以通过添加 =@ResponseStatus= 注解从而使用指定的 status code 。

#+BEGIN_SRC java
   @ResponseStatus(value=HttpStatus.NOT_FOUND, reason="No such Order")  // 404
   public class OrderNotFoundException extends RuntimeException {
       // TODO
   }
#+END_SRC

#+BEGIN_SRC java
  @RequestMapping(value="/orders/{id}", method=GET)
  public String showOrder(@PathVariable("id") long id, Model model) {
      Order order = orderRepository.findOrderById(id);

      if (order == null) throw new OrderNotFoundException(id);

      model.addAttribute(order);
      return "orderDetail";
  }
#+END_SRC



**** 控制器级别

使用 =@ExceptionHandler= 注解处理同一个控制器中抛出的异常，这种方式的优点：

- 可以处理没有被 =@ResponseStatus= 注解过的异常
- 可以将用户重定向到专门的错误页面
- 组装一个完全定制化的 error response

#+BEGIN_SRC java
  @Controller
  public class ExceptionHandlingController {

      // @RequestHandler methods that maybe throw exception
      ...


      // Exception handling methods:

      // Convert a predefined exception to an HTTP Status code
      @ResponseStatus(value=HttpStatus.CONFLICT, reason="Data integrity violation")  // 409
      @ExceptionHandler(DataIntegrityViolationException.class)
      public void conflict() {
          // TODO
      }

      // Specify name of a specific view that will be used to display the error:
      @ExceptionHandler({SQLException.class, DataAccessException.class})
      public String databaseError() {
          // Nothing to do.  Returns the logical view name of an error page, passed
          // to the view-resolver(s) in usual way.
          return "databaseError";
      }

      // Total control - setup a model and return the view name yourself. Or
      // consider subclassing ExceptionHandlerExceptionResolver.
      @ExceptionHandler(Exception.class)
      public ModelAndView handleError(HttpServletRequest req, Exception ex) {
          logger.error("Request: " + req.getRequestURL() + " raised " + ex);

          ModelAndView mav = new ModelAndView();
          mav.addObject("exception", ex);
          mav.addObject("url", req.getRequestURL());
          mav.setViewName("error");
          return mav;
      }
  }
#+END_SRC

**** 全局级别

任何标注 =@ControllerAdvice= / =@RestControllerAdvice= 注解的类支持 3 种类型的方法：

- Exception handling methods annotated with =@ExceptionHandler=
- Model enhancement methods (for adding additional data to the model) annotated with =@ModelAttribute=
- Binder initialization methods (used for configuring form-handling) annotated with =@InitBinder=


#+BEGIN_SRC java
  @ControllerAdvice
  class GlobalControllerExceptionHandler {
      @ResponseStatus(HttpStatus.CONFLICT)  // 409
      @ExceptionHandler(DataIntegrityViolationException.class)
      public void handleConflict() {
          // Nothing to do
      }
  }
#+END_SRC

***** 重新抛出

#+BEGIN_SRC java
  @ControllerAdvice
  class GlobalDefaultExceptionHandler {
    public static final String DEFAULT_ERROR_VIEW = "error";

    @ExceptionHandler(value = Exception.class)
    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
      // If the exception is annotated with @ResponseStatus rethrow it and let
      // the framework handle it - like the OrderNotFoundException example
      // at the start of this post.
      // AnnotationUtils is a Spring Framework utility class.
      if (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != null)
        throw e;

      // Otherwise setup and send the user to a default error-view.
      ModelAndView mav = new ModelAndView();
      mav.addObject("exception", e);
      mav.addObject("url", req.getRequestURL());
      mav.setViewName(DEFAULT_ERROR_VIEW);
      return mav;
    }
  }
#+END_SRC



** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-application-event][Application Event]]

*** Event

    #+BEGIN_SRC java
  @ToString
  public class Event extends ApplicationEvent {

      private static final long serialVersionUID = 1L;

      @Getter
      private String message;

      public Event(Object source, String message) {
          super(source);
          this.message = message;
      }

  }
    #+END_SRC


*** Listener

    #+BEGIN_SRC java
  @Component
  @Slf4j
  public class Listener {

      @EventListener
      public void handlerEvent(Event event) {
          log.info("Receive event: {}", event);
      }

  }
    #+END_SRC


*** Publisher

    #+BEGIN_SRC java
  @Service
  @Slf4j
  public class Publisher {

      @Autowired
      private ApplicationContext applicationContext;

      public void publish(String message) {
          log.info("Sending message: {}", message);
          applicationContext.publishEvent(new Event(this, message));
      }

  }
    #+END_SRC


*** 自定义 applicationEventMulticaster

    #+BEGIN_SRC java
  @Bean(name="applicationEventMulticaster")
  public ApplicationEventMulticaster simpleApplicationEventMulticaster() {
      SimpleApplicationEventMulticaster eventMulticaster
          = new SimpleApplicationEventMulticaster();
      eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
      return eventMulticaster;
  }
    #+END_SRC


*** 常见 SpringApplicationEvent

- ApplicationEnvironmentPreparedEvent
- ApplicationFailedEvent
- ApplicationPreparedEvent
- ApplicationReadyEvent
- ApplicationStartingEvent



** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-async-method][Async Method]]


*** 异常统一捕获

    如果需要统一进行异常捕获，可以实现 =AsyncConfigurer= 接口，
    =getAsyncExecutor= 方法返回的 Executor 对象用于处理异步方法调用，
    =getAsyncUncaughtExceptionHandler= 方法返回的对象捕获异步调用期间产生的异常，
    *当且仅当异步调用方法的返回类型为 void* 。

    #+BEGIN_SRC java
  @EnableAsync
  @Configuration
  public class AsyncConfiguration implements AsyncConfigurer {

      @Override
      public Executor getAsyncExecutor() {
          ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
          taskExecutor.setCorePoolSize(4);
          taskExecutor.setMaxPoolSize(8);
          taskExecutor.setQueueCapacity(32);
          taskExecutor.initialize();
          return taskExecutor;
      }

      @Override
      public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
          return new SimpleAsyncUncaughtExceptionHandler();
      }

  }
    #+END_SRC


** Scheduling Tasks

*** 启用计划任务

    在配置类上使用 =@EnableScheduling= 来开启对计划任务的支持。


*** 任务执行

**** 每隔固定时间执行

     #+BEGIN_SRC java
  @Scheduled(fixedRate=5000)
     #+END_SRC

**** 指定任务间隔

     #+BEGIN_SRC java
  // specify the interval between invocations measured
  // from the completion of the task
  @Scheduled(fixedDelay=5000)
     #+END_SRC

**** UNIX Cron 风格

     #+BEGIN_SRC java
  @Scheduled(cron="0 28 11 ? * *") // 每天 11 点 28 分 执行
     #+END_SRC


** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-type-safe-configuration-properties][Type Safe Configuration Properties]]

*** 配置文件

    #+BEGIN_SRC sh
  #Simple properties
  mail.host=mailer@mail.com
  mail.port=9000
  mail.from=mailer@mail.com

  #List properties
  mail.defaultRecipients[0]=admin@mail.com
  mail.defaultRecipients[1]=owner@mail.com

  #Map Properties
  mail.additionalHeaders.redelivery=true
  mail.additionalHeaders.secure=true

  #Object properties
  mail.credentials.username=john
  mail.credentials.password=password
  mail.credentials.authMethod=SHA1
    #+END_SRC


*** Properties Bean

    #+BEGIN_SRC java
  @Getter
  @Setter
  @ToString
  @Configuration
  @Validated
  @PropertySource("classpath:configprops.properties")
  @ConfigurationProperties(prefix="mail")
  public class ConfigProperties {

      @Getter
      @Setter
      @ToString
      public static class Credentials {
          @Length(max=4, min=1)
          private String authMethod;
          private String username;
          private String password;
      }

      @NotBlank
      private String host;
      @Min(1025)
      @Max(65536)
      private int port;
      @Pattern(regexp="^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,6}$")
      private String from;

      // In order to validate values of nested properties,
      // you must annotate the associated field as @Valid to trigger its validation.
      @Valid
      private Credentials credentials;
      private List<String> defaultRecipients;
      private Map<String, String> additionalHeaders;

  }

    #+END_SRC


** 内容注入

*** 注入普通字符串

    #+BEGIN_SRC java
  @Value("I love you")
  String normal;
    #+END_SRC


*** 注入操作系统属性

    #+BEGIN_SRC java
  @Value("#{systemProperties['os.name']}")
  String osName
    #+END_SRC


*** 注入表达式结果

    #+BEGIN_SRC java
  @Value("#{ T(java.lang.Math).random() * 100.0 }")
  double randomNumber;
    #+END_SRC


*** 注入其他 Bean 属性

    #+BEGIN_SRC java
  @Value("#{anotherBean.value}")
  String another;
    #+END_SRC


*** 注入文件资源

    #+BEGIN_SRC java
  @Value("classpath:test.txt")
  Resource testFile;
    #+END_SRC


*** 注入网址资源

    #+BEGIN_SRC java
  @Value("http://www.baidu.com")
  Resource testUrl;

    #+END_SRC


*** 从配置文件注入

    #+BEGIN_SRC java
      @Configuration
      @PropertySource("classpath:jdbc.properties")
      public class MyConfig {
          @Value("${jdbc.url}")
          private String jdbcUrl;
      }


    #+END_SRC


** Springboot Test

*** 样板文件

#+BEGIN_SRC java
  @RunWith(SpringRunner.class)
  @SpringBootTest(SpringBootTest.WebEnvironment.MOCK, classes=XxxApplication.class)
  @AutoConfigureMockMvc
  @ActiveProfiles("xxx")
  @TestPropertySource(locations="classpath:xxx.properties")
  public class ApplicationTest {

      @Test
      public void test() {
        // TODO
      }

  }

#+END_SRC



*** MockMvc

#+BEGIN_SRC java
  @Autowired
  private MockMvc mockMvc;

  @Test
  public void testHttpMethodWithPathVariable() throws Exception {
      mockMvc.perform(MockMvcRequestBuilders.get("/hello/{name}", "John"))
          .andDo(MockMvcResultHandlers.print()) // print request and response
          .andExpect(MockMvcResultMatchers.status().isOk())
          .andExpect(MockMvcResultMatchers.content().contentType("application/json;charset=UTF-8"))
          .andExpect(MockMvcResultMatchers.jsonPath("$.message").value("Hello World John!!!"));
  }

  @Test
  public void testHttpMethodWithQueryParameters() throws Exception {
      this.mockMvc.perform(get("/greetWithQueryVariable")
                           .param("name", "John Doe")
                           .param("age", "30"))
          .andDo(MockMvcResultHandlers.print())
          .andExpect(MockMvcResultMatchers.status().isOk())
          .andExpect(MockMvcResultMatchers.content().contentType("application/json;charset=UTF-8"))
          .andExpect(MockMvcResultMatchers.jsonPath("$.message").value("Hello World John Doe!!!"));
  }


#+END_SRC


*** Hamcrest

=import static org.hamcrest.Matchers.*;=

=import static org.junit.Assert.assertThat;=

**** Core API

- is
- not
- anyOf :: assertThat(str, anyOf(startsWith(start), containsString(end)))
- allOf :: assertThat(str, allOf(startsWith(start), containsString(end)))


**** Object Matcher

- hasToString(str) :: To assert that the `toString` method of an Object returns a specified `str`
- typeCompatibleWith(clazz) :: check that one class is a sub-class of another
- sameInstance
- instanceOf


**** Bean Matcher

- hasProperty
- samePropertyValuesAs


**** Collection Matcher

- empty
- hasSize
- arrayWithSize
- containsInAnyOrder
- contains :: in given order
- hasItemInArray
- isOneOf / isIn
- arrayContainingInAnyOrder
- arrayContaining
- hasKey
- hasValue
- hasEntry
- everyItem :: assertThat(list, everyItem(greaterThan(0)))

**** Number Matcher

- greaterThan
- greaterThanOrEqualTo
- lessThan
- lessThanOrEqualTo
- closeTo(pivot, deviation)


**** Text Matcher

- isEmptyString
- isEmptyOrNullString
- equalToIgnoringWhiteSpace
- stringContainsInOrder
- equalToIgnoringCase
- containsString(str)
- startsWith(str)
- endsWith(str)
- notNullValue


*** Mockito

Mock 测试就是在测试过程中，对于某些不容易构造（如 HttpServletRequest 必须在Servlet 容器中才能构造出来）
或者不容易获取比较复杂的对象（如 JDBC 中的ResultSet 对象），用一个虚拟的对象（Mock 对象）来创建以便测试的测试方法。

Mock 最大的功能是把单元测试的耦合分解开，如果代码对另一个类或者接口有依赖，它能够模拟这些依赖，并帮助验证所调用的依赖的行为。


**** Mock 与 Stub 的区别

Mock 不是 Stub，两者是有区别的：

- 前者被称为 mockist TDD，而后者一般称为 classic TDD
- 前者是基于行为的验证（behavior verification），后者是基于状态的验证 （state verification）
- 前者使用的是模拟的对象，而后者使用的是真实的对象



**** 验证行为

#+BEGIN_SRC java
  //Let's import Mockito statically so that the code looks clearer
  import static org.mockito.Mockito.*;

  //mock creation
  List mockedList = mock(List.class);

  //using mock object
  mockedList.add("one");
  mockedList.clear();

  //verification
  verify(mockedList).add("one");
  verify(mockedList).clear();
#+END_SRC

一旦创建 mock 将会 *记得所有的交互* 。可以选择验证感兴趣的任何交互。


**** 打桩

#+BEGIN_SRC java
  //You can mock concrete classes, not just interfaces
  LinkedList mockedList = mock(LinkedList.class);

  //stubbing
  when(mockedList.get(0)).thenReturn("first");
  when(mockedList.get(1)).thenThrow(new RuntimeException());

  //following prints "first"
  System.out.println(mockedList.get(0));

  //following throws runtime exception
  System.out.println(mockedList.get(1));

  //following prints "null" because get(999) was not stubbed
  System.out.println(mockedList.get(999));
#+END_SRC


**** 连续调用打桩对象

#+BEGIN_SRC java
  when(mock.someMethod("some arg"))
   .thenThrow(new RuntimeException())
   .thenReturn("foo");

  //First call: throws runtime exception:
  mock.someMethod("some arg");

  //Second call: prints "foo"
  System.out.println(mock.someMethod("some arg"));

  //Any consecutive call: prints "foo" as well (last stubbing wins).
  System.out.println(mock.someMethod("some arg"));

#+END_SRC

#+BEGIN_SRC java
  when(mock.someMethod("some arg"))
      .thenReturn("one", "two", "three");

#+END_SRC


**** 参数匹配器

#+BEGIN_SRC java
  //stubbing using built-in anyInt() argument matcher
  when(mockedList.get(anyInt())).thenReturn("element");

  //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
  when(mockedList.contains(argThat(isValid()))).thenReturn("element");

  //following prints "element"
  System.out.println(mockedList.get(999));

  //you can also verify using an argument matcher
  verify(mockedList).get(anyInt());
#+END_SRC

[[https://static.javadoc.io/org.mockito/mockito-core/2.21.0/org/mockito/Matchers.html][更多内置匹配器]]


**** 调用次数

#+BEGIN_SRC java
  //using mock
  mockedList.add("once");

  mockedList.add("twice");
  mockedList.add("twice");

  mockedList.add("three times");
  mockedList.add("three times");
  mockedList.add("three times");

  //following two verifications work exactly the same - times(1) is used by default
  verify(mockedList).add("once");
  verify(mockedList, times(1)).add("once");

  //exact number of invocations verification
  verify(mockedList, times(2)).add("twice");
  verify(mockedList, times(3)).add("three times");

  //verification using never(). never() is an alias to times(0)
  verify(mockedList, never()).add("never happened");

  //verification using atLeast()/atMost()
  verify(mockedList, atLeastOnce()).add("three times");
  verify(mockedList, atLeast(2)).add("five times");
  verify(mockedList, atMost(5)).add("three times");
#+END_SRC

times(1) 是默认的，因此，使用的 times(1) 可以显示的省略


**** 处理异常

#+BEGIN_SRC java
  doThrow(new RuntimeException()).when(mockedList).clear();

  //following throws RuntimeException:
  mockedList.clear();

#+END_SRC


**** 确保不发生交互

#+BEGIN_SRC java
  //using mocks - only mockOne is interacted
  mockOne.add("one");

  //ordinary verification
  verify(mockOne).add("one");

  //verify that method was never called on a mock
  verify(mockOne, never()).add("two");

  //verify that other mocks were not interacted
  verifyZeroInteractions(mockTwo, mockThree);
#+END_SRC


**** 寻找多余交互

#+BEGIN_SRC java
  //using mocks
  mockedList.add("one");
  mockedList.add("two");

  verify(mockedList).add("one");

  //following verification will fail
  verifyNoMoreInteractions(mockedList);
#+END_SRC


**** 注解

***** 启用注解

#+BEGIN_SRC java
  @RunWith(MockitoJUnitRunner.class)
  public class MockitoAnnotationTest {

  }
#+END_SRC


***** @Mock

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseMockAnnotation_thenCorrect() {
      List mockList = Mockito.mock(ArrayList.class);

      mockList.add("one");
      Mockito.verify(mockList).add("one");
      assertEquals(0, mockList.size());

      Mockito.when(mockList.size()).thenReturn(100);
      assertEquals(100, mockList.size());
  }
#+END_SRC

使用注解：

#+BEGIN_SRC java
  @Mock
  List<String> mockedList;

  @Test
  public void whenUseMockAnnotation_thenMockIsInjected() {
      mockedList.add("one");
      Mockito.verify(mockedList).add("one");
      assertEquals(0, mockedList.size());

      Mockito.when(mockedList.size()).thenReturn(100);
      assertEquals(100, mockedList.size());
  }
#+END_SRC


***** @Spy

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseSpyAnnotation_thenCorrect() {
      List<String> spyList = Mockito.spy(new ArrayList<String>());

      spyList.add("one");
      spyList.add("two");

      Mockito.verify(spyList).add("one");
      Mockito.verify(spyList).add("two");

      assertEquals(2, spyList.size());

      Mockito.doReturn(100).when(spyList).size();
      assertEquals(100, spyList.size());
  }
#+END_SRC


使用注解：

#+BEGIN_SRC java
  @Spy
  List<String> spiedList = new ArrayList<String>();

  @Test
  public void whenUseSpyAnnotation_thenSpyIsInjected() {
      spiedList.add("one");
      spiedList.add("two");

      Mockito.verify(spiedList).add("one");
      Mockito.verify(spiedList).add("two");

      assertEquals(2, spiedList.size());

      Mockito.doReturn(100).when(spiedList).size();
      assertEquals(100, spiedList.size());
  }

#+END_SRC


***** @Captor

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseCaptorAnnotation_thenCorrect() {
      List mockList = Mockito.mock(List.class);
      ArgumentCaptor<String> arg = ArgumentCaptor.forClass(String.class);

      mockList.add("one");
      Mockito.verify(mockList).add(arg.capture());

      assertEquals("one", arg.getValue());
  }

#+END_SRC

使用注解：

#+BEGIN_SRC java
  @Mock
  List mockedList;

  @Captor
  ArgumentCaptor argCaptor;

  @Test
  public void whenUseCaptorAnnotation_thenTheSam() {
      mockedList.add("one");
      Mockito.verify(mockedList).add(argCaptor.capture());

      assertEquals("one", argCaptor.getValue());
  }

#+END_SRC


***** @InjectMocks

相当于同时使用 @Spy 和 @Mock

#+BEGIN_SRC java
  @Mock
  Map<String, String> wordMap;

  @InjectMocks
  MyDictionary dic = new MyDictionary();

  @Test
  public void whenUseInjectMocksAnnotation_thenCorrect() {
      Mockito.when(wordMap.get("aWord")).thenReturn("aMeaning");

      assertEquals("aMeaning", dic.getMeaning("aWord"));
  }

#+END_SRC

**** 传送门

[[https://www.baeldung.com/tag/mockito/][Baeldung Mockito]]
