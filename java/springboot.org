#+TITLE:     SpingBoot
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

* Spring MVC

** Handler

*** 使用 ServletAPI 作为入参

MVC 的 Handler 方法可以接受的 ServletAPI 类型的参数，具体可参考：

=org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver.resolveArgument/4=

常见的有：

- HttpServletRequest
- HttpServletResponse
- HttpSession
- Principal
- Locale
- InputStream
- OutputStream
- Reader
- Writer

** HiddenHttpMethodFilter

浏览器表单只支持 GET 与 POST 请求，而 DELETE，PUT 等方法并不支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 HTTP 方法，
使得支持 GET，POST，PUT 与 DELETE 请求。


























































* WEB

** 静态资源路径

- =classpath:/META-INF/resources/=
- =classpath:/resources/=
- =classpath:/static/=
- =classpath:/public/=
- 当前项目的根路径(=/=)


** Spring MVC 原理

#+HTML: <img src="http://www.51gjie.com/Images/image1/epnnzel2.4i4.jpg"/>
#+HTML: </br>
#+HTML: <img src="http://www.51gjie.com/Images/image1/srcc4b4l.hix.jpg"/>


- 用户发送请求到前端控制器(DispatcherServlet)，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制
- 前端控制器请求 HandlerMapping 查找 Handler ，返回 HandlerExecutionChain 对象（包含一个 Handler 对象，即 *Controller* ，和多个 HandlerInterceptor 拦截器）对象，
  通过这种策略模式，很容易添加新的映射策略（这个过程可以根据 xml 配置或注解进行查找）
- HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器
- 处理器适配器去执行 Handler ，将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个 ModelAndView 对象
- 处理器适配器向前端控制器返回ModelAndView，ModelAndView是springmvc框架的一个底层对象，包括 Model 和 View
- 前端控制器请求 ViewResolver 进行视图解析，即根据逻辑视图名解析成真正的视图
- View 会根据传进来的 Model 模型数据进行渲染
- 前端控制器向用户响应结果、

*** DispatcherServlet 原理

#+HTML: <img src="http://www.51gjie.com/Images/image1/0meux44p.4vz.jpg"/>


*** 重要组件

**** ContentNegotiatingViewResovler

#+HTML: <img src="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-all-flow.png"/>

- =ContentNegotiatingViewResolver= 组合所有视图解析器
- 可以自定义一个视图解析器， =ContentNegotiatingViewResolver= 自动将其整合进来

**** =HttpMessageConverters=

转换 HTTP 响应，如 User => JOSN

**** =ConfigurableWebBindingInitializer=

用于将请求的数据转换成 RequestBody


* 缓存

** JSR107

#+HTML: <img src="https://img-blog.csdn.net/20180826194453182?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bzYwOTYzMDE5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"/>

定义了 5 个核心接口:

1. CachingProvider

   创建，配置，获取，管理和控制 =CacheManager= ，一个应用运行期间可以访问多个 =CacheManager=
2. CacheManager

   创建，配置，获取，管理和控制 =Cache= ，一个 =CacheManager= 仅被一个 =CachingProvider= 拥有
3. Cache

   类似 =Map= 的数据结构，一个 Cache 仅被一个 =CacheManager= 拥有
4. Entry

   存储在 =Cache= 中的 k-v 对
5. Expiry

   =Cache= 中条目的有效期，可以通过 =ExpiryPolicy= 设置




** Springboot 缓存抽象

- Cache

缓存接口，定义缓存操作。实现有：RedisCache, EhCacheCache, ConcurrentMapCache 等
- CacheManager

缓存管理器
- @Cacheable

根据方法的请求参数对其结果进行缓存
- @CacheEvict

清空缓存
- @CachePut

更新缓存
- @EnableCaching

开启基于注解的缓存
- keyGenerator

key 生成策略
- serialize

value 序列化策略


** 示例代码

- [[https://github.com/ruanhao/java-for-fun/tree/master/src/test/java/com/hao/notes/caching][基本使用]]
- [[https://github.com/ruanhao/java-for-fun/tree/master/src/test/java/com/hao/notes/caching/redis][使用 Redis 作为 CacheManager]]


* 调度

** [[https://github.com/ruanhao/java-for-fun/tree/master/src/test/java/com/hao/notes/schedule][示例工程]]
** 每隔固定时间执行

     #+BEGIN_SRC java
       @Scheduled(fixedRate=5000)
     #+END_SRC

** 指定任务间隔

     #+BEGIN_SRC java
       // specify the interval between invocations measured
       // from the completion of the task
       @Scheduled(fixedDelay=5000)
     #+END_SRC

** UNIX Cron 风格

     #+BEGIN_SRC java
       @Scheduled(cron="0 28 11 ? * *")     // 每天 11 点 28 分 执行
       @Scheduled(cron="0 */5 14,18 * * ?") // 每天 14/18 点整，每隔 5 分钟执行
       @Scheduled(cron="0 15 10 ? * 1-6")   // 每个月周一至周六 10:15 执行
       @Scheduled(cron="0 0 2 ? * 6L")      // 每个月最后一个周六凌晨 2 点执行
       @Scheduled(cron="0 0 2 LW * ?")      // 每个月最后一个工作日凌晨 2 点执行
       @Scheduled(cron="0 0 2-4 ? * 1#1")   // 每个月第一个周一凌晨 2 点至 4 点期间，每隔整点执行

     #+END_SRC



* [[https://github.com/ruanhao/java-for-fun/tree/master/src/test/java/com/hao/notes/properties][配置]]

** [[https://github.com/lxy-go/SpringBoot/blob/master/SpringBoot%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B.md#8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE][自动配置原理]]


- SpringBoot 启动时加载自动配置类

  扫描所有 jar 包类路径下的 =MATA-INF/spring.factories= 文件（比如 =spring-boot-autoconfigure-1.5.15.RELEASE.jar/META-INF/spring.factories= ），
  文件中 =org.springframework.boot.autoconfigure.EnableAutoConfiguration= 对应的所有的自动配置类将进行自动配置。
- 自动配置类根据配置属性进行配置（创建 bean）

  所有在配置文件中能配置的属性在 =xxxProperties= 类中封装，比如 =@EnableConfigurationProperties(RedisProperties.class)=

*** 自动配置报告

启用 =debug=true= 属性，打印自动配合报告，这样就可以知道哪些自动配置类生效。

** @ConfigurationProperties 与 @Value 的区别

|                | @ConfigurationProperties | @Value   |
| 功能           | 批量注入配置文件属性     | 单个指定 |
| 松散绑定(语法) | ✓                        | ✗        |
| spEL           | ✗                        | ✓        |
| JSR303 校验    | ✓                        | ✗        |
| 复杂类型       | ✓                        | ✗        |


** [[https://github.com/ruanhao/java-for-fun/blob/master/src/test/java/com/hao/notes/properties/ExamplesWithDevProfile.java][Profile]]

*** 主配置文件激活
主配置文件: =application.properties=

#+BEGIN_SRC
  spring.profiles.active=<profile1>,<profile2>
#+END_SRC

*** 命令行激活

#+BEGIN_SRC sh
  java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=<profile>
#+END_SRC

*** 虚拟机参数激活

=-Dspring.profiles.active==







** 配置文件搜索顺序

1. =file:config=
2. =file:/=
3. =classpath:/config=
4. =classpath:/=

项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置: （指定配置文件和默认的配置文件会共同起作用）

#+BEGIN_SRC sh
  java -jar project-0.0.1-SNAPSHOT.jar --spring.config.location=/path/to/application.properties
#+END_SRC


** [[https://github.com/ruanhao/java-for-fun/blob/master/src/test/resources/test-properties-config/placeholder.properties][配置文件占位符]]

** =@Conditional= 派生注解

| @ConditionalOnJava              | 系统的java版本是否符合要求                      |
| @ConditionalOnBean              | 容器中存在指定Bean                              |
| @ConditionalOnMissBean          | 容器中不存在指定Bean                            |
| @ConditionalOnExpression        | 满足spEL表达式                                  |
| @ConditionalOnClass             | 系统中有指定的类                                |
| @ConditionalOnMissClass         | 系统中没有指定的类                              |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean,或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                  |
| @ConditionalOnResource          | 类路径下是否存在指定的资源文件                  |
| @ConditionalOnWebApplication    | 当前是web环境                                   |
| @ConditionalOnNotWebApplication | 当前不是web环境                                 |
| @ConditionalOnJndi              | JNDI存在指定项                                  |


* [[https://github.com/ruanhao/java-for-fun/tree/master/src/test/java/com/hao/notes/async][Async]]

** 异常统一捕获

如果需要统一进行异常捕获，可以实现 =AsyncConfigurer= 接口，
=getAsyncExecutor= 方法返回的 Executor 对象用于处理异步方法调用，
=getAsyncUncaughtExceptionHandler= 方法返回的对象捕获异步调用期间产生的异常，
*当且仅当异步调用方法的返回类型为 void* 。

#+BEGIN_SRC java
  @EnableAsync
  @Configuration
  public class AsyncConfiguration implements AsyncConfigurer {

      @Override
      public Executor getAsyncExecutor() {
          ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
          taskExecutor.setCorePoolSize(4);
          taskExecutor.setMaxPoolSize(8);
          taskExecutor.setQueueCapacity(32);
          taskExecutor.initialize();
          return taskExecutor;
      }

      @Override
      public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
          return new SimpleAsyncUncaughtExceptionHandler();
      }

  }
#+END_SRC





* 工具

** JacksonXML

*** 示例数据

#+BEGIN_SRC xml
  <root k6="6">
      <k1>str</k1>
      <k-2>2</k-2>
      <k3>
          <ki>1</ki>
          <ki>2</ki>
      </k3>
      <k5>5-1</k5>
      <k5>5-2</k5>
      <k9><![CDATA[中<a>文]]></k9>
  </root>
#+END_SRC


*** pom 配置

#+BEGIN_SRC xml
  <dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
  </dependency>
#+END_SRC


*** DTO

#+BEGIN_SRC java
  import java.util.*;
  import com.fasterxml.jackson.dataformat.xml.annotation.*;
  import lombok.Data;


  @Data
  @JacksonXmlRootElement(localName="root")
  public class RootXml {

      private String k1;

      @JacksonXmlProperty(localName="k-2")
      private Integer k2;

      @JacksonXmlProperty(localName="k3")
      @JacksonXmlElementWrapper(useWrapping=true)
      private Collection<String> kis;

      @JacksonXmlElementWrapper(useWrapping=false)
      private Collection<String> k5;

      @JacksonXmlProperty(isAttribute=true)
      private Integer k6;

      @JacksonXmlCData(value=true) // 序列化时是否总是使用 CDATA 块
      private String k9;
  }
#+END_SRC

*** Controller

#+BEGIN_SRC java
  @PostMapping(path="/xml", consumes=MediaType.APPLICATION_XML_VALUE)
  public void test(@RequestBody RootXml xml) {

  }
#+END_SRC




** MapStruct

*** pom 配置

**** properties

#+BEGIN_SRC xml
  <properties>
    <org.mapstruct.version>1.2.0.Final</org.mapstruct.version>
  </properties>
#+END_SRC

**** dependency

#+BEGIN_SRC xml
  <!-- 针对 swagger 的 workaround -->
  <dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <exclusions>
      <exclusion>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
      </exclusion>
    </exclusions>
  </dependency>

  <dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-jdk8</artifactId> <!-- use mapstruct-jdk8 for Java 8 or higher -->
    <version>${org.mapstruct.version}</version>
  </dependency>

  <dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>${org.mapstruct.version}</version>
    <scope>provided</scope>
  </dependency>
#+END_SRC

**** plugin

#+BEGIN_SRC xml
  <!-- 兼容 lombok -->
  <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
  </plugin>
#+END_SRC


*** Mapper 接口

#+BEGIN_SRC java
  @Mapper(unmappedTargetPolicy=ReportingPolicy.IGNORE)
  public interface ClassAMapper {

      ClassAMapper MAPPER = Mappers.getMapper( ClassAMapper.class );

      @Mappings({
              @Mapping(source="id", target="ID"),
              @Mapping(source="name", target="NAME")
      })
      ClassA from(ClassB obj);

      default ClassA from(ClassC obj) {
          // Custmization
      }
  }
#+END_SRC


*** 调用

#+BEGIN_SRC java
  ClassB objB = new ClassB();
  ClassC objC = new ClassC();
  ClassA.MAPPER.from(objB);
  ClassA.MAPPER.from(objC);
#+END_SRC


** MapperFactory

*** 配置

#+BEGIN_SRC xml
  <dependency>
    <groupId>ma.glasnost.orika</groupId>
    <artifactId>orika-core</artifactId>
    <version>1.5.2</version><!-- or latest version -->
  </dependency>
#+END_SRC


#+BEGIN_SRC java
  @Configuration
  public class MapperConfig extends ConfigurableMapper {

      @Bean
      public MapperFactory mapperFactory(){
          MapperFactory factory = new DefaultMapperFactory.Builder().build();
          factory.classMap(NetworkDto.class, Network.class)
              .field("group.id", "groupId")
              .mapNulls(false)
              .byDefault()
              .register();
          return factory;
      }
  }
#+END_SRC

*** 使用

#+BEGIN_SRC java
  class NetworkBo {

      @Autowired
      private MapperFactory mapperFactory;

      public void handle() {
          NetworkDto dto = ...;
          Network network = ...;
          mapperFactory.getMapperFacade().map(dto, network);
      }
  }

#+END_SRC


*** 传送门

- [[https://orika-mapper.github.io/orika-docs/advanced-mappings.html][高级映射配置]]


* 实践

** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-restful-service][Restful Service (MVC)]]

*** WebApplicationInitializer

实现 =WebApplicationInitializer= 接口便可以实现等同于对 =web.xml= 进行配置

*** Controller

#+BEGIN_SRC java
  @RestController
  @RequestMapping("/{userId}/bookmarks")
  class BookmarkRestController {

      @PostMapping
      ResponseEntity<?> add(@PathVariable String userId, @RequestBody Bookmark input) {
          return ResponseEntity.noContent().build();
      }
  }
#+END_SRC


*** HttpMessageConverter

对每个 HTTP 请求，Spring MVC 将遍历所有配置的 HttpMessageConverter 对象，
直到找到一个合适的对象可以将返回的 POJO 转换成 Accept header 中指定的 content type 。

Spring Boot 会自动组装一个可以转换成 JSON 类型的 HttpMessageConverter 对象。

HttpMessageConverter 工作于两个方向：
- 请求（ content-type => Java object ）
- 响应（ Java object => content-type ）


*** 异常处理

**** 异常级别

正常情况下，任何未被处理的异常将导致服务器返回 HTTP 500 Response 。
自定义的异常可以通过添加 =@ResponseStatus= 注解从而使用指定的 status code 。

#+BEGIN_SRC java
   @ResponseStatus(value=HttpStatus.NOT_FOUND, reason="No such Order")  // 404
   public class OrderNotFoundException extends RuntimeException {
       // TODO
   }
#+END_SRC

#+BEGIN_SRC java
  @RequestMapping(value="/orders/{id}", method=GET)
  public String showOrder(@PathVariable("id") long id, Model model) {
      Order order = orderRepository.findOrderById(id);

      if (order == null) throw new OrderNotFoundException(id);

      model.addAttribute(order);
      return "orderDetail";
  }
#+END_SRC



**** 控制器级别

使用 =@ExceptionHandler= 注解处理同一个控制器中抛出的异常，这种方式的优点：

- 可以处理没有被 =@ResponseStatus= 注解过的异常
- 可以将用户重定向到专门的错误页面
- 组装一个完全定制化的 error response

#+BEGIN_SRC java
  @Controller
  public class ExceptionHandlingController {

      // @RequestHandler methods that maybe throw exception
      ...


      // Exception handling methods:

      // Convert a predefined exception to an HTTP Status code
      @ResponseStatus(value=HttpStatus.CONFLICT, reason="Data integrity violation")  // 409
      @ExceptionHandler(DataIntegrityViolationException.class)
      public void conflict() {
          // TODO
      }

      // Specify name of a specific view that will be used to display the error:
      @ExceptionHandler({SQLException.class, DataAccessException.class})
      public String databaseError() {
          // Nothing to do.  Returns the logical view name of an error page, passed
          // to the view-resolver(s) in usual way.
          return "databaseError";
      }

      // Total control - setup a model and return the view name yourself. Or
      // consider subclassing ExceptionHandlerExceptionResolver.
      @ExceptionHandler(Exception.class)
      public ModelAndView handleError(HttpServletRequest req, Exception ex) {
          logger.error("Request: " + req.getRequestURL() + " raised " + ex);

          ModelAndView mav = new ModelAndView();
          mav.addObject("exception", ex);
          mav.addObject("url", req.getRequestURL());
          mav.setViewName("error");
          return mav;
      }
  }
#+END_SRC

**** 全局级别

任何标注 =@ControllerAdvice= / =@RestControllerAdvice= 注解的类支持 3 种类型的方法：

- Exception handling methods annotated with =@ExceptionHandler=
- Model enhancement methods (for adding additional data to the model) annotated with =@ModelAttribute=
- Binder initialization methods (used for configuring form-handling) annotated with =@InitBinder=


#+BEGIN_SRC java
  @ControllerAdvice
  class GlobalControllerExceptionHandler {
      @ResponseStatus(HttpStatus.CONFLICT)  // 409
      @ExceptionHandler(DataIntegrityViolationException.class)
      public void handleConflict() {
          // Nothing to do
      }
  }
#+END_SRC

***** 重新抛出

#+BEGIN_SRC java
  @ControllerAdvice
  class GlobalDefaultExceptionHandler {
    public static final String DEFAULT_ERROR_VIEW = "error";

    @ExceptionHandler(value = Exception.class)
    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
      // If the exception is annotated with @ResponseStatus rethrow it and let
      // the framework handle it - like the OrderNotFoundException example
      // at the start of this post.
      // AnnotationUtils is a Spring Framework utility class.
      if (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != null)
        throw e;

      // Otherwise setup and send the user to a default error-view.
      ModelAndView mav = new ModelAndView();
      mav.addObject("exception", e);
      mav.addObject("url", req.getRequestURL());
      mav.setViewName(DEFAULT_ERROR_VIEW);
      return mav;
    }
  }
#+END_SRC



** [[https://github.com/ruanhao/show-me-the-code/tree/springboot-application-event][Application Event]]

*** Event

    #+BEGIN_SRC java
  @ToString
  public class Event extends ApplicationEvent {

      private static final long serialVersionUID = 1L;

      @Getter
      private String message;

      public Event(Object source, String message) {
          super(source);
          this.message = message;
      }

  }
    #+END_SRC


*** Listener

    #+BEGIN_SRC java
  @Component
  @Slf4j
  public class Listener {

      @EventListener
      public void handlerEvent(Event event) {
          log.info("Receive event: {}", event);
      }

  }
    #+END_SRC


*** Publisher

    #+BEGIN_SRC java
  @Service
  @Slf4j
  public class Publisher {

      @Autowired
      private ApplicationContext applicationContext;

      public void publish(String message) {
          log.info("Sending message: {}", message);
          applicationContext.publishEvent(new Event(this, message));
      }

  }
    #+END_SRC


*** 自定义 applicationEventMulticaster

    #+BEGIN_SRC java
  @Bean(name="applicationEventMulticaster")
  public ApplicationEventMulticaster simpleApplicationEventMulticaster() {
      SimpleApplicationEventMulticaster eventMulticaster
          = new SimpleApplicationEventMulticaster();
      eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
      return eventMulticaster;
  }
    #+END_SRC


*** 常见 SpringApplicationEvent

- ApplicationEnvironmentPreparedEvent
- ApplicationFailedEvent
- ApplicationPreparedEvent
- ApplicationReadyEvent
- ApplicationStartingEvent





** Springboot Test

*** 样板文件

#+BEGIN_SRC java
  @RunWith(SpringRunner.class)
  @SpringBootTest(SpringBootTest.WebEnvironment.MOCK, classes=XxxApplication.class)
  @AutoConfigureMockMvc
  @ActiveProfiles("xxx")
  @TestPropertySource(locations="classpath:xxx.properties")
  public class ApplicationTest {

      @Test
      public void test() {
        // TODO
      }

  }

#+END_SRC



*** MockMvc

#+BEGIN_SRC java
  @Autowired
  private MockMvc mockMvc;

  @Test
  public void testHttpMethodWithPathVariable() throws Exception {
      mockMvc.perform(MockMvcRequestBuilders.get("/hello/{name}", "John"))
          .andDo(MockMvcResultHandlers.print()) // print request and response
          .andExpect(MockMvcResultMatchers.status().isOk())
          .andExpect(MockMvcResultMatchers.content().contentType("application/json;charset=UTF-8"))
          .andExpect(MockMvcResultMatchers.jsonPath("$.message").value("Hello World John!!!"));
  }

  @Test
  public void testHttpMethodWithQueryParameters() throws Exception {
      this.mockMvc.perform(get("/greetWithQueryVariable")
                           .param("name", "John Doe")
                           .param("age", "30"))
          .andDo(MockMvcResultHandlers.print())
          .andExpect(MockMvcResultMatchers.status().isOk())
          .andExpect(MockMvcResultMatchers.content().contentType("application/json;charset=UTF-8"))
          .andExpect(MockMvcResultMatchers.jsonPath("$.message").value("Hello World John Doe!!!"));
  }


#+END_SRC


*** Hamcrest

=import static org.hamcrest.Matchers.*;=

=import static org.junit.Assert.assertThat;=

**** Core API

- is
- not
- anyOf :: assertThat(str, anyOf(startsWith(start), containsString(end)))
- allOf :: assertThat(str, allOf(startsWith(start), containsString(end)))


**** Object Matcher

- hasToString(str) :: To assert that the `toString` method of an Object returns a specified `str`
- typeCompatibleWith(clazz) :: check that one class is a sub-class of another
- sameInstance
- instanceOf


**** Bean Matcher

- hasProperty
- samePropertyValuesAs


**** Collection Matcher

- empty
- hasSize
- arrayWithSize
- containsInAnyOrder
- contains :: in given order
- hasItemInArray
- isOneOf / isIn
- arrayContainingInAnyOrder
- arrayContaining
- hasKey
- hasValue
- hasEntry
- everyItem :: assertThat(list, everyItem(greaterThan(0)))

**** Number Matcher

- greaterThan
- greaterThanOrEqualTo
- lessThan
- lessThanOrEqualTo
- closeTo(pivot, deviation)


**** Text Matcher

- isEmptyString
- isEmptyOrNullString
- equalToIgnoringWhiteSpace
- stringContainsInOrder
- equalToIgnoringCase
- containsString(str)
- startsWith(str)
- endsWith(str)
- notNullValue


*** Mockito

Mock 测试就是在测试过程中，对于某些不容易构造（如 HttpServletRequest 必须在Servlet 容器中才能构造出来）
或者不容易获取比较复杂的对象（如 JDBC 中的ResultSet 对象），用一个虚拟的对象（Mock 对象）来创建以便测试的测试方法。

Mock 最大的功能是把单元测试的耦合分解开，如果代码对另一个类或者接口有依赖，它能够模拟这些依赖，并帮助验证所调用的依赖的行为。


**** Mock 与 Stub 的区别

Mock 不是 Stub，两者是有区别的：

- 前者被称为 mockist TDD，而后者一般称为 classic TDD
- 前者是基于行为的验证（behavior verification），后者是基于状态的验证 （state verification）
- 前者使用的是模拟的对象，而后者使用的是真实的对象



**** 验证行为

#+BEGIN_SRC java
  //Let's import Mockito statically so that the code looks clearer
  import static org.mockito.Mockito.*;

  //mock creation
  List mockedList = mock(List.class);

  //using mock object
  mockedList.add("one");
  mockedList.clear();

  //verification
  verify(mockedList).add("one");
  verify(mockedList).clear();
#+END_SRC

一旦创建 mock 将会 *记得所有的交互* 。可以选择验证感兴趣的任何交互。


**** 打桩

#+BEGIN_SRC java
  //You can mock concrete classes, not just interfaces
  LinkedList mockedList = mock(LinkedList.class);

  //stubbing
  when(mockedList.get(0)).thenReturn("first");
  when(mockedList.get(1)).thenThrow(new RuntimeException());

  //following prints "first"
  System.out.println(mockedList.get(0));

  //following throws runtime exception
  System.out.println(mockedList.get(1));

  //following prints "null" because get(999) was not stubbed
  System.out.println(mockedList.get(999));
#+END_SRC


**** 连续调用打桩对象

#+BEGIN_SRC java
  when(mock.someMethod("some arg"))
   .thenThrow(new RuntimeException())
   .thenReturn("foo");

  //First call: throws runtime exception:
  mock.someMethod("some arg");

  //Second call: prints "foo"
  System.out.println(mock.someMethod("some arg"));

  //Any consecutive call: prints "foo" as well (last stubbing wins).
  System.out.println(mock.someMethod("some arg"));

#+END_SRC

#+BEGIN_SRC java
  when(mock.someMethod("some arg"))
      .thenReturn("one", "two", "three");

#+END_SRC


**** 参数匹配器

#+BEGIN_SRC java
  //stubbing using built-in anyInt() argument matcher
  when(mockedList.get(anyInt())).thenReturn("element");

  //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
  when(mockedList.contains(argThat(isValid()))).thenReturn("element");

  //following prints "element"
  System.out.println(mockedList.get(999));

  //you can also verify using an argument matcher
  verify(mockedList).get(anyInt());
#+END_SRC

[[https://static.javadoc.io/org.mockito/mockito-core/2.21.0/org/mockito/Matchers.html][更多内置匹配器]]


**** 调用次数

#+BEGIN_SRC java
  //using mock
  mockedList.add("once");

  mockedList.add("twice");
  mockedList.add("twice");

  mockedList.add("three times");
  mockedList.add("three times");
  mockedList.add("three times");

  //following two verifications work exactly the same - times(1) is used by default
  verify(mockedList).add("once");
  verify(mockedList, times(1)).add("once");

  //exact number of invocations verification
  verify(mockedList, times(2)).add("twice");
  verify(mockedList, times(3)).add("three times");

  //verification using never(). never() is an alias to times(0)
  verify(mockedList, never()).add("never happened");

  //verification using atLeast()/atMost()
  verify(mockedList, atLeastOnce()).add("three times");
  verify(mockedList, atLeast(2)).add("five times");
  verify(mockedList, atMost(5)).add("three times");
#+END_SRC

times(1) 是默认的，因此，使用的 times(1) 可以显示的省略


**** 处理异常

#+BEGIN_SRC java
  doThrow(new RuntimeException()).when(mockedList).clear();

  //following throws RuntimeException:
  mockedList.clear();

#+END_SRC


**** 确保不发生交互

#+BEGIN_SRC java
  //using mocks - only mockOne is interacted
  mockOne.add("one");

  //ordinary verification
  verify(mockOne).add("one");

  //verify that method was never called on a mock
  verify(mockOne, never()).add("two");

  //verify that other mocks were not interacted
  verifyZeroInteractions(mockTwo, mockThree);
#+END_SRC


**** 寻找多余交互

#+BEGIN_SRC java
  //using mocks
  mockedList.add("one");
  mockedList.add("two");

  verify(mockedList).add("one");

  //following verification will fail
  verifyNoMoreInteractions(mockedList);
#+END_SRC


**** 注解

***** 启用注解

#+BEGIN_SRC java
  @RunWith(MockitoJUnitRunner.class)
  public class MockitoAnnotationTest {

  }
#+END_SRC


***** @Mock

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseMockAnnotation_thenCorrect() {
      List mockList = Mockito.mock(ArrayList.class);

      mockList.add("one");
      Mockito.verify(mockList).add("one");
      assertEquals(0, mockList.size());

      Mockito.when(mockList.size()).thenReturn(100);
      assertEquals(100, mockList.size());
  }
#+END_SRC

使用注解：

#+BEGIN_SRC java
  @Mock
  List<String> mockedList;

  @Test
  public void whenUseMockAnnotation_thenMockIsInjected() {
      mockedList.add("one");
      Mockito.verify(mockedList).add("one");
      assertEquals(0, mockedList.size());

      Mockito.when(mockedList.size()).thenReturn(100);
      assertEquals(100, mockedList.size());
  }
#+END_SRC


***** @Spy

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseSpyAnnotation_thenCorrect() {
      List<String> spyList = Mockito.spy(new ArrayList<String>());

      spyList.add("one");
      spyList.add("two");

      Mockito.verify(spyList).add("one");
      Mockito.verify(spyList).add("two");

      assertEquals(2, spyList.size());

      Mockito.doReturn(100).when(spyList).size();
      assertEquals(100, spyList.size());
  }
#+END_SRC


使用注解：

#+BEGIN_SRC java
  @Spy
  List<String> spiedList = new ArrayList<String>();

  @Test
  public void whenUseSpyAnnotation_thenSpyIsInjected() {
      spiedList.add("one");
      spiedList.add("two");

      Mockito.verify(spiedList).add("one");
      Mockito.verify(spiedList).add("two");

      assertEquals(2, spiedList.size());

      Mockito.doReturn(100).when(spiedList).size();
      assertEquals(100, spiedList.size());
  }

#+END_SRC


***** @Captor

不使用注解：

#+BEGIN_SRC java
  @Test
  public void whenNotUseCaptorAnnotation_thenCorrect() {
      List mockList = Mockito.mock(List.class);
      ArgumentCaptor<String> arg = ArgumentCaptor.forClass(String.class);

      mockList.add("one");
      Mockito.verify(mockList).add(arg.capture());

      assertEquals("one", arg.getValue());
  }

#+END_SRC

使用注解：

#+BEGIN_SRC java
  @Mock
  List mockedList;

  @Captor
  ArgumentCaptor argCaptor;

  @Test
  public void whenUseCaptorAnnotation_thenTheSam() {
      mockedList.add("one");
      Mockito.verify(mockedList).add(argCaptor.capture());

      assertEquals("one", argCaptor.getValue());
  }

#+END_SRC


***** @InjectMocks

相当于同时使用 @Spy 和 @Mock

#+BEGIN_SRC java
  @Mock
  Map<String, String> wordMap;

  @InjectMocks
  MyDictionary dic = new MyDictionary();

  @Test
  public void whenUseInjectMocksAnnotation_thenCorrect() {
      Mockito.when(wordMap.get("aWord")).thenReturn("aMeaning");

      assertEquals("aMeaning", dic.getMeaning("aWord"));
  }

#+END_SRC

**** 传送门

[[https://www.baeldung.com/tag/mockito/][Baeldung Mockito]]


* 参考

** [[https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties][所有可配置选项]]

** [[https://spring.io/blog/2013/06/03/content-negotiation-using-views][Content Negotiation Using Views]]