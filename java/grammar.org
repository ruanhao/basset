#+TITLE:     Grammar
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>


* Stream

** 基本原理

流的使用一般包括三件事:

- 一个数据源（如集合）来执行一个查询
- 一个中间操作链，形成一条流的流水线
- 一个终端操作，执行流水线，并能生成结果


** 示例代码

*** 筛选

**** 谓词筛选

#+BEGIN_SRC java
  List<Dish> vegetarianMenu = menu.stream()
      .filter(Dish::isVegetarian)
      .collect(toList());
#+END_SRC


**** 筛选各异

#+BEGIN_SRC java
  List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
  number.stream()
      .filter(i -> i % 2 == 0)
      .distinct()
      .forEach(System.out::println);
#+END_SRC


**** 截短

#+BEGIN_SRC java
  List<Dish> dishes = menu.stream()
      .filter(d -> d.getCalories() > 300)
      .limit(3)
      .collect(toList());
#+END_SRC

**** 跳过

#+BEGIN_SRC java
  List<Dish> dishes = menu.stream()
      .filter(d -> d.getCalories() > 300)
      .skip(2)
      .collect(toList());
#+END_SRC


*** 映射


**** 基本映射

#+BEGIN_SRC java
  List<String> dishNames = menu.stream()
      .map(Dish::getName)
      .collect(toList());
#+END_SRC

**** 扁平化流

#+BEGIN_SRC java
  List<String> uniqueCharacters =
      words.stream()
      .map(w -> w.split(""))
      .flatMap(Arrays::stream)    // Arrays.stream() 的方法可以接受一个数组并产生一个流
                                  // 将各个生成流扁平化为单个流
      .distinct()
      .collect(Collectors.toList());
#+END_SRC


*** 归约

此类查询需要将流中所有元素反复结合起来，得到一个值。这样的查询可以被归类为归约操作（将流归约成一个值）。

用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（流）反复折叠成一个小方块，而这就是折叠操作的结果。

**** 求和

#+BEGIN_SRC java
  // BinaryOperator<T> 用来将两个元素结合起来产生一个新值
  int sum = numbers.stream().reduce(0, (a, b) -> a + b);
  int sum = numbers.stream().reduce(0, Integer::sum);


  // reduce 还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象
  // 因为流中可能没有任何元素的情况，reduce 操作就无法返回其和，因为它没有初始值
  // 这就是为什么结果被包裹在一个 Optional 对象里，以表明和可能不存在
  Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
#+END_SRC

**** 计算最大值

#+BEGIN_SRC java
  Optional<Integer> max = numbers.stream().reduce(Integer::max);
#+END_SRC

**** 计算平均值

#+BEGIN_SRC java
  double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
#+END_SRC


*** 数值流

=IntStream= 中的 =map= 方法只能为流中的每个元素返回另一个 =int= ，
如果这不是你想要的，可以用 =IntStream= 的 =mapToObj= 方法改写它，这个方法会返回一个对象值流。

或者使用 =boxed= 方法先转换为 =Stream<Integer>= 。

#+BEGIN_SRC java
  IntStream evenNumbers = IntStream.range(1, 100);
  IntStream evenNumbers = IntStream.rangeClosed(1, 100);
#+END_SRC


*** 构造流

**** 由值创建流

#+BEGIN_SRC java
  Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
  Stream<String> emptyStream = Stream.empty();
#+END_SRC


**** 由数组创建流

#+BEGIN_SRC java
  int[] numbers = {2, 3, 5, 7, 11, 13};
  int sum = Arrays.stream(numbers).sum();
#+END_SRC

**** 由文件生成流

#+BEGIN_SRC java
  Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset());
#+END_SRC

**** 由函数生成流 （创建无限流）

Stream API 提供了两个静态方法来从函数生成流: =Stream.iterate= 和 =Stream.generate= ，这两个操作可以创建所谓的无限流，

由 =iterate= 和 =generate= 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。
一般来说，应该使用 =limit(n)= 来对这种流加以限制，以避免打印无穷多个值。

#+BEGIN_SRC java
  Stream.iterate(0, n -> n + 2)
      .limit(10)
      .forEach(System.out::println);

  Stream.generate(Math::random)
      .limit(5)
      .forEach(System.out::println);

  IntStream ones = IntStream.generate(() -> 1);

#+END_SRC















* Collection

** 基本原理

***  收集器

即 Collectors 类提供的工厂方法（例如 groupingBy )所创建的对象。主要提供三个功能:

- 将流元素归约和汇总为一个值
- 元素分组
- 元素分区



** 示例代码

#+BEGIN_SRC java
  import static java.util.Comparator.*;
  import static java.util.stream.Collectors.*;

  @AllArgsConstructor
  class Dish {

      @Getter private final String name;
      @Getter private final boolean vegetarian;
      @Getter private final int calories;
      @Getter private final Type type;

      public enum Type { MEAT, FISH, OTHER }

      public enum CaloricLevel { DIET, NORMAL, FAT }
  }


  public static List<Dish> menu =
      Arrays.asList(new Dish("pork", false, 800, Dish.Type.MEAT),
                    new Dish("beef", false, 700, Dish.Type.MEAT),
                    new Dish("chicken", false, 400, Dish.Type.MEAT),
                    new Dish("french fries", true, 530, Dish.Type.OTHER),
                    new Dish("rice", true, 350, Dish.Type.OTHER),
                    new Dish("season fruit", true, 120, Dish.Type.OTHER),
                    new Dish("pizza", true, 550, Dish.Type.OTHER),
                    new Dish("prawns", false, 300, Dish.Type.FISH),
                    new Dish("salmon", false, 450, Dish.Type.FISH));



  public static void getThreeHighCaloricDishNames() {
      menu.stream()
          .sorted(comparing(Dish::getCalories).reversed())
          .limit(3)
          .map(d -> d.getName())
          .forEach(System.out::println);
  }

  public static void getDistinctDishType() {
      menu.stream()
          .map(d -> d.getType())
          .distinct()
          .forEach(System.out::println);
  }

  public static void getAllCalories0() {
      int sum = menu.stream()
          .map(Dish::getCalories)
          .reduce(0, Integer::sum);
      System.out.println(sum);
  }

  public static void getAllCalories1() {
      int sum = menu.stream()
          .mapToInt(Dish::getCalories)
          .sum();
      System.out.println(sum);
  }

  public static void getMaxCalorie() {
      Optional<Integer> maxOp = menu.stream()
          .map(Dish::getCalories)
          .reduce(Integer::max);
      System.out.println(maxOp.orElse(0));
  }

  public static void getMaxCalorieDish() {
      Optional<Dish> maxOp = menu.stream()
          .collect(maxBy(comparingInt(Dish::getCalories)));
      maxOp.ifPresent(System.out::println);
  }

  public static void getTotalNumberOfDish() {
      long total = menu.stream()
          .collect(counting());
      System.out.println(total);
  }

  public static void getAllCalories2() {
      int sum = menu.stream()
          .collect(summingInt(Dish::getCalories));
      System.out.println(sum);
  }

  public static void getAverageCalorie() {
      double avg = menu.stream()
          .collect(averagingInt(Dish::getCalories));
      System.out.println(avg);
  }

  public static void getStatistics() {
      IntSummaryStatistics s = menu.stream()
          .collect(summarizingInt(Dish::getCalories));
      System.out.println(s);
  }

  public static void getShortMenu() {
      String j = menu.stream()
          .map(Dish::getName)
          .collect(joining(", "));
      System.out.println(j);
  }

  public static void groupByCaloricLevel() {
      Map<Dish.CaloricLevel, List<Dish>> dishesByCaloricLevel =
          menu.stream().collect( groupingBy(dish -> {
                      if (dish.getCalories() <= 400)
                          return Dish.CaloricLevel.DIET;
                      else if (dish.getCalories() <= 700)
                          return Dish.CaloricLevel.NORMAL;
                      else
                          return Dish.CaloricLevel.FAT;
                  } ));
      System.out.println(dishesByCaloricLevel);
  }

  public static void groupByDishesAndTypeCaloricLevel() {
      Map<Dish.Type, Map<Dish.CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
          menu.stream()
          .collect(groupingBy(Dish::getType,
                              groupingBy(dish -> {
                                      if (dish.getCalories() <= 400)
                                          return Dish.CaloricLevel.DIET;
                                      else if (dish.getCalories() <= 700)
                                          return Dish.CaloricLevel.NORMAL;
                                      else
                                          return Dish.CaloricLevel.FAT;
                                  }  )
                              )
                   );
      System.out.println(dishesByTypeCaloricLevel);
  }

  public static void getTotalNumberOfDishByType() {
      Map<Dish.Type,Long> typesCount =
          menu.stream()
          .collect(groupingBy(Dish::getType,
                              counting()));
      System.out.println(typesCount);
  }

  public static void getMostCaloricByType0() {
      Map<Dish.Type, Optional<Dish>> mostCaloricByType =
          menu.stream()
          .collect(groupingBy(Dish::getType,
                              maxBy(comparingInt(Dish::getCalories))));
      System.out.println(mostCaloricByType);
  }

  public static void getMostCaloricByType1() {
      Map<Dish.Type, Dish> mostCaloricByType =
          menu.stream()
          .collect(groupingBy(Dish::getType,
                              collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                                                Optional::get)
                              ));
      System.out.println(mostCaloricByType);
  }

  public static void getCaloricLevelsByType() {
      Map<Dish.Type, Set<Dish.CaloricLevel>> caloricLevelsByType =
          menu.stream().collect(groupingBy(Dish::getType,
                                           mapping( dish -> {
                                                   if (dish.getCalories() <= 400)
                                                       return Dish.CaloricLevel.DIET;
                                                   else if (dish.getCalories() <= 700)
                                                       return Dish.CaloricLevel.NORMAL;
                                                   else
                                                       return Dish.CaloricLevel.FAT;
                                               },
                                               toSet())));
      System.out.println(caloricLevelsByType);
  }

  public static void getCaloricLevelsByType1() {
      Map<Dish.Type, Set<Dish.CaloricLevel>> caloricLevelsByType =
          menu.stream().collect(groupingBy(Dish::getType,
                                           mapping( dish -> {
                                                   if (dish.getCalories() <= 400)
                                                       return Dish.CaloricLevel.DIET;
                                                   else if (dish.getCalories() <= 700)
                                                       return Dish.CaloricLevel.NORMAL;
                                                   else
                                                       return Dish.CaloricLevel.FAT;
                                               },
                                               toCollection(HashSet::new))));
      System.out.println(caloricLevelsByType);
  }

  public static void getTotalCaloriesByType() {
      Map<Dish.Type, Integer> totalCaloriesByType =
          menu.stream().collect(groupingBy(Dish::getType,
                                           summingInt(Dish::getCalories)));
      System.out.println(totalCaloriesByType);
  }

  public static void getVegetarianDishes() {
      Map<Boolean, List<Dish>> partitionedMenu =
          menu.stream().collect(partitioningBy(Dish::isVegetarian));
      System.out.println(partitionedMenu.get(true));
  }

  public static void getMostCaloricPartitionedByVegetarian() {
      Map<Boolean, String> mostCaloricPartitionedByVegetarian =
          menu.stream().collect(partitioningBy(Dish::isVegetarian,
                                               collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                                                                 op -> op.get().getName())));
      System.out.println(mostCaloricPartitionedByVegetarian);
  }




#+END_SRC


*** stream 操作

#+BEGIN_SRC java
  System.out.println("===== getThreeHighCaloricDishNames (sort) =====");
  getThreeHighCaloricDishNames();
  System.out.println("===== getDistinctDishType (distinct) =====");
  getDistinctDishType();
  System.out.println("===== getAllCalories (reduce) =====");
  getAllCalories0();
  System.out.println("===== getAllCalories (mapToInt) =====");
  getAllCalories1();
  System.out.println("===== getMaxCalorie (reduce) =====");
  getMaxCalorie();
#+END_SRC

#+BEGIN_EXAMPLE
===== getThreeHighCaloricDishNames (sort) =====
pork
beef
pizza
===== getDistinctDishType (distinct) =====
MEAT
OTHER
FISH
===== getAllCalories (reduce) =====
4200
===== getAllCalories (mapToInt) =====
4200
===== getMaxCalorie (reduce) =====
800
#+END_EXAMPLE


*** 聚合

#+BEGIN_SRC java
  System.out.println("===== getTotalNumberOfDish (counting) =====");
  getTotalNumberOfDish();
  System.out.println("===== getMaxCalorie (maxBy) =====");
  getMaxCalorieDish();
  System.out.println("===== getAllCalories (summingInt) =====");
  getAllCalories2();
  System.out.println("===== getAverageCalorie (averagingInt) =====");
  getAverageCalorie();
  System.out.println("===== getStatistics (summarizingInt) =====");
  getStatistics();
  System.out.println("===== getShortMenu (joining) =====");
  getShortMenu();
#+END_SRC

#+BEGIN_EXAMPLE
===== getTotalNumberOfDish (counting) =====
9
===== getMaxCalorie (maxBy) =====
com.cisco.ruan.nio.Dish@27bc2616
===== getAllCalories (summingInt) =====
4200
===== getAverageCalorie (averagingInt) =====
466.6666666666667
===== getStatistics (summarizingInt) =====
IntSummaryStatistics{count=9, sum=4200, min=120, average=466.666667, max=800}
===== getShortMenu (joining) =====
pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon
#+END_EXAMPLE


*** 分组

#+BEGIN_SRC java
  System.out.println("===== groupByCaloricLevel (groupingBy) =====");
  groupByCaloricLevel();
  System.out.println("===== groupByDishesAndTypeCaloricLevel (multi-level groupingBy) =====");
  groupByDishesAndTypeCaloricLevel();
  System.out.println("===== groupByDishesAndTypeCaloricLevel (counting on substream) =====");
  getTotalNumberOfDishByType();
  System.out.println("===== getMostCaloricByType (maxBy on substream) =====");
  getMostCaloricByType0();
  System.out.println("===== getMostCaloricByType (collectingAndThen) =====");
  getMostCaloricByType1();
  System.out.println("===== getTotalCaloriesByType (summingInt on substream) =====");
  getTotalCaloriesByType();
  System.out.println("===== getCaloricLevelsByType (mapping on substream and collect in set) =====");
  getCaloricLevelsByType();
  System.out.println("===== getCaloricLevelsByType (mapping on substream and collect in hashset) =====");
  getCaloricLevelsByType1();
#+END_SRC

#+BEGIN_EXAMPLE
===== groupByCaloricLevel (groupingBy) =====
{NORMAL=[com.cisco.ruan.nio.Dish@179d3b25, com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@5d099f62, com.cisco.ruan.nio.Dish@37f8bb67], DIET=[com.cisco.ruan.nio.Dish@49c2faae, com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0, com.cisco.ruan.nio.Dish@439f5b3d], FAT=[com.cisco.ruan.nio.Dish@27bc2616]}
===== groupByDishesAndTypeCaloricLevel (multi-level groupingBy) =====
{OTHER={NORMAL=[com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@5d099f62], DIET=[com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0]}, FISH={NORMAL=[com.cisco.ruan.nio.Dish@37f8bb67], DIET=[com.cisco.ruan.nio.Dish@439f5b3d]}, MEAT={NORMAL=[com.cisco.ruan.nio.Dish@179d3b25], DIET=[com.cisco.ruan.nio.Dish@49c2faae], FAT=[com.cisco.ruan.nio.Dish@27bc2616]}}
===== groupByDishesAndTypeCaloricLevel (counting on substream) =====
{OTHER=4, FISH=2, MEAT=3}
===== getMostCaloricByType (maxBy on substream) =====
{OTHER=Optional[com.cisco.ruan.nio.Dish@5d099f62], FISH=Optional[com.cisco.ruan.nio.Dish@37f8bb67], MEAT=Optional[com.cisco.ruan.nio.Dish@27bc2616]}
===== getMostCaloricByType (collectingAndThen) =====
{OTHER=com.cisco.ruan.nio.Dish@5d099f62, FISH=com.cisco.ruan.nio.Dish@37f8bb67, MEAT=com.cisco.ruan.nio.Dish@27bc2616}
===== getTotalCaloriesByType (summingInt on substream) =====
{OTHER=1550, FISH=750, MEAT=1900}
===== getCaloricLevelsByType (mapping on substream and collect in set) =====
{OTHER=[NORMAL, DIET], FISH=[NORMAL, DIET], MEAT=[NORMAL, DIET, FAT]}
===== getCaloricLevelsByType (mapping on substream and collect in hashset) =====
{OTHER=[NORMAL, DIET], FISH=[NORMAL, DIET], MEAT=[NORMAL, DIET, FAT]}
#+END_EXAMPLE

*** 分区

#+BEGIN_SRC java
  System.out.println("===== getVegetarianDishes (partitioningBy) =====");
  getVegetarianDishes();
  System.out.println("===== getMostCaloricPartitionedByVegetarian (multi-level partitioningBy) =====");
  getMostCaloricPartitionedByVegetarian();
#+END_SRC


#+BEGIN_EXAMPLE
===== getVegetarianDishes (partitioningBy) =====
[com.cisco.ruan.nio.Dish@254989ff, com.cisco.ruan.nio.Dish@20ad9418, com.cisco.ruan.nio.Dish@31cefde0, com.cisco.ruan.nio.Dish@5d099f62]
===== getMostCaloricPartitionedByVegetarian (multi-level partitioningBy) =====
{false=pork, true=pizza}
#+END_EXAMPLE




* Lambda

** 知识点

*** 谓词（Predicate）

返回 boolean 的函数


*** 函数式接口（Functional Interface）

只有一个 *抽象* 方法的接口，这种类型的接口也称为 SAM 接口，即 Single Abstract Method interfaces ，主要用在 Lambda 表达式

#+BEGIN_SRC java

@FunctionalInterface
interface MyService {

    void test(String s); // 一个抽象方法

    default void defaultWork() {
        // 函数式接口里可以包含默认方法
    }

    static void printHello(){
        // 函数式接口里可以包含静态方法
    }
}
#+END_SRC

*** 常见函数式接口

- Comparable (T, T) -> int

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Comparator<T> {
        int compare(T o1, T o2);
    }
  #+END_SRC

- Runnable () -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Runnable {
        public abstract void run();
    }
  #+END_SRC

- Callable () -> T
  #+BEGIN_SRC java
    public interface Callable<V> {
        V call() throws Exception;
    }
  #+END_SRC

- Predicate (T) -> boolean
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Predicate<T>{
        boolean test(T t);
    }
  #+END_SRC

- BiPredicate (T, U) -> boolean

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiPredicate<T, U> {
        boolean test(T t, U u);
    }
  #+END_SRC

- Consumer (T) -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Consumer<T>{
        void accept(T t);
    }
  #+END_SRC

- BiConsumer (T, U) -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiConsumer<T, U> {
        void accept(T t, U u);
    }
  #+END_SRC

- Function (T) -> R
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Function<T, R>{
        R apply(T t);
    }
  #+END_SRC

- UnaryOperator (T) -> T

  Function<T, T>

- BiFunction (T, U) -> R

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiFunction<T, U, R> {
        R apply(T t, U u);
    }
  #+END_SRC

- BinaryOperator (T, T) -> T

  BiBunction<T, T, T>

- Supplier () -> T
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Supplier<T> {
        T get();
    }
  #+END_SRC



*** 方法引用

| 方法引用                  | Lambda 表达式                           |
| ClassName::staticMethod   | (args) -> ClassName.staticMethod(args)  |
| ClassName::instanceMethod | (ins, args) -> ins.instanceMethod(args) |
| expr::instanceMethod      | (args) -> expr.instanceMethod(args)     |


*** 构造方法引用

对于一个现有构造函数，可以利用它的名称和关键字 new 来创建它的一个引用: ClassName::new \\
它的功能与指向静态方法的引用类似


*** 类型检查与推断

- Lambda 的类型是从使用 Lambda 的上下文推断出来的
- 同一个 Lambda 表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容
- Java 编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式


*** 特殊的 void 兼容规则

如果一个 Lambda 的主体是一个语句表达式，它就和一个返回 void 的函数描述符兼容。\\
例如，以下两行都是合法的，尽管 List 的 add 方法返回了一个 boolean ，而不是 Consumer 上下文 (T -> void) 所要求的 void :

#+BEGIN_SRC java
  Predicate<String> p = s -> list.add(s);

  Consumer<String> b = s -> list.add(s);
#+END_SRC


** 示例代码

*** 方法引用

#+BEGIN_SRC java
  str.sort((s1, s2) -> s1.compareToIgnoreCase(s2)); // =>
  str.sort(String::compareToIgnoreCase);

  Function<String, Integer> stringToInteger =
      (String s) -> Integer.parseInt(s); // =>
  Function<String, Integer> stringToInteger = Integer::parseInt;

  BiPredicate<List<String>, String> contains =
      (list, element) -> list.contains(element); // =>
  BiPredicate<List<String>, String> contains = List::contains;
#+END_SRC

*** 构造方法引用

#+BEGIN_SRC java
  Supplier<Apple> a = () -> new Apple(); // =>
  Supplier<Apple> a = Apple::new;

  Function<Integer,Apple> a = (weight) -> new Apple(weight); // =>
  Function<Integer,Apple> a = Apple::new;

  BiFunction<String, Integer, Apple> c3 =
      (color, weight) -> new Apple(color, weight); // =>
  BiFunction<String, Integer, Apple> c3 = Apple::new;
#+END_SRC

*** 排序

#+BEGIN_SRC java
  // Comparator 具有一个叫作 comparing 的静态辅助方法，
  // 它可以接受一个 Function 来提取 Comparable 键值，并生成一个 Comparator 对象
  import static java.util.Comparator.comparing;
  inventories.sort(comparing((a) -> a.getWeight()));
  inventories.sort(comparing(Apple::getWeight));

  inventories.sort(comparing(Apple::getWeight).reversed()); // 逆序

  inventories.sort(comparing(Apple::getWeight).thenComparing(Apple::getColour)); // 比较器链
#+END_SRC

*** 谓词复合 (negate, and, or)

and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。

=a.or(b).and(c)= 可以看作 =(a || b) && c=

#+BEGIN_SRC java
  Predicate<Apple> notRedApple = redApple.negate();

  Predicate<Apple> redAndHeavyApple =
      redApple.and(a -> a.getWeight() > 150);

  Predicate<Apple> redAndHeavyAppleOrGreen =
      redApple.and(a -> a.getWeight() > 150)
      .or(a -> "green".equals(a.getColor()));
#+END_SRC

*** 函数复合

#+BEGIN_SRC java
  // andThen: g(f(x))
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  Function<Integer, Integer> h = f.andThen(g);
  int result = h.apply(1); // 4

  // compose: f(g(x))
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  Function<Integer, Integer> h = f.compose(g);
  int result = h.apply(1); // 3
#+END_SRC



* Optional

** 基本原理

不推荐使用基础类型的 Optional ，因为基础类型的 Optional 不支持map，flatMap 以及 filter 方法，
而这些却是 Optional 类最有用的方法。


** 代码示例

*** 类三元操作符

以不解包的方式组合两个 Optional 对象，用一行语句实现条件判断的结构：

#+BEGIN_SRC java
  public Optional<Insurance> nullSafeFindCheapestInsurance(Optional<Person> person, Optional<Car> car) {
      return person.flatMap(p -> car.map(c -> findCheapestInsurance(p, c)));
  }
#+END_SRC


*** 避免在 Null 对象上调用 stream()

#+BEGIN_SRC java
  org.apache.commons.collections4.CollectionUtils.emptyIfNull(list)
      .stream()
      .filter(...);
#+END_SRC
