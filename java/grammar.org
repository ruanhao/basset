#+TITLE:     Grammar
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>


* [[https://github.com/ruanhao/java-for-fun/blob/master/src/main/java/com/hao/notes/stream/StreamExamples.java][Stream]]


流的使用一般包括三件事:

- 一个数据源（如集合）来执行一个查询
- 一个中间操作链，形成一条流的流水线
- 一个终端操作，执行流水线，并能生成结果


** 流的操作

*** filter

*** distinct

*** limit

*** skip

*** map

*** flatMap

*** reduce

此类查询需要将流中所有元素反复结合起来，得到一个值。这样的查询可以被归类为归约操作（将流归约成一个值）。

用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（流）反复折叠成一个小方块，而这就是折叠操作的结果。

**** 求和

#+BEGIN_SRC java
  // BinaryOperator<T> 用来将两个元素结合起来产生一个新值
  int sum = numbers.stream().reduce(0, (a, b) -> a + b);
  int sum = numbers.stream().reduce(0, Integer::sum);


  // reduce 还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象
  // 因为流中可能没有任何元素的情况，reduce 操作就无法返回其和，因为它没有初始值
  // 这就是为什么结果被包裹在一个 Optional 对象里，以表明和可能不存在
  Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
#+END_SRC

**** 最大值

#+BEGIN_SRC java
  Optional<Integer> max = numbers.stream().reduce(Integer::max);
#+END_SRC


**** 平均值

#+BEGIN_SRC java
  double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
#+END_SRC


*** 数值流

=IntStream= 中的 =map= 方法只能为流中的每个元素返回另一个 =int= ，
如果这不是你想要的，可以用 =IntStream= 的 =mapToObj= 方法改写它，这个方法会返回一个对象值流。

或者使用 =boxed= 方法先转换为 =Stream<Integer>= 。

#+BEGIN_SRC java
  IntStream evenNumbers = IntStream.range(1, 100);
  IntStream evenNumbers = IntStream.rangeClosed(1, 100);
#+END_SRC


*** 构造流

**** 由值创建流

#+BEGIN_SRC java
  Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
  Stream<String> emptyStream = Stream.empty();
#+END_SRC


**** 由数组创建流

#+BEGIN_SRC java
  int[] numbers = {2, 3, 5, 7, 11, 13};
  int sum = Arrays.stream(numbers).sum();
#+END_SRC


**** 由文件生成流

#+BEGIN_SRC java
  Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset());
#+END_SRC


**** 由函数生成流 （创建无限流）

Stream API 提供了两个静态方法来从函数生成流: =Stream.iterate= 和 =Stream.generate= ，这两个操作可以创建所谓的无限流，

由 =iterate= 和 =generate= 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。
一般来说，应该使用 =limit(n)= 来对这种流加以限制，以避免打印无穷多个值。

#+BEGIN_SRC java
  Stream.iterate(0, n -> n + 2)
      .limit(10)
      .forEach(System.out::println);

  Stream.generate(Math::random)
      .limit(5)
      .forEach(System.out::println);

  IntStream ones = IntStream.generate(() -> 1);

#+END_SRC















* [[https://github.com/ruanhao/java-for-fun/blob/master/src/main/java/com/hao/notes/stream/CollectionExamples.java][Collection]]

即 Collectors 类提供的工厂方法（例如 groupingBy )所创建的对象。主要提供三个功能:

- 将流元素归约和汇总为一个值
- 元素分组
- 元素分区


* Lambda

** 知识点

*** 谓词（Predicate）

返回 boolean 的函数


*** 函数式接口（Functional Interface）

只有一个 *抽象* 方法的接口，这种类型的接口也称为 SAM 接口，即 Single Abstract Method interfaces ，主要用在 Lambda 表达式

#+BEGIN_SRC java

@FunctionalInterface
interface MyService {

    void test(String s); // 一个抽象方法

    default void defaultWork() {
        // 函数式接口里可以包含默认方法
    }

    static void printHello(){
        // 函数式接口里可以包含静态方法
    }
}
#+END_SRC

*** 常见函数式接口

- Comparable (T, T) -> int

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Comparator<T> {
        int compare(T o1, T o2);
    }
  #+END_SRC

- Runnable () -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Runnable {
        public abstract void run();
    }
  #+END_SRC

- Callable () -> T
  #+BEGIN_SRC java
    public interface Callable<V> {
        V call() throws Exception;
    }
  #+END_SRC

- Predicate (T) -> boolean
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Predicate<T>{
        boolean test(T t);
    }
  #+END_SRC

- BiPredicate (T, U) -> boolean

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiPredicate<T, U> {
        boolean test(T t, U u);
    }
  #+END_SRC

- Consumer (T) -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Consumer<T>{
        void accept(T t);
    }
  #+END_SRC

- BiConsumer (T, U) -> void
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiConsumer<T, U> {
        void accept(T t, U u);
    }
  #+END_SRC

- Function (T) -> R
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Function<T, R>{
        R apply(T t);
    }
  #+END_SRC

- UnaryOperator (T) -> T

  Function<T, T>

- BiFunction (T, U) -> R

  #+BEGIN_SRC java
    @FunctionalInterface
    public interface BiFunction<T, U, R> {
        R apply(T t, U u);
    }
  #+END_SRC

- BinaryOperator (T, T) -> T

  BiBunction<T, T, T>

- Supplier () -> T
  #+BEGIN_SRC java
    @FunctionalInterface
    public interface Supplier<T> {
        T get();
    }
  #+END_SRC



*** 方法引用

| 方法引用                  | Lambda 表达式                           |
| ClassName::staticMethod   | (args) -> ClassName.staticMethod(args)  |
| ClassName::instanceMethod | (ins, args) -> ins.instanceMethod(args) |
| expr::instanceMethod      | (args) -> expr.instanceMethod(args)     |


*** 构造方法引用

对于一个现有构造函数，可以利用它的名称和关键字 new 来创建它的一个引用: ClassName::new \\
它的功能与指向静态方法的引用类似


*** 类型检查与推断

- Lambda 的类型是从使用 Lambda 的上下文推断出来的
- 同一个 Lambda 表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容
- Java 编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式


*** 特殊的 void 兼容规则

如果一个 Lambda 的主体是一个语句表达式，它就和一个返回 void 的函数描述符兼容。\\
例如，以下两行都是合法的，尽管 List 的 add 方法返回了一个 boolean ，而不是 Consumer 上下文 (T -> void) 所要求的 void :

#+BEGIN_SRC java
  Predicate<String> p = s -> list.add(s);

  Consumer<String> b = s -> list.add(s);
#+END_SRC


** 示例代码

*** 方法引用

#+BEGIN_SRC java
  str.sort((s1, s2) -> s1.compareToIgnoreCase(s2)); // =>
  str.sort(String::compareToIgnoreCase);

  Function<String, Integer> stringToInteger =
      (String s) -> Integer.parseInt(s); // =>
  Function<String, Integer> stringToInteger = Integer::parseInt;

  BiPredicate<List<String>, String> contains =
      (list, element) -> list.contains(element); // =>
  BiPredicate<List<String>, String> contains = List::contains;
#+END_SRC

*** 构造方法引用

#+BEGIN_SRC java
  Supplier<Apple> a = () -> new Apple(); // =>
  Supplier<Apple> a = Apple::new;

  Function<Integer,Apple> a = (weight) -> new Apple(weight); // =>
  Function<Integer,Apple> a = Apple::new;

  BiFunction<String, Integer, Apple> c3 =
      (color, weight) -> new Apple(color, weight); // =>
  BiFunction<String, Integer, Apple> c3 = Apple::new;
#+END_SRC

*** 排序

#+BEGIN_SRC java
  // Comparator 具有一个叫作 comparing 的静态辅助方法，
  // 它可以接受一个 Function 来提取 Comparable 键值，并生成一个 Comparator 对象
  import static java.util.Comparator.comparing;
  inventories.sort(comparing((a) -> a.getWeight()));
  inventories.sort(comparing(Apple::getWeight));

  inventories.sort(comparing(Apple::getWeight).reversed()); // 逆序

  inventories.sort(comparing(Apple::getWeight).thenComparing(Apple::getColour)); // 比较器链
#+END_SRC

*** 谓词复合 (negate, and, or)

and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。

=a.or(b).and(c)= 可以看作 =(a || b) && c=

#+BEGIN_SRC java
  Predicate<Apple> notRedApple = redApple.negate();

  Predicate<Apple> redAndHeavyApple =
      redApple.and(a -> a.getWeight() > 150);

  Predicate<Apple> redAndHeavyAppleOrGreen =
      redApple.and(a -> a.getWeight() > 150)
      .or(a -> "green".equals(a.getColor()));
#+END_SRC

*** 函数复合

#+BEGIN_SRC java
  // andThen: g(f(x))
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  Function<Integer, Integer> h = f.andThen(g);
  int result = h.apply(1); // 4

  // compose: f(g(x))
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  Function<Integer, Integer> h = f.compose(g);
  int result = h.apply(1); // 3
#+END_SRC



* Optional

** 基本原理

不推荐使用基础类型的 Optional ，因为基础类型的 Optional 不支持map，flatMap 以及 filter 方法，
而这些却是 Optional 类最有用的方法。


** 代码示例

*** 类三元操作符

以不解包的方式组合两个 Optional 对象，用一行语句实现条件判断的结构：

#+BEGIN_SRC java
  public Optional<Insurance> nullSafeFindCheapestInsurance(Optional<Person> person, Optional<Car> car) {
      return person.flatMap(p -> car.map(c -> findCheapestInsurance(p, c)));
  }
#+END_SRC


*** 避免在 Null 对象上调用 stream()

#+BEGIN_SRC java
  org.apache.commons.collections4.CollectionUtils.emptyIfNull(list)
      .stream()
      .filter(...);
#+END_SRC
