** Usage

*** Prototype

#+BEGIN_SRC java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.FIELD, Elementtype.METHOD})
  public @interface MyAnnotation {
      String name() default "";
  }
#+END_SRC

#+BEGIN_SRC java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface MyAnnotation {
      int[] digit() default {1,2,3};
  }
  // Can be used as @MyAnnotation(1), @MyAnnotation({1}), @MyAnnotation({1,2})
#+END_SRC

#+BEGIN_SRC java
  @Inherited
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface MyAnnotation {}
  /* Inherited : 在定义注解后并使用于程序代码上时，预设上父类别中的注解并不会被继承至子类别中，可以在定义注解时加上java.lang.annotation.Inherited 限定的Annotation，这让定义的Annotation型别被继承下来
     注意注解继承只针对class 级别注解有效
  */
#+END_SRC

**** ElementType.PACKAGE

此Target 只能用于package-info.java 文件中

package-info.java 文件作用:

+ 为标注在包上Annotation 提供便利

+ 声明默认访问权限的类和包常量

+ 描述和记录包信息


#+BEGIN_SRC java
  @PkgAnnotation
  package com.company;
  // 这里是包类，声明一个包使用的公共类，强调的是包访问权限
  class PkgClass{
      public void test(){}
  }
  // 包常量，只运行包内访问，适用于分“包”开发
  class PkgConst{
      static final String PACAKGE_CONST="ABC";
  }
#+END_SRC

#+BEGIN_SRC java
String pkgName = "com.company";
Package pkg = Package.getPackage(pkgName);
Annotation[] annotations = pkg.getAnnotations();
#+END_SRC


*** Howto

#+BEGIN_SRC java
  Method setter = beanProperty.getWriteMethod();
  if (setter.isAnnotationPresent(MyAnnotation.class)) {
      System.out.println(setter.getAnnotation(MyAnnotation.class).name());
  }
#+END_SRC

*** APIs

#+BEGIN_SRC java
MyClass.class.isAnnotationPresent(MyAnnotation.class);

MyAnnotation a = (MyAnnotation) MyClass.class.getAnnotation(MyAnnotation.class); // 得到加在 MyClass 上的注解实例
#+END_SRC
