** Install

*** Jars

http://www.springsource.org/download

- dist/spring.jar
- lib/jakarta-commons/commons-logging.jar
- lib/aspectj/aspectjweaver.jar, aspectjrt.jar, lib/cglib/cglib-nodep.jar (如果使用AOP)
- lib/j2ee/common-annotations.jar (如果使用了JSR-250中的注解，如@Resource/@PostConstruct/@PreDestroy)


** 实例化bean的方式

*** 使用类构造器实例化

#+BEGIN_SRC xml
  <bean id="myBean" class="com.hao.MyBean"/>
#+END_SRC

*** 使用静态工厂方法实例化

#+BEGIN_SRC xml
<bean id="myBean" class="com.hao.MyBeanFactory" factory-method="createBean"/>
#+END_SRC

#+BEGIN_SRC java
  public class MyBeanFactory {
      public static MyBean createBean() {
          return new MyBean();
      }
  }
#+END_SRC

*** 使用工厂方法实例化

#+BEGIN_SRC xml
  <bean id="myBeanFactory" class="com.hao.MyBeanFactory"/>
  <bean id="myBean" factory-bean="myBeanFactory" factory-method="createBean"/>
#+END_SRC

#+BEGIN_SRC java
  public class MyBeanFactory {
        public MyBean createBean() {
            return new MyBean();
        }
  }
#+END_SRC


** Bean作用域

*** singleton
*** prototype
<bean scope="prototype"/>
*** request
*** session
*** global session



** Bean初始化

*** 延迟初始化

<bean lazy-init="true"/>          ;; 针对单个bean进行延迟初始化

<beans default-lazy-init="true"/> ;; 针对所有bean


*** 指定初始化方法

<bean init-method="init"/>

#+BEGIN_SRC java
  public class ServiceBean implements Service {
      public void init() {
          System.out.println("init...");
      }
  }
#+END_SRC


** 注入依赖

*** 普通方式(setter方式)

#+BEGIN_SRC xml
  <bean id="personDao1" class="com.hao.dao.impl.PersonDaoBean"/>
  <bean id="personService" class="com.hao.service.impl.PersonServiceBean">
    <property name="personDao" ref="personDao1"/> <!-- name 是用来指定属性的 -->
  </bean>
#+END_SRC



*** 使用内部bean (该bean不能被其他bean使用)

#+BEGIN_SRC xml
  <bean id="orderService" class="com.hao.service.OrderServiceBean">
    <property name="orderDao">
      <bean class="com.hao.service.OrderDaoBean"/>
    </property>
  </bean>
#+END_SRC



*** 使用构造器进行注入

#+BEGIN_SRC xml
  <bean id="personDao1" class="com.hao.dao.impl.PersonDaoBean"/>
  <bean id="personService" class="com.hao.service.impl.PersonServiceBean">
    <constructor-arg index="0" type="com.hao.dao.PersonDao" ref="personDao1"/>
    <!-- type指的是参数类型，一般是抽象类型或接口类型 -->
    <!-- 还有value属性可以用来设置，value一般是设置基本类型数据，当设置基本类型时，type可以省略 -->
  </bean>

#+END_SRC



*** 为基本类型属性注入值(比如String)

#+BEGIN_SRC xml
  <property name="name" value="helloworld"/>
  <property name="age" value="30"/> <!-- 可以注入整型，这样定义属性：Integer age; -->
#+END_SRC



*** 注入集合

**** Set类型

#+BEGIN_SRC xml
  <bean id="hello" class="com.hao.Hello">
    <property naem="sets">
      <set>
        <value>1</value>
        <value>2</value>
        <value>3</value>
      </set>
    </property>
  </bean>
#+END_SRC

**** ArrayList类型

#+BEGIN_SRC xml
  <bean id="hello" class="com.hao.Hello">
      <property naem="list">
        <list>
          <value>1</value>
          <value>2</value>
          <value>3</value>
        </list>
      </property>
  </bean>
#+END_SRC

**** Properties类型

#+BEGIN_SRC xml
  <bean id="hello" class="com.hao.Hello">
        <property naem="property">
          <props>
            <prop key="key0">1</prop>
            <prop key="key1">2</prop>
            <prop key="key2">3</prop>
          </props>
        </property>
  </bean>
#+END_SRC

**** Map类型

#+BEGIN_SRC xml
  <bean id="hello" class="com.hao.Hello">
          <property naem="map">
            <map>
              <entry key="key-0" value="value-0"></entry>
              <entry key="key-1" value="value-1"></entry>
              <entry key="key-2" value="value-2"></entry>
            </map>
          </property>
  </bean>
#+END_SRC




*** 使用注解方式

在java代码中使用@Autowired或@Resource注解方式进行装配，需要在xml配置文件中配置一下信息：

#+BEGIN_SRC xml
  <beans xmlns="http://www.springframework.org/shema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context" <!-- 关键 -->
         xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframeworkorg/schema/context <!-- 关键 -->
    http://www.springframeworkorg/schema/context/spring-context-2.5.xsd"> <!-- 关键 -->
    <context:annotation-config/>  <!-- 关键 -->
  </beans>
#+END_SRC

这个配置隐式注册了多个对注解进行解析处理的处理器：AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, RequiredAnnotationBeanPostProcessor

@Autowired和@Resource两个注解的区别是：@Autowired默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean时才会按类型装配

**** @Autowired

按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果希望按名称装配，可以结合@Qualifier注解一起使用：

#+BEGIN_SRC java
@Autowired @Qualifier("personDaoBean")
private PersonDao personDao;
#+END_SRC

**** @Resource

默认按名称装配，名称可以通过name属性指定。如果没有指定name属性，当注解标注在字段上，默认取字段名称作为bean名称寻找依赖对象；当注解标注在setter方法上，默认取属性名作为bean名称寻找依赖对象：

#+BEGIN_SRC java
@Resource(name="personDaoBean")
private PersonDao personDao;
#+END_SRC

如果没有指定name属性，按默认名称找不到对象时，会回退到按类型装配；但是一旦指定name属性，就只能按名称装配了


*** 自动装配对象（不推荐）

<bean id="..." class="..." autowire="byType"/>

autowire属性取值如下:

- byType

  按类型装配，可以根据属性的类型，在容易中寻找跟该类型匹配的bean。如果发现多个，将会抛出异常。如果没有找到，则属性值为null。

- byName

  按名称装配，可以根据属性的名称，在容器中寻找跟该属性名相同的bean。如果没有找到，则属性值为null。

- contructor

  与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean，则抛出异常。

- autodetect

  通过bean类的自省机制来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。



*** 通过在classpath自动扫描方式把组件纳入Spring容器中管理

在类路径下寻找标注了@Component, @Service, @Controller, @Repository注解的类，并把这些类纳入Spring容器中管理。其作用和在xml文件中使用bean节点配置组件是一样的。
要使用自动扫描机制，我们需要打开以下配置信息:

#+BEGIN_SRC xml
<context:component-scan base-package="com.hao"/>
<!-- 有了这个配置,  <context:annotation-config/>可以省略，因为前者包含后者所有的注解处理器 -->
#+END_SRC

其中base-package为需要扫描的包（含子包）


- @Service

  用于标注业务层组件

  #+BEGIN_SRC java
@Service("beanName")
public class xxx {}

  #+END_SRC

#+BEGIN_SRC java
@Service("name") @Scope("prototype")
public class xxx {}
#+END_SRC

#+BEGIN_SRC java
  @Service("name")
  public class xxx {
      @PostContruct // 指定bean初始化函数
      public void init() {}
      @PreDestroy
      public void destroy() {}

  }
#+END_SRC

- @Controller

  用于标注控制层组件

- @Repository

  用于标注数据访问组件，即DAO组件

- @Component

  泛指组件，当组件不好归类时，可以使用这个注解进行标注


** AOP

*** 概念

**** Aspect（切面）

横切性关注点的抽象即为切面

**** joinpoint（连接点）

所谓连接点是指那些被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点，广义上joinpoint还可以是field或类构造器

**** Pointcut（切入点）

指对那些jointpoint进行拦截的定义

**** Advice（通知）

指拦截到jointpoint后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知

**** Target（目标对象）

代理的目标对象

**** Weave（织入）

指将aspects应用到target对象并导致proxy对象创建的过程称为织入

**** Ifntroduction（引入）

再不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field


*** 各类通知的位置参考

参考 reflect.org


*** 使用注解方式声明切面

#+BEGIN_EXAMPLE
\*   com.hao.service. .  *  . *   (..)
-1-  --------2-------   -3-  -4-  -5-
1: 返回类型，*表示任意，如需要明确指明，则要给出类的全称，如java.lang.String
2: 表示对哪些包下的类进行拦截，最后一个点表示包括子包
3: 表示所有类
4: 表示所有方法
5: 表示参数可任意

#+END_EXAMPLE

#+BEGIN_SRC xml
<aop:aspectj-autoproxy/>
#+END_SRC

#+BEGIN_SRC java
  @Aspect @Component
  public class MyInterceptor {
      @Pointcut("execution(* com.hao.service..*.*(..))")
      private void anyMethod() {} // 声明一个切入点（为这个切入点定义名称，叫anyMethod）

      @Before ("anyMethod() && args(userName)") // 表示：使用名为anyMethod()的切入点，同时在原切入点表达式的基础上，再加入额外限制：只有一个参数，且参数类型为String
      public void doCheck(String userName) {
          System.out.println("beforeCheck");
      }


      @AfterReturning(pointcut="anyMethod()", returning="revalue") // 定义后置通知，且可以获得切入点的返回结果
      public void doReturnCheck(String revalue) {

      }


      @AfterThrowing(pointcut="anyMethod()", throwing="ex") // 定义例外通知
      public void doExceptionAction(Exception ex) {

      }

      @After("anyMethod()") // 定义最终通知
      public void doReleaseAction() {

      }

      @Around("anyMethod()") // 环绕通知
      public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
          return pjp.proceed();
      }
  }
#+END_SRC

*** 使用XML方式声明切面

#+BEGIN_SRC xml
  <bean id="log" class="com.hao.LogPrint"/>
  <aop:config>
    <aop:aspect id="myaop" ref="log">
      <aop:pointcut id="mycut" expression="execution(* com.hao..*.*(..))"/>
      <aop:before pointcut-ref="mycut" method="doAccessCheck"/>
      <aop:after-returning pointcut-ref="mycut" method="doReturnCheck"/>
      <aop:after-throwing pointcut-ref="mycut" method="doExcepitonAction"/>
      <aop:after pointcut-ref="mycut" method="doReleaseAction"/>
      <aop:around pointcut-ref="mycut" method="doBasicProfiling"/>
    </aop:aspect>
  </aop:config>
#+END_SRC


** JDBC

*** 配置数据源

#+BEGIN_SRC xml
  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="org.gjt.mm.mysql.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=UTF-8"/>
    <property name="username" value="root"/>
    <property name="password" value="123456"/>
  </bean>
#+END_SRC

也可以使用配置文件结合属性占位符:

#+BEGIN_SRC xml
<context:property-placeholder location="jdbc.properties"/>
#+END_SRC


*** 配置事务

**** XML方式

#+BEGIN_SRC xml
  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
  </bean>

  <aop:config>
    <aop:pointcut id="transactionPointcut" expression="execution(* com.hao.servie..*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="transactionPointcut"/>
  </aop:config>

  <tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
      <tx:method name="get*" read-only="true" propagation="NOT_SUPPORTED"/>
      <tx:method name="*"/>
    </tx:attributes>
  </tx:advice>
#+END_SRC


**** 注解方式

#+BEGIN_SRC xml
  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
  </bean>

  <tx:annotation-driver transaction-manager="txManager"/>
#+END_SRC

#+BEGIN_SRC java
@Service @Transactional
public class PersonServiceBean implement PersonService { }
#+END_SRC


*** 事务

如果抛出RuntimeException，则Spring默认将会回滚事务，RuntimeException称为unchecked例外

#+BEGIN_SRC java
public void delete(Integer id) {
    throw new RuntimeException("wrong");
}

// 如果想改变这种默认行为，希望不回滚，则需改为：
@Transactional(noRollbackFor=RuntimeException.class)
public void delete(Integer id) {
    throw new RuntimeException("wrong");
}
#+END_SRC

如果抛出checked例外，则Spring默认不会自动回滚事务，如：

#+BEGIN_SRC java
public void delete(Integer id) throws Exception {
    throw new Exception("wrong");
}

// 如果想改变这种默认行为，希望支持回滚，则需改为：
@Transactional(rollbackFor=Exception.class)
public void delete(Integer id) throws Exception {
    throw new Exception("wrong");
}
#+END_SRC

取消对事务的支持：

#+BEGIN_SRC java
@Transactional(propagation=Propagation.NOT_SUPPORTED)
public Person getPerson(Integer id) {}

/*
Propagation.REQUIRED: 业务方法需要在一个事务中运行，如果该方法运行时，已经处在一个事务中，那么加入到该事务，否则为自己创建一个新的事务 (这是Spring的默认值)
Propagation.NOT_SUPPORTED: 声明方法不需要事务，如果方法没有关联到一个事务，容器不会为它开启事务。如果方法在一个事务中被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行
Propagation.REQUIRENEW: 表明不管是否存在事务，业务方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法执行结束，新事物才算结束，原先的事务才会恢复执行
Propagation.MANDATORY: 该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果业务方法在没有事务的环境下调用，容器就会抛出例外
Propagation.SUPPORTS: 如果业务方法在某个事务范围内被调用，则方法称为该事务的一部分。如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行
Propagation.Never: 指定业务方法绝对不能再事务范围内后执行。如果业务方法在某个事务中执行，容器会抛出例外，只用业务方法没有关联到任何事务，才能正常执行
Propagation.NESTED: 如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按REQUIRED属性执行，它使用一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
*/
#+END_SRC
