#+TITLE:     top
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall


* 1，基本知识

=top= 用到的数据来自于 =/proc/[pid]/statm=

[[file:images/top.png]]


** 1.1，CPU 性能指标

*** 1.1.1, us

表示 CPU 有多少时间在运行用户态代码

*** 1.1.2, sy

表示 CPU 有多少时间在运行内核态代码。\\
%sy 高说明内核占用太多资源，或者用户进程发起了太多的系统调用。

*** 1.1.3, ni

表示 CPU 有多少时间在运行 niceness 不为 0 的进程代码。

默认情况下，进程的 niceness 值都为0，但可以通过命令 nice 来启动一个进程并指定其 niceness 值，\\
niceness 的取值范围是 -20 到 19 ，值越小，表示优先级越高，越优先被内核调度。

*** 1.1.4, id

表示 CPU 有多少时间处于空闲状态。

*** 1.1.5, wa

表示 CPU 有多少时间处于 I/O 等待状态。

通常情况下，当 CPU 遇到一个 I/O 操作时，会先触发 I/O 操作，然后去干别的，等 I/O 操作完成后，CPU 再接着继续工作，
但如果这时系统比较空闲，CPU 没有别的事情可以做，那么 CPU 将处于等待状态，这种处于等待状态的时间将会被统计进 I/O wait ，
也就是说 CPU 处于 I/O wait 状态即 CPU 闲着没事干在等 I/O 操作结束，和 idle 几乎是一样的。

这个值高说明 CPU 闲且 I/O 操作多或者 I/O 操作慢，但低并不能说明没有 I/O 操作或者 I/O 操作快，有可能是 CPU 在忙别的，所以这只是一个参考值，需要和其他的统计项一起来分析。

*** 1.1.6, hi & si

这两个值反映了 CPU 有多少时间花在了中断处理上，hi (hardware interrupts) 是硬件中断，si (softirqs) 是软件中断。

硬件中断一般由 I/O 设备引起，如网卡、磁盘等，发生硬件中断后，CPU 需要立即处理，当硬件中断中需要处理的事情很多时，内核会生成相应的软中断，
然后将耗时且不需要立即处理完成的操作放在软中断中执行，比如当网卡收到网络包时，需要 CPU 立即把数据拷贝到内存中去，
因为网卡自带的缓存较小，如果不及时处理的话后面的数据包就进不来，导致丢包，
当数据拷贝到内存中之后，就不需要那么着急的处理了，这时候可以将处理数据包（协议栈）的代码放在软中断中执行。

*** 1.1.7, st

%st 和虚拟机有关，当系统运行在虚拟机中时，当前虚拟机就会和宿主机以及其它的虚拟机共享CPU，%st 就表示当前虚拟机在等待 CPU 为它服务的时间。

该值越大，表示物理 CPU 被宿主机和其它虚拟机占用的时间越长，导致当前虚拟机得不到充足的 CPU 资源。
如果 %st 长时间大于0，说明 CPU 资源得不到满足，这时可以考虑将虚拟机移到其它机器上，或者减少当前机器运行的虚拟机数量。


** 1.2, 内存性能指标

*** 1.2.1, SHR

SHR 是指加载外部动态库 (.so) 或者以共享内存方式进行进程间通信时所使用的共享内存区域。\\
这部分物理内存空间其实是被多个进程所共享的，所以称为共享内存。

某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。\\
所以要计算进程独占内存的大小只要用 RES 的值减去 SHR 值即可。

*** 1.2.2, VIRT

进程所使用的虚拟内存大小。

VIRT 的参考意义不大，它只能反应出程序的大小。

*** 1.2.3, RES

系统为虚拟内存分配的物理内存大小，RES 不能完全的代表一个进程真正占用的内存空间，因为它里面还包含了 SHR 的部分。

top 命令输出中的 RES 和 pmap 输出中的 RSS 是一个东西。

*** 1.2.4, MEM

等于 =RES/total*100%= ，这里 total 指总的物理内存大小。

#+BEGIN_EXAMPLE
由于 SHR 可能会被多个进程所共享，所以系统中所有进程的 RES 加起来可能会超过总的物理内存数量，
由于同样的原因，所有进程的 %MEM 总和可能超过 100% 。
#+END_EXAMPLE

*** 1.2.5, 可用内存

=free + (buffers + cached)=

*** 1.2.6, 已用内存

=used - (buffers + cached)=

* 2，常用选项

- 以 CPU 排序

  P

- 以内存排序

  M

- 显示 SMP 负载情况

  1

- 显示线程信息

  H

- 高亮模式

  z

- 显示完整命令名

  c

- kill 指定进程

  k

- 指定排序栏高亮

  x

- 指定排序栏

  <, >

- 显示指定进程

  =top -p=

- 显示一屏信息

  =top -bn 1=

- 使用 megabytes 为单位

  =top -M=

- 监控指定进程和进行内线程信息

  =top -H -p=


* 3, 问题处理


** 3.1, CPU 问题处理

*** 3.1.1, us 过高

表示有用户态进程占用了过多的 CPU ，通过 top 命令可以很清楚的看到是哪个进程，如果这不是预期的行为，可以通过 kill 命令杀死相应的进程或者重启它。

*** 3.1.2, sy 过高

如果只是偶尔过高的话，不用担心，但如果是持续走高的话，就需要重视，有可能是某些进程的系统调用太频繁，\\
比如进程不停的往控制台输出日志，但如果用户态的进程都没有问题，那可能是内核里面的代码出现了问题，尤其是代码写的不好的驱动模块。

*** 3.1.3, ni 过高

说明有人用 nice 程序运行了比较耗 CPU 的进程。

如果 niceness 值大于 0 的话，就没什么好担心的，因为它的优先级比默认优先级要低，不会影响 CPU 性能，但最好还是确认一下该进程不会抢占系统的其它资源，如内存、磁盘 I/O 等，避免对系统整体性能造成影响。\\
如果 niceness 值小于 0 的话，表示该进程优先级高且占用 CPU 资源多，需要确保该进程占用的 CPU 资源是符合预期的，如果不是，可以用 top 命令把它找出来并 kill 掉或者重启。

*** 3.1.4, wa 过高

意味着系统中有进程在做大量的 I/O 操作，或者在读写速度比较慢的 I/O 设备，比如频繁的读写磁盘，这时可以通过 =iotop= 命令来查看是哪些进程占 I/O ，然后再针对不同的进程做相应的处理。

还有一种情况就是系统在频繁的使用交换分区，这时需要解决的就是内存的问题，而不是 I/O 的问题。

*** 3.1.5, hi 或者 si 过高

hi 过高一般是硬件出问题了，si 过高一般是内核里面的代码出问题了。

*** 3.1.6, st 过高

表示当前虚拟机得不到足够的 CPU 资源。

这时可以考虑将当前虚拟机搬迁到其它的主机上，或者想办法降低当前主机的负载，比如关掉一些其它的虚拟机。


** 3.2, 内存问题处理

*** 3.2.1, free 的值较小，并且 buffers/cache 的值也小

free 的值比较少并不一定代表有问题，因为 Linux 会尽可能多的将内存用于 page cache ，\\
但是如果 buffers/cache 的值也小，就说明内存吃紧了，系统没有足够多的内存用于 cache，

如果当前服务器部署是一个需要频繁的读写磁盘的应用，如 FTP 服务器，那么对性能的影响将会非常大。

*** 3.2.2, swap used 的值较大

正常情况下 swap 应该很少被使用，used 值比较大说明交换空间被使用的比较多，\\
如果通过 vmstat 命令看到 swap in/out 的比较频繁的话，说明系统内存严重不足，整体性能已经受到严重影响。
