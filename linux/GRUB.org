#+TITLE:     GRUB
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 1, 基本原理

** 1.1, Linux 启动过程

#+BEGIN_EXAMPLE
  1, BIOS POST 完成后，加载硬盘 MBR 中的 GRUB 代码，启动过程就被 GRUB 接管

  2, GRUB 会加载 /boot/grub 下的驱动到内存中

  3, GRUB 加载内核和 initrd image ，并启动内核
     GRUB 知道内核是位于哪个分区内
     GRUB 也需要有文件系统驱动，因为需要读取文件，所以驱动很小
     GRUB 已经支持所有的常见文件系统

  4, 内核接管整个系统后，加载 /sbin/init 并创建第一个用户态的进程

  5, init 进程开始调用一系列的脚本来创建很多子进程，这些子进程负责初始化整个系统
#+END_EXAMPLE


** 1.2, BIOS VS UEFI

BIOS 和 UEFI 两者启动系统的方式不一样，BIOS 是读取硬盘第一个扇区的 MBR 到内存中，然后将控制权交给 MBR 里的 Bootloader 。

而 UEFI 是读取 EFI 分区，如果 EFI 分区存在且里面有启动程序的话，将控制权交给启动程序，否则和 BIOS 一样，\\
读取硬盘第一个扇区的 MBR 到内存中，将控制权交给 MBR 里面的 Bootloader 。从这里可以看出：

- UEFI 是兼容 BIOS 的，就是说就算主板支持 UEFI ，只要我们不用 EFI 分区，主板还是按照原来 BIOS 的方式来启动系统
- 两者只能选其一，使用 EFI 分区里面的启动程序，或者是 MBR 里面的 Bootloader


** 1.3, MBR VS GPT

*** 1.3.1, MBR

#+BEGIN_EXAMPLE
  ------------------------------------------------------------------
  |   |         |         |        |-------------------------------|
  |MBR| 主分区1 | 主分区2 | 主分区3| 扩展 |逻辑分区1|...|逻辑分区n |
  |   |         |         |        |-------------------------------|
  ------------------------------------------------------------------
                                          ↓
  扩展分区是一个特殊的主分区，分区最前面包含所有逻辑分区的描述，包含大小，位置等
#+END_EXAMPLE

- 由于留给 MBR 的空间太小，所以 MBR 格式的硬盘只能支持四个分区，就是常说的四个主分区。如果想把磁盘分成大于 4 个分区，就需要将其中的一个或者多个分区设置成扩展分区，然后在扩展分区里面划分逻辑分区

- 对 Linux 而言，可以安装在主分区和逻辑分区里面，所以怎么划分硬盘都没关系。但对于 Windows 而言，由于只支持安装在主分区里面，所以必须至少有一个主分区，如果安装 Linux 时不小心将磁盘全部划分成逻辑分区，则以后要安装 Windows 就比较麻烦，需要重新划分磁盘分区格式

- 由于留给 MBR 的空间太小，它所能表述的磁盘空间有限，只能支持小于 2T 的硬盘


*** 1.3.2, GPT

GPT 主要用来替换 MBR ，并且配合 UEFI 使用。\\
在 Windows 和 OS X 上，只支持通过 UEFI 方式启动 GPT 硬盘，而 FreeBSD ，Linux 依然支持 BIOS 模式启动 GPT 硬盘。

GPT 的主要优点：

- 支持几乎无限制的磁盘分区个数，再也不需要主分区、扩展分区和逻辑分区这些概念了
- 支持超过 2T 的硬盘
- 分区数据在磁盘的不同位置存有多份，且有 CRC 校验码，所以更安全



** 1.4, initrd image

我们都知道 Linux 内核模块的概念，比方说 Linux 支持 N 种不同的文件系统，Ext2/3/4，XFS, Btrfs 等等，那需要把所有的这些文件系统驱动都编译进内核吗？当然不需要，因为这样做会导致内核太大，运行时占用太多的内存，取而代之，我们会把这些驱动编译成一个一个的内核模块，在需要用到的时候再把它们加载进内核，其它时间存放在磁盘上就好了。

现在有个问题，在 GRUB 将控制权交给 Linux 内核后，内核需要启动 init 程序，这个 init 程序是放在某个磁盘分区上的，这个磁盘分区用的是 N 个文件系统中的某一个，内核到哪里找这个文件系统的驱动呢？这个时候 initrd image 出场了，它里面包含了很多驱动模块，并且用的是内存文件系统，内存文件系统的驱动已经编译到内核中了，所以内核是可以直接访问 initrd image 的。当然 initrd image 里面不仅仅只包含文件系统的驱动，还有其它的很多文件。

** 1.5, init 进程

init 是用户态的第一个进程，所以非常重要，各个 Linux 发行版都用这个进程来创建很多子进程，然后让这些子进程来初始化用户态的环境，如 mount 各个分区，启动各个服务等，现在各个发行版主要采用这三种框架中的一种 sysvinit ，upstart ，systemd 。

sysvinit 出现最早，简单易用，但缺点是速度慢，比如有 10 个服务需要在开机时启动，那么 sysvinit 只能一个接一个的启动它们，即使他们之间没有任何关系，也不能并行的启动。

于是出现了 upstart ，upstart 基于事件驱动，可以让没有关系的服务并行的启动，这样可以加快开机速度。

但是人们觉得还是不够快，于是出现了 systemd ，它可以通过一定的技术和技巧让有关系的服务也能并发的启动，当然导致的结果是 systemd 比较复杂。

* 2, GRUB 配置示例

- =kernel /boot/vmlinuz-2.6.9-1.667 ro root=/dev/hda5 quiet=

  当 GRUB 加载完内核（/boot/vmlinuz-2.6.9-1.667）后，将这里的 =ro root=/dev/hda5 quiet做为参数传给内核，然后将控制权交给内核