#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall




** TIME_WATI

**** 什么是TIME_WAIT

因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。

#+CAPTION: TCP Close Process
#+LABEL: fig:SED-HR40
[[./pic/tcp_close.png][TCP Close]]

MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。关于MSL的大小，RFC 793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，并且这个数值是硬编码在内核中的，也就是说除非你重新编译内核，否则没法修改它：

#+BEGIN_SRC c
#define TCP_TIMEWAIT_LEN (60*HZ)
#+END_SRC

**** 为什么会存在TIME_WAIT

为什么主动关闭的一方不直接进入CLOSED状态，而是进入TIME_WAIT状态，并且停留两倍的MSL时长呢？这是因为TCP是建立在不可靠网络上的可靠的协议。

例子：主动关闭的一方收到被动关闭的一方发出的FIN包后，回应ACK包，同时进入TIME_WAIT状态，但是因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：

- 旧的TCP连接已经不存在了，系统此时只能返回RST包
- 新的TCP连接被建立起来了，延迟包可能干扰新的连接

不管是哪种情况都会让TCP不再可靠，所以TIME_WAIT状态有存在的必要性。


**** 如何控制TIME_WAIT的数量

***** tcp_tw_recycle

顾名思义就是回收TIME_WAIT连接。这里隐藏着一个不易察觉的陷阱：

当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。

#+BEGIN_SRC c
  if (tmp_opt.saw_tstamp &&
      tcp_death_row.sysctl_tw_recycle &&
      (dst = inet_csk_route_req(sk, req)) != NULL &&
      (peer = rt_get_peer((struct rtable *)dst)) != NULL &&
      peer->v4daddr == saddr) {
      if (get_seconds() < peer->tcp_ts_stamp + TCP_PAWS_MSL &&
          (s32)(peer->tcp_ts - req->ts_recent) >
          TCP_PAWS_WINDOW) {
          NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);
          goto drop_and_release;
      }
  }
  /*
    tmp_opt.saw_tstamp：该socket支持tcp_timestamp
    sysctl_tw_recycle： 本机系统开启tcp_tw_recycle选项
    TCP_PAWS_MSL：60s， 该条件判断表示该源ip的上次tcp通讯发生在60s内
    TCP_PAWS_WINDOW：1，该条件判断表示该源ip的上次tcp通讯的timestamp 大于本次tcp
  */
#+END_SRC

*分析:*

主机client1和client2通过NAT网关（1个ip地址）访问serverN，由于timestamp时间为系统启动到当前的时间，因此，client1和client2的timestamp不相同；根据上述syn包处理源码，在tcp_tw_recycle和tcp_timestamps同时开启的条件下，timestamp大的主机访问serverN成功，而timestmap小的主机访问失败。

*参数:*

#+BEGIN_SRC sh
/proc/sys/net/ipv4/tcp_timestamps - 控制timestamp选项开启/关闭
/proc/sys/net/ipv4/tcp_tw_recycle - 减少timewait socket释放的超时时间
#+END_SRC

*解决方案:*

tcp_tw_recycle=1 <服务器端> and tcp_timestamps=0 <客户端> (两者不要同时开启)

***** tcp_tw_reuse

顾名思义就是复用TIME_WAIT连接。当创建新连接的时候，如果可能的话会考虑复用相应的TIME_WAIT连接。 *通常认为tcp_tw_reuse比tcp_tw_recycle安全一些* ，这是因为一来TIME_WAIT创建时间必须超过一秒才可能会被复用；二来只有连接的时间戳是递增的时候才会被复用。官方文档里是这样说的：如果从协议视角看它是安全的，那么就可以使用。这简直就是外交辞令啊！按我的看法， *如果网络比较稳定，比如都是内网连接，那么就可以尝试使用。*

不过需要注意的是在哪里使用，既然我们要复用连接， *那么当然应该在连接的发起方使用，* 而不能在被连接方使用。举例来说：客户端向服务端发起HTTP请求，服务端响应后主动关闭连接，于是TIME_WAIT便留在了服务端，此类情况使用 =tcp_tw_reuse= 是无效的，因为服务端是被连接方，所以不存在复用连接一说。让我们延伸一点来看，比如说服务端是PHP，它查询另一个MySQL服务端，然后主动断开连接，于是TIME_WAIT就落在了PHP一侧，此类情况下使用 =tcp_tw_reuse= 是有效的，因为此时PHP相对于MySQL而言是客户端，它是连接的发起方，所以可以复用连接。

*说明：如果使用tcp_tw_reuse，请激活tcp_timestamps，否则无效。*

重用TIME_WAIT的条件是收到最后一个包后超过1s。

(*待验证*)tcp_tw_reuse即便不开timestamp也是会生效的，开了timestamp只是增大了重用的概率，触发重用满足两个条件之一即可:

1. 新连接的syn序列号比处于TIME_WAIT状态的连接最后收到的序列号大
2. 新连接时间戳比老连接时间戳大。

***** tcp_max_tw_buckets

顾名思义就是控制TIME_WAIT总数。官网文档说这个选项只是为了阻止一些简单的DoS攻击，平常不要人为的降低它。如果缩小了它，那么系统会将多余的TIME_WAIT删除掉，日志里会显示："TCP: time wait bucket table overflow"

需要提醒大家的是物极必反，曾经看到有人把 =tcp_max_tw_buckets= 设置成0，也就是说完全抛弃TIME_WAIT，这就有些冒险了。

**** 总结

有时候，如果我们换个角度去看问题，往往能得到四两拨千斤的效果。前面提到的例子：客户端向服务端发起HTTP请求，服务端响应后主动关闭连接，于是TIME_WAIT便留在了服务端。这里的关键在于主动关闭连接的是服务端！在关闭TCP连接的时候，先出手的一方注定逃不开TIME_WAIT的宿命。如果客户端可控的话，那么在服务端打开KeepAlive (=Connection: Keep-Alive=)，尽可能不让服务端主动关闭连接，而让客户端主动关闭连接，如此一来问题便迎刃而解了。
