#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall



** parameters

#+BEGIN_SRC sh
## -n          依數字大小排序
## -r          降冪排序(反向排序)
## -t,         欄位以,當分隔符號(默认是以[:space:]作为分隔符)
## -k[KEYDEF]  以第幾個欄位來排序
##             KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position,
##             where F is a field number and C a character position in the field;
##             both are origin 1, and the stop position defaults to the line's end.
## -m          merge already sorted files
## -u          只识别用-k设定的域
##             另外, 会权衡所有-k选项, 都相同的才会删除, 只要其中有一级不同就不会删除
##             如有多个相同，-u只输出一行，*输出行是位于原文件中最靠前的那一行*
#+END_SRC

** Example

**** sort -m file1 file2

**** sort -C file

Check the sort status (silent)

**** sort -k3,3rn -k2,2n file

第三列倒序, 第二列升序排列

** Option K

**** sort -k3

以第三列到行末为整体作为单位来排序, 可以假象从第三列到最后作为一个单独的列来看待, 例:

#+BEGIN_SRC sh
$> cat face.txt
baidu  100 5000
google 100 5000
sohu   100 4500
guge   50  3000

$> cat face.txt  | sort  -k2n
guge   50  3000
baidu  100 5000
google 100 5000
sohu   100 4500
#+END_SRC

最后一行出现貌似顺序不正确的行为原因如下:

命令将第二列到行尾看做整体, 即'50 3000', '100 5000'等等, 当这些'整体'比较完后, 于是只剩第一列可以比较, 所以产生貌似不正确的结果

**** sort -k3,3

第三列相同的项的先后顺序由 *左* 边各列决定(从第一列开始)

**** sort -k2.1,3.1

*跨域的设定是个假象*, sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分, 而不会把第三个域的开头字符纳入比较范围. 当有相同项时, sort就回到第一列开始比较

**** example

#+BEGIN_SRC sh
$> cat world.txt
z a a
y a b
x a c

$> cat world.txt | sort -k2
z a a
y a b
x a c

$> cat world.txt | sort -k2,2
x a c
y a b
z a a

$> cat world.txt | sort -k2.1,3.1
x a c
y a b
z a a
#+END_SRC

体会 *左右* 的区别

#+BEGIN_SRC sh
$> cat world.txt
z a a a
y a a b
x a b c

$> cat world.txt  | sort -k2 -k3
z a a a
y a a b
x a b c

$> cat world.txt  | sort -k2,2 -k3,3
y a a b
z a a a
x a b c

$> cat world.txt  | sort -k2,2
x a b c
y a a b
z a a a

$> cat world.txt  | sort -k2,2 -k3
z a a a
y a a b
x a b c
#+END_SRC
