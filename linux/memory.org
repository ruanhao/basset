#+TITLE: Memory
#+OPTIONS: ^:nil



** free

=free -g=

|   |                    |     1 |    2 |    3 |      4 |       5 |      6 |
| 1 |                    | total | used | free | shared | buffers | cached |
| 2 | Mem:               |   252 |  208 |   43 |      0 |       3 |    181 |
| 3 | -/+ buffers/cache: |       |   23 |  228 |        |         |        |
| 4 | Swap:              |     3 |    0 |    3 |        |         |        |

=F[2][1] = F[2][2] + F[2][3]=

=F[3][2] = F[2][2] - F[2][5] -  F[2][6]=

=F[3][3] = F[2][3] +F[2][5] + F[2][6]=

*** Mem

从OS的角度来看

- *total*

  物理内存总量

- *used*

  总计分配给缓存(包含buffers与cache)使用的数量(/其中部分缓存并未实际使用/)

  =used = used[kernel] + used[application] + F[2][5] + F[2][6]=

  F[2][5]和F[2][6]是可用于分配的内存数量

- *shared*

  Deprecated

- *buffers*

  Something that has yet to be "written" to disk

- *cached*

  Something that has been "read" from the disk and stored for later use

  也就是说buffer是用于存放要输出到块设备的数据, 而cache是存放从块设备上读出的数据, buffer和cache是为了提高IO的性能, 并由OS管理

*** -/+ buffers/cache

从Application的角度看

- *used*

  表示一个应用程序认为系统被用掉多少内存

- *free*

  表示一个应用程序认为系统还有多少内存

** slab

The slab allocator is an abstraction layer to make easier allocation of numerous objects of a same type

Linux将kernel object存放在cache中，并透过slab来进行管理。当系统执行一个kernel object时，就会建立一块slab cache来储存

專指kernel所使用的記憶體空間(kernel page)。Linux kernel所占用的記憶體空間是無法對應到磁碟上的

active是指使用中的記憶體；而inactive是即將搬到swap上的記憶體

Linux kernel採用slab機制進行記憶體管理，slab是一串連續的記憶體，用來表示cache所占用的空間。一塊cache可能占用一個以上的slab

#+BEGIN_SRC bash

 $ slabtop

 Active / Total Objects (% used)    : 549459 / 564039 (97.4%)
 Active / Total Slabs (% used)      : 52722 / 52727 (100.0%)
 Active / Total Caches (% used)     : 106 / 155 (68.4%)
 Active / Total Size (% used)       : 195789.07K / 198033.17K (98.9%)
 Minimum / Average / Maximum Object : 0.02K / 0.35K / 128.00K

  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME
182970 182511  99%    0.21K  10165      18           40660K dentry_cache
127170 127145  99%    0.74K  25434        5          101736K ext3_inode_cache
109040 108938  99%    0.09K   2726      40           10904K buffer_head
 33762  33723   99%    0.58K   5627       6           22508K proc_inode_cache
 10913  10911   99%    0.52K   1559        7          6236K radix_tree_node
  9296   9240   99%     0.55K   1328       7          5312K inode_cache
  9240   9155   99%     0.09K    210      44          840K sysfs_dir_cache

  ## 圖中的每一行都代表在kernel中執行的process所占用的cache大小
  ## OBJS   指的是這個process調用了多少個object
  ## ACTIVE 代表有多少object正在使用中，USE是active的比例
  ## SLABS  指這個process使用多少個slab來管理，而OBJ/SLAB就是指一個slab擁有多少個object
#+END_SRC


** buddy

*/proc/buddyinfo*紀錄的就是Linux kernel的記憶體管理機制*buddy system*的內容

Linux kernel透過buddy system來對free page進行管理，page是kernel記憶體使用的基本單位

當系統需要一塊page時，會透過buddy system提取，而buddy的管理機制會儘可能地維持記憶體的連續性，以減少fragmentation的情形發生

buddy system管理記憶體的方式是將連續的page指定為一個chunk，而且chunk的大小是以2的次方依序分割。也就是1k, 2k, 4k, 8k, 16k, 32k,... 以此類推。當kernel需要一塊空間時，他會從最小且足夠的chunk中去要一塊。若是不夠，則轉向下一個chunk去要，而且盡可能把切剩餘的空間加到同等級的chunk中，藉此減少用不到的浪費(fragmentation)。譬如說，需要16k，但是16k的chunk沒有剩餘的了，所以就向32k的chunk去要，而切剩的另外16k則計算到16k的chunk中

在/proc/buddyinfo中就是記錄這些chunk的使用情形，依序顯示每個不同大小的chunk還有多少個可用空間

#+BEGIN_SRC bash

$ cat /proc/buddyinfo

Node 0, zone      DMA      5      3      5      2      3      2      1      1      2      2      1
Node 0, zone   Normal      0      1      5      0      1      1      1      1      1      0    108
Node 0, zone  HighMem    320    259    147     59     16     11      6      3      1      1    684

## /proc/buddyinfo中將實體記憶體依照其位址(由low至high)分成3個zone
## 分別是: DMA, Normal與HighMem
## 而每個zone內的數字代表在這個zone之中依序還有多少可用的chunk數量
## 像這個例子，在DMA zone中，4k的chunk(由左至右第三個數字)還有5個可用的空間

#+END_SRC
