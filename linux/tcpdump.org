#+TITLE:     tcpdump
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 一, 基本语法


** 1.1, 过滤主机

- 抓取所有经过 eth1，目的或源地址是 192.168.1.1 的网络数据

  #+BEGIN_SRC bash
  tcpdump -i eth1 host 192.168.1.1
  #+END_SRC

- 指定源地址

  #+BEGIN_SRC bash
  tcpdump -i eth1 src host 192.168.1.1
  #+END_SRC

- 指定目的地址

  #+BEGIN_SRC bash
  tcpdump -i eth1 dst host 192.168.1.1
  #+END_SRC


** 1.2, 过滤端口

- 抓取所有经过eth1，目的或源端口是25的网络数据

#+BEGIN_SRC
tcpdump -i eth1 port 25
#+END_SRC

- 指定源端口

#+BEGIN_SRC
tcpdump -i eth1 src port 25
#+END_SRC

- 指定目的端口

#+BEGIN_SRC
tcpdump -i eth1 dst port 25
#+END_SRC


** 1.3, 过滤网络

#+BEGIN_SRC
tcpdump -i eth1 net 192.168
tcpdump -i eth1 src net 192.168
tcpdump -i eth1 dst net 192.168
#+END_SRC


** 1.4, 过滤协议

#+BEGIN_SRC
tcpdump -i eth1 arp
tcpdump -i eth1 ip
tcpdump -i eth1 tcp
tcpdump -i eth1 udp
tcpdump -i eth1 icmp
#+END_SRC


** 1.5, 表达式

#+BEGIN_EXAMPLE
与 : && (and)
非 : !  (not)
或 : || (or)
#+END_EXAMPLE

- 抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据

#+BEGIN_SRC
tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))'
#+END_SRC

- 抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据

#+BEGIN_SRC
tcpdump -i eth1 '((icmp) and ((ether dst host 00:01:02:03:04:05)))'
#+END_SRC

- 抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据

#+BEGIN_SRC
tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))'
#+END_SRC


* 二, 包头过滤

** 2.0, 基本语法

#+BEGIN_SRC
proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）
proto[x:y] & z = 0  : proto[x:y]和z的与操作为0
proto[x:y] & z !=0  : proto[x:y]和z的与操作不为0
proto[x:y] & z = z  : proto[x:y]和z的与操作为z
proto[x:y] = z      : proto[x:y]等于z
#+END_SRC

操作符 : >, <, >=, <=, =, !=


** 2.1, IP

[[../network/tcpip.org][报文格式参考]]

*** 2.1.1, 过滤 IP Option

通常 IP 头是 20 字节，但 IP 头有选项设置，不能直接从偏移 21 字节处读取数据。

IP 头有个长度字段( IHL )可以知道头长度是否大于 20 字节。

IHL (4 bits) 表示 IP 头 32 bit 的块数, 通常为 5 ( = 5 * 32 bits = 160 bits or 20 bytes)

过滤方法

#+BEGIN_SRC
tcpdump -i eth1 'ip[0] & 0x0f > 5'
#+END_SRC


*** 2.1.2, 过滤分片

**** 2.1.1.1, 基本原理

当发送端的 MTU 大于到目的路径链路上的 MTU 时就会被分片

分片信息在 IP 头的第七和第八字节：

#+BEGIN_SRC

 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Flags|      Fragment Offset    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

#+END_SRC

Bit 0:  保留，必须是0
Bit 1:  (DF) 0 = 分片, 1 = 不分片
Bit 2:  (MF) 0 = 最后的分片, 1 = 还有分片

Fragment Offset 字段只有在分片的时候才使用。

**** 2.1.1.2, 过滤不分片的包

要抓带 DF 位标记的不分片的包，第七字节的值应该是：*01000000 = 64*

#+BEGIN_SRC
tcpdump -i eth1 'ip[6] = 64'
#+END_SRC

**** 2.1.1.3, 过滤分片包

#+BEGIN_SRC
tcpdump -i eth1 '((ip[6:2] > 0) and (not ip[6] = 64))'
#+END_SRC

**** 2.1.1.4, 测试分片

TCP 发送数据时，将大于 MSS 的数据分段( segment 不叫分片)

MSS 往往基于 MTU 计算出来，通常 *MSS = MTU-sizeof(IP Header)-sizeof(TCP Header) = 1500-20-20 = 1460*

这样，数据经过本地 TCP 层分段后，交给本地 IP 层，在本地 IP 层就不需要分片了。但是在下一跳路由 (Next Hop) 的邻居路由器上可能发生 IP 分片!

#+BEGIN_SRC
ping -M want -s 3000 192.168.1.1
#+END_SRC

*** 2.1.3, 过滤大于 x 字节的数据包

#+BEGIN_SRC
tcpdump -i eth1 'ip[2:2] > 600'
#+END_SRC


** 2.2, TCP

[[../network/tcpip.org][报文格式参考]]

*** 2.2.1, 过滤源端口

#+BEGIN_SRC
tcpdump -i eth1 'tcp[0:2] > 1024'
tcpdump -i eth1 'portrange 21-23'
#+END_SRC

*** 2.2.2, 过滤特殊标记

TCP 标记定义在 TCP 头的第十四个字节

#+BEGIN_SRC
 +-+-+-+-+-+-+-+-+
 |C|E|U|A|P|R|S|F|
 |W|C|R|C|S|S|Y|I|
 |R|E|G|K|H|T|N|N|
 +-+-+-+-+-+-+-+-+
#+END_SRC

**** 2.2.2.1, 过滤 SYN 包
#+BEGIN_SRC
tcpdump -i eth1 'tcp[13] = 2'
tcpdump -i eth1 'tcp[tcpflags] = tcp-syn'
#+END_SRC

**** 2.2.2.2, 过滤 SYN-ACK 包
#+BEGIN_SRC
tcpdump -i eth1 'tcp[13] & 2 = 2'
tcpdump -i eth1 'tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack != 0'
#+END_SRC

**** 2.2.2.3, 过滤 PSH-ACK 包
#+BEGIN_SRC
tcpdump -i eth1 'tcp[13] = 24'
#+END_SRC

**** 2.2.2.4, 过滤 FIN 包 ( FIN 通常和 ACK 一起 )
#+BEGIN_SRC
tcpdump -i eth1 'tcp[13] & 1 = 1'
#+END_SRC

**** 2.2.2.5, 过滤 RST 包
#+BEGIN_SRC
tcpdump -i eth1 'tcp[13] & 4 = 4'
#+END_SRC

**** 2.2.2.6, 握手特征码
#+BEGIN_SRC
SYN=1, FIN=0, RST=0, ACK=0 # 第一次握手
SYN=1, FIN=0, RST=0, ACK=1 # 第二次握手
SYN=0, FIN=0, RST=0, ACK=1 # ESTABLISHED
#+END_SRC


* 三, 示例

- 抓 HTTP GET 数据

  #+BEGIN_SRC
  tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x47455420'
  # "GET "的十六进制是47455420
  # DATA Offset 单位为 32 bits = 4 bytes，所以需要右移2位(*4)
  #+END_SRC

- 指定抓包数量

  #+BEGIN_SRC
  time tcpdump -nn -i eth0 'tcp[tcpflags] = tcp-syn' -c 10000 > /dev/null
  ## 计算抓 10000 个 SYN 包花费多少时间，可以判断访问量大概是多少
  #+END_SRC

- 从 pcap 文件读取内容

  #+BEGIN_SRC
  tcpdump -nvvvs 0 -X -r data.pcap
  #+END_SRC
