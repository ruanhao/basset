#+TITLE:     Nginx
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 3


* 基本原理

** 设计架构

Nginx 会同时运行多个进程，一个主进程（master）和多个工作进程（worker），配置缓存时还会有缓存加载器进程（cache loader）和
缓存管理器进程（cache manager）等。所有进程均仅含一个线程，通过共享内存的机制实现进程间通信。主进程以 root 身份运行，
其余进程以非特权身份运行。

*** master 进程

- 读取并验证配置信息
- 创建，绑定及关闭套接字
- 启动，终止及维护 worker 进程的个数
- 配置热部署（平滑升级）
- 编译嵌入式脚本
- 日志文件管理


*** worker 进程

- 接受并处理客户端连接
- 提供反向代理及过滤功能


*** cache loader 进程

- 建立内存数据库


*** cache manager 进程

- 缓存失效及过期检查


* 常用配置

** 基本配置

#+BEGIN_SRC nginx
  server {

      listen 40839;
      root /var/data;             # 网站的源代码静态文件的根目录。
      server_name example.org;    # 域名

      location / {
          index index.html index.php;
          # 当访问 http://example.org 时就会去读取 /var/root/index.html ，
          # 如果找不到就会读取 index.php ，就会转发到 fastcgi_pass 里面的逻辑
      }

      location ~* \.(gif|jpg|png)$ {
          expires 30d;            # 在 30 天后过期，也就是缓存 30 天
      }

      location ~ \.php$ {
          fastcgi_pass  localhost:9000;
          fastcgi_param SCRIPT_FILENAME
                        $document_root$fastcgi_script_name;
          include       fastcgi_params;
      }

  }
#+END_SRC


** 反向代理

反向代理是依赖于 `ngx_http_proxy_module` 这个模块来实现的


*** 直接转发

#+BEGIN_SRC nginx
  server {
      server_name www.example.com;
      listen       443;

      location /reverse.gif {
          proxy_pass http://image.sinajs.cn/newchart/hollow/small/nsh000001.gif;
      }

  }
#+END_SRC


*** 动态转发

#+BEGIN_SRC nginx
  upstream pool {
      server 127.0.0.1:8888;
  }

  server {

      listen 40839;
      root /tmp/data;
      server_name example.org;

      try_files $uri/index.html @reverse; # 先找根目录下的 index.html ，如果找不到，才执行 location @rails365

      location @reverse {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $http_host;
          proxy_redirect off;
          proxy_pass http://pool;
      }
  }
#+END_SRC


*** websocket 转发

#+BEGIN_SRC nginx
  upstream ws {
    server http://127.0.0.1:8888;
  }

  server {

    location /ws/ {
      proxy_pass ws;
      proxy_http_version 1.1;

      proxy_read_timeout    7200;
      proxy_send_timeout    7200;

      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
    }

  }

#+END_SRC


** 压缩

#+BEGIN_SRC nginx
  http {

      # 开启gzip
      gzip on;

      # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩
      gzip_min_length 1k;

      # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明
      gzip_comp_level 2;

      # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。
      gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

      # 是否在http header中添加Vary: Accept-Encoding，建议开启
      gzip_vary on;

      # 禁用IE 6 gzip
      gzip_disable "MSIE [1-6]\.";

      server {
          location ~* ^.+\.(css|js|txt|xml|swf|wav)$ {
              access_log   off;
              expires      24h;   # 开启缓存
          }

      }
  }
#+END_SRC


** 监控

#+BEGIN_SRC sh
  pip install ngxtop
#+END_SRC


** Basic Auth

`ngx_http_auth_basic_module` 是使用文件作为存储介质的，用户名和密码必须和文件的信息匹配才能认证成功。

使用 `htpasswd` 这个命令来生成存放用户名和密码的文件，需要先安装它。

#+BEGIN_SRC sh
  htpasswd -bc /etc/nginx/.htpasswd <username> <password>
#+END_SRC

#+BEGIN_SRC nginx
  location /target {
      auth_basic "Restricted";
      auth_basic_user_file /etc/nginx/.htpasswd; # htpasswd 文件
  }
#+END_SRC


** 负载均衡

*** least_conn

优先发送给那些接受请求少的

#+BEGIN_SRC nginx
  upstream servers {
      least_conn;
      server <server_ip_1>;
      server <server_ip_2>;
  }
#+END_SRC


*** ip_hash

可以记录请求来源的ip，如果是同一个ip，下次访问的时候还是会到相同的主机

#+BEGIN_SRC nginx
  upstream servers {
      ip_hash;
      server <server_ip_1>;
      server <server_ip_2>;
  }
#+END_SRC


*** hash

通过任何变量来控制

#+BEGIN_SRC nginx
  upstream servers {
      hash $request_uri consistent; # 通过请求地址($request_uri)来控制
      server <server_ip_1>;
      server <server_ip_2>;
  }
#+END_SRC


*** down

假如有一台主机是出了故障，或者下线了，要暂时移出，那可以把它标为down，表示请求会略过这台主机

#+BEGIN_SRC nginx
  upstream servers {
      server <server_ip_1>;
      server <server_ip_2> down;
  }
#+END_SRC


*** backup

backup 是指备份的机器，相对于备份的机器来说，其他的机器就相当于主要服务器，只要当主要服务器不可用的时候，才会用到备用服务器

#+BEGIN_SRC nginx
  upstream servers {
      server <server_ip_1>;
      server <server_ip_2> backup;
  }
#+END_SRC


*** weight

weight指的是权重，默认情况下，每台主机的权重都是1，也就是说，接收请求的次数的比例是一样的。

可以根据主机的配置或其他情况自行调节，比如，对于配置高的主机，可以把weight值调大。

#+BEGIN_SRC nginx
  upstream servers {
      server <server_ip_0> weight=3;
      server <server_ip_1>;
      server <server_ip_2>;
  }
#+END_SRC


** 返回状态码

#+BEGIN_SRC nginx
  location /error {
      return 404 "Not Found !";
  }
#+END_SRC


** URL 重写

#+BEGIN_SRC nginx
  location / {
      rewrite '^/images/(.*)\.(png|jpg|gif)$' /data?file=$1.$2;
      # 注意不能在上面这条规则后面加上“last”参数，否则下面的 set 指令不会执行
      set $image_file $1;
      set $image_type $2;
  }

  location /data {
      root /tmp/data;
      # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最
      try_files /$arg_file /404.html;
  }

  location /404.html {
      return 404 "$image_file.$image_type Not Found";
  }
#+END_SRC

#+BEGIN_SRC nginx
  location /images/ {
      rewrite ^/images/(.*)$ http://1.2.3.4/images/$1/; ## 浏览器重定向至 http://1.2.3.4/images/$1
  }
#+END_SRC


** Location

#+BEGIN_SRC sh
location    <uri> { ... }  ## 对当前路径及子路径下的所有资源都生效
location =  <uri> { ... }  ## 只对当前路径生效（精确匹配，不包括子路径）
location ~  <uri> { ... }  ## 正则匹配（区分大小写）
location ~* <uri> { ... }  ## 正则匹配（不区分大小写）
location ^~ <uri> { ... }  ## 降低正则匹配的优先级
#+END_SRC

*** 优先级

  #+BEGIN_EXAMPLE
  1. Directives with the "=" prefix that match the query exactly. If found, searching stops.
  2. All remaining directives with literal strings. If this match used the "^~" prefix, searching stops.
  3. Regular expressions, in the order they are defined in the configuration file.
  4. If #3 yielded a match, that result is used. Otherwise, the match from #2 is used.
  #+END_EXAMPLE


*** 转发规则

  location 和 target 尽量都以 / 结尾，否则可能会遇到循环重定向问题，遇到问题请抓包分析即可知来龙去脉。

  #+BEGIN_SRC sh
    location /hello {
        root /home/test;   ## 访问 http://<domain>/hello
                           ## 若不存在目录 /home/test/hello ，则返回 404
                           ## 若存在目录   /home/test/hello ，重定向至 https://<domain>/hello/，默认请求 /home/test/hello/index.html
    }

    location /hello {
        root /home/test/;  ## 同上
    }

    location /hello/ {
        root /home/test;   ## 访问 http://<domain>/hello ， 无法匹配，返回 404
                           ## 访问 https://<domain>/hello/，默认请求 /home/test/hello/index.html
    }

    location /hello/ {
        root /home/test/;  ## 同上
    }
  #+END_SRC

  #+BEGIN_SRC sh
    location /world {
        proxy_pass http://127.0.0.1:9999;   ## 访问 http://<domain>/world ，   转发为 GET /world HTTP/1.0
                                            ## 访问 http://<domain>/world/hk ，转发为 GET /world/hk HTTP/1.0
    }

    location /world {
        proxy_pass http://127.0.0.1:9999/;  ## 访问 http://<domain>/world ，   转发为 GET / HTTP/1.0
                                            ## 访问 http://<domain>/world/hk ，转发为 GET //hk HTTP/1.0
                                            ## / + (/world/hk - /world) = / + /hk = //hk
    }

    location /world/ {
        proxy_pass http://127.0.0.1:9999;   ## 访问 http://<domain>/world ，   重定向为 http://<domain>/world/ ，转发为 GET /world/ HTTP/1.0
                                            ## 访问 http://<domain>/world/hk ，转发为 GET /world/hk HTTP/1.0
    }

    location /world/ {
        proxy_pass http://127.0.0.1:9999/;  ## 访问 http://<domain>/world ，   重定向为 http://<domain>/world/ ，转发为 GET / HTTP/1.0
                                            ## 访问 http://<domain>/world/hk ，转发为 GET /hk HTTP/1.0
                                            ## / + (/workd/hk - /world/) = / + hk = /hk
    }
  #+END_SRC


** 访问控制

默认是 =allow all= ，如果要启用访问控制功能，则最后一行必须为 =deny all=

#+BEGIN_SRC nginx
  location <uri> {
      deny  192.168.0.2;
      allow 192.168.1.0/24;
      deny  all;
  }
#+END_SRC


** 端口转发

*The ngx_stream_core_module module is available since version 1.9.0*

#+BEGIN_SRC nginx
  stream {
      server {
          listen     48080;
          proxy_pass 127.0.0.1:8080;
      }
  }
#+END_SRC


** 添加模块

#+BEGIN_SRC sh
  sudo apt-get install libpcre3 libpcre3-dev build-essential zlib1g-dev -y
  version=`nginx -v 2>&1 | grep -o '[0-9]*\.[0-9]*\.[0-9]*'`
  curl -O http://hg.nginx.org/nginx/archive/release-$version.tar.gz
  tar xfvz release-$version.tar.gz
  cd nginx-release-$version
  ./auto/configure --with-stream
  make
  sudo make install
#+END_SRC

** Nginx in Docker

*** 获取 nginx.conf

#+BEGIN_SRC sh
  docker run --rm --name tmp-nginx -d nginx
  docker cp tmp-nginx:/etc/nginx/nginx.conf /host/path/nginx.conf
  docker rm -f tmp-nginx
#+END_SRC

*** 自定义 nginx.conf

=docker run --rm --name my-nginx -p 8080:80 -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx=

*** 自定义静态文件

=docker run --rm --name my-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx=
