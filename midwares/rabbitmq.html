<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-05-20 Mon 00:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RabbitMQ</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Hao Ruan">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
<link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">RabbitMQ</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb7e721f">1. AMQP</a>
<ul>
<li><a href="#org3b8e228">1.1. AMQP Frame</a>
<ul>
<li><a href="#orga18dd8c">1.1.1. Frame Types</a>
<ul>
<li><a href="#org6d3342c">1.1.1.1. Method frame</a></li>
<li><a href="#org28a6715">1.1.1.2. Content header frame</a></li>
<li><a href="#org417097c">1.1.1.3. Body frame</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge694083">1.2. AMQP Model</a></li>
<li><a href="#org80fb7c3">1.3. Protocol Implement</a>
<ul>
<li><a href="#org591c9c1">1.3.1. Declaring exchange</a></li>
<li><a href="#orga7e62d7">1.3.2. Declaring queue</a></li>
<li><a href="#org0f3d3ea">1.3.3. Binding queue to exchange</a></li>
<li><a href="#org48177ce">1.3.4. Publishing message</a>
<ul>
<li><a href="#org20dd3c8">1.3.4.1. <code>mandatory</code> flag</a></li>
<li><a href="#org4cc58d6">1.3.4.2. Publisher Confirm</a></li>
<li><a href="#org5fc2e94">1.3.4.3. Alternate exchange</a></li>
<li><a href="#org8764cde">1.3.4.4. Transaction</a></li>
<li><a href="#org7862822">1.3.4.5. HA queues</a></li>
<li><a href="#org6f19b83">1.3.4.6. Delivery Mode 2</a></li>
</ul>
</li>
<li><a href="#org939ad25">1.3.5. Consuming message</a>
<ul>
<li><a href="#orge7a722e">1.3.5.1. Consumer Tag</a></li>
<li><a href="#orga0cd695">1.3.5.2. <code>no-ack</code> argument</a>
<ul>
<li><a href="#org4120475">1.3.5.2.1. Delivery tag</a></li>
</ul>
</li>
<li><a href="#orgb9744a7">1.3.5.3. Prefetching (QoS)</a></li>
<li><a href="#orgf89e02c">1.3.5.4. <code>Basic.Get</code></a></li>
<li><a href="#org854a131">1.3.5.5. <code>Basic.Reject</code></a></li>
<li><a href="#orgbb47d3d">1.3.5.6. <code>Basic.Nack</code></a></li>
<li><a href="#orgb88a167">1.3.5.7. Dead letter exchanges</a></li>
</ul>
</li>
<li><a href="#orgc49d70d">1.3.6. <code>Basic.Properties</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfff9015">2. 交换器</a>
<ul>
<li><a href="#orgd91712f">2.1. 属性</a></li>
<li><a href="#org45a8919">2.2. direct</a></li>
<li><a href="#org77cd312">2.3. fanout</a></li>
<li><a href="#orgac5f9d8">2.4. topic</a></li>
<li><a href="#orgf55376f">2.5. 路由</a></li>
</ul>
</li>
<li><a href="#org146a838">3. RabbitMQ 管理</a>
<ul>
<li><a href="#org524c307">3.1. 日志</a></li>
<li><a href="#orgd1bbd62">3.2. 配置文件</a></li>
<li><a href="#orgb3a44b1">3.3. 接入 Eshell</a></li>
</ul>
</li>
<li><a href="#org546ffe2">4. 代码示例</a>
<ul>
<li><a href="#org48b36f8">4.1. 基本用法</a>
<ul>
<li><a href="#orgc98e764">4.1.1. 生产者</a></li>
<li><a href="#org51c46a3">4.1.2. 消费者</a></li>
</ul>
</li>
<li><a href="#org334bb11">4.2. 发送方确认模式</a>
<ul>
<li><a href="#org18357aa">4.2.1. 生产者</a></li>
</ul>
</li>
<li><a href="#org043945d">4.3. 通过 AMQP 实时访问日志</a></li>
</ul>
</li>
<li><a href="#org547a2cd">5. 集群</a>
<ul>
<li><a href="#org7d062e6">5.1. Architecture</a>
<ul>
<li><a href="#orgcbf86f4">5.1.1. Queue in cluster</a></li>
<li><a href="#org333d1db">5.1.2. Exchange in cluster</a></li>
<li><a href="#orgb6049ab">5.1.3. RAM/DISK node</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org81a1538">6. 持久性</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="meta">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Author</td>
<td class="org-left">Hao Ruan (haoru@cisco.com)</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">2019-05-20 00:19:00</td>
</tr>
</tbody>
</table>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb7e721f">1. AMQP</a>
<ul>
<li><a href="#org3b8e228">1.1. AMQP Frame</a>
<ul>
<li><a href="#orga18dd8c">1.1.1. Frame Types</a>
<ul>
<li><a href="#org6d3342c">1.1.1.1. Method frame</a></li>
<li><a href="#org28a6715">1.1.1.2. Content header frame</a></li>
<li><a href="#org417097c">1.1.1.3. Body frame</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge694083">1.2. AMQP Model</a></li>
<li><a href="#org80fb7c3">1.3. Protocol Implement</a>
<ul>
<li><a href="#org591c9c1">1.3.1. Declaring exchange</a></li>
<li><a href="#orga7e62d7">1.3.2. Declaring queue</a></li>
<li><a href="#org0f3d3ea">1.3.3. Binding queue to exchange</a></li>
<li><a href="#org48177ce">1.3.4. Publishing message</a>
<ul>
<li><a href="#org20dd3c8">1.3.4.1. <code>mandatory</code> flag</a></li>
<li><a href="#org4cc58d6">1.3.4.2. Publisher Confirm</a></li>
<li><a href="#org5fc2e94">1.3.4.3. Alternate exchange</a></li>
<li><a href="#org8764cde">1.3.4.4. Transaction</a></li>
<li><a href="#org7862822">1.3.4.5. HA queues</a></li>
<li><a href="#org6f19b83">1.3.4.6. Delivery Mode 2</a></li>
</ul>
</li>
<li><a href="#org939ad25">1.3.5. Consuming message</a>
<ul>
<li><a href="#orge7a722e">1.3.5.1. Consumer Tag</a></li>
<li><a href="#orga0cd695">1.3.5.2. <code>no-ack</code> argument</a>
<ul>
<li><a href="#org4120475">1.3.5.2.1. Delivery tag</a></li>
</ul>
</li>
<li><a href="#orgb9744a7">1.3.5.3. Prefetching (QoS)</a></li>
<li><a href="#orgf89e02c">1.3.5.4. <code>Basic.Get</code></a></li>
<li><a href="#org854a131">1.3.5.5. <code>Basic.Reject</code></a></li>
<li><a href="#orgbb47d3d">1.3.5.6. <code>Basic.Nack</code></a></li>
<li><a href="#orgb88a167">1.3.5.7. Dead letter exchanges</a></li>
</ul>
</li>
<li><a href="#orgc49d70d">1.3.6. <code>Basic.Properties</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfff9015">2. 交换器</a>
<ul>
<li><a href="#orgd91712f">2.1. 属性</a></li>
<li><a href="#org45a8919">2.2. direct</a></li>
<li><a href="#org77cd312">2.3. fanout</a></li>
<li><a href="#orgac5f9d8">2.4. topic</a></li>
<li><a href="#orgf55376f">2.5. 路由</a></li>
</ul>
</li>
<li><a href="#org146a838">3. RabbitMQ 管理</a>
<ul>
<li><a href="#org524c307">3.1. 日志</a></li>
<li><a href="#orgd1bbd62">3.2. 配置文件</a></li>
<li><a href="#orgb3a44b1">3.3. 接入 Eshell</a></li>
</ul>
</li>
<li><a href="#org546ffe2">4. 代码示例</a>
<ul>
<li><a href="#org48b36f8">4.1. 基本用法</a>
<ul>
<li><a href="#orgc98e764">4.1.1. 生产者</a></li>
<li><a href="#org51c46a3">4.1.2. 消费者</a></li>
</ul>
</li>
<li><a href="#org334bb11">4.2. 发送方确认模式</a>
<ul>
<li><a href="#org18357aa">4.2.1. 生产者</a></li>
</ul>
</li>
<li><a href="#org043945d">4.3. 通过 AMQP 实时访问日志</a></li>
</ul>
</li>
<li><a href="#org547a2cd">5. 集群</a>
<ul>
<li><a href="#org7d062e6">5.1. Architecture</a>
<ul>
<li><a href="#orgcbf86f4">5.1.1. Queue in cluster</a></li>
<li><a href="#org333d1db">5.1.2. Exchange in cluster</a></li>
<li><a href="#orgb6049ab">5.1.3. RAM/DISK node</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org81a1538">6. 持久性</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgb7e721f" class="outline-2">
<h2 id="orgb7e721f"><span class="section-number-2">1</span> AMQP</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3b8e228" class="outline-3">
<h3 id="org3b8e228"><span class="section-number-3">1.1</span> AMQP Frame</h3>
<div class="outline-text-3" id="text-1-1">
<p>
AMQP uses <span class="underline">classes</span> and <span class="underline">methods</span>, referred to as <b>AMQP commands</b>, to create a common language between clients and servers.
</p>


<div class="figure">
<p><img src="img/rabbit_frame.png" alt="rabbit_frame.png">
</p>
</div>


<div class="figure">
<p><img src="img/rabbit_frame2.png" alt="rabbit_frame2.png">
</p>
</div>
</div>

<div id="outline-container-orga18dd8c" class="outline-4">
<h4 id="orga18dd8c"><span class="section-number-4">1.1.1</span> Frame Types</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The AMQP specification defines five types of frames:
</p>

<ul class="org-ul">
<li>Protocol header frame
Only used once, when connecting to RabbitMQ.</li>
<li>Method frame
Carries with it the RPC request or response that's being sent to or received from RabbitMQ.</li>
<li>Content header frame
Contains the size and properties for a message.</li>
<li>Body frames
Contain the content of messages.</li>
<li>Heartbeat frame
Sent to and from RabbitMQ as a check to ensure that both sides of the connection are available and working properly.</li>
</ul>
</div>

<div id="outline-container-org6d3342c" class="outline-5">
<h5 id="org6d3342c"><span class="section-number-5">1.1.1.1</span> Method frame</h5>
<div class="outline-text-5" id="text-1-1-1-1">

<div class="figure">
<p><img src="img/rabbit_method_frame.png" alt="rabbit_method_frame.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org28a6715" class="outline-5">
<h5 id="org28a6715"><span class="section-number-5">1.1.1.2</span> Content header frame</h5>
<div class="outline-text-5" id="text-1-1-1-2">

<div class="figure">
<p><img src="img/rabbit_content_header_frame.png" alt="rabbit_content_header_frame.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org417097c" class="outline-5">
<h5 id="org417097c"><span class="section-number-5">1.1.1.3</span> Body frame</h5>
<div class="outline-text-5" id="text-1-1-1-3">

<div class="figure">
<p><img src="img/rabbit_body_frame.png" alt="rabbit_body_frame.png">
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orge694083" class="outline-3">
<h3 id="orge694083"><span class="section-number-3">1.2</span> AMQP Model</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The AMQ model logically defines three abstract components in broker software that define the routing behavior of messages:
</p>

<ul class="org-ul">
<li>Exchange
The component of the message broker that routes messages to queues</li>
<li>Queue
A data structure on disk or in memory that stores messages</li>
<li>Binding
A rule that tells the exchange which queue the messages should be stored in</li>
</ul>
</div>
</div>


<div id="outline-container-org80fb7c3" class="outline-3">
<h3 id="org80fb7c3"><span class="section-number-3">1.3</span> Protocol Implement</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org591c9c1" class="outline-4">
<h4 id="org591c9c1"><span class="section-number-4">1.3.1</span> Declaring exchange</h4>
<div class="outline-text-4" id="text-1-3-1">

<div class="figure">
<p><img src="img/rabbit_declare_exchange.png" alt="rabbit_declare_exchange.png">
</p>
</div>


<p>
If, for whatever reason, the command should fail, RabbitMQ will close the channel by sending a <code>Channel.Close</code> command. <br>
This response will include a numeric reply code and text value indicating why the <code>Exchange.Declare</code> failed and the channel was closed.
</p>
</div>
</div>

<div id="outline-container-orga7e62d7" class="outline-4">
<h4 id="orga7e62d7"><span class="section-number-4">1.3.2</span> Declaring queue</h4>
<div class="outline-text-4" id="text-1-3-2">

<div class="figure">
<p><img src="img/rabbitmq_create.png" alt="rabbitmq_create.png">
</p>
</div>


<ul class="org-ul">
<li>消费者和生产者都能使用 <code>Queue.Delare</code> 命令来创建队列。</li>
<li>如果消费者在同一信道上已订阅了另一个信道的话，则无法再声明队列了，必须先取消订阅。</li>
<li>当创建队列时，可以指定队列名称，如果不指定的话，RabbitMQ 会分配一个随机名称并在 <code>Queue.Declare</code> 命令的响应中返回。</li>
<li>如果需要临时队列只为一个消费者服务的话，可以结合使用 <code>auto-delete</code> 和 <code>exclusive</code> ，当消费者断开连接时，队列就被移除了。</li>
<li>发出去的消息如果路由到了不存在的队列的话，RabbitMQ 会忽略它们。因此，一般情况下，生产者和消费者都应该尝试创建队列。</li>
<li>Should the <code>Queue.Declare</code> command fail, the channel will be <span class="underline">closed</span>.</li>
</ul>

<pre class="example">
When declaring a queue, there's no harm in issuing the same Queue.Declare command more than once.
RabbitMQ will consider subsequent queue declares to be PASSIVE and will return useful information about the queue,
such as the number of pending messages in the queue and the number of consumers subscribed to it.
</pre>
</div>
</div>


<div id="outline-container-org0f3d3ea" class="outline-4">
<h4 id="org0f3d3ea"><span class="section-number-4">1.3.3</span> Binding queue to exchange</h4>
<div class="outline-text-4" id="text-1-3-3">

<div class="figure">
<p><img src="img/rabbit_bind_queue.png" alt="rabbit_bind_queue.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org48177ce" class="outline-4">
<h4 id="org48177ce"><span class="section-number-4">1.3.4</span> Publishing message</h4>
<div class="outline-text-4" id="text-1-3-4">

<div class="figure">
<p><img src="img/rabbit_publish_msg.png" alt="rabbit_publish_msg.png">
</p>
</div>
</div>


<div id="outline-container-org20dd3c8" class="outline-5">
<h5 id="org20dd3c8"><span class="section-number-5">1.3.4.1</span> <code>mandatory</code> flag</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<p>
The <code>mandatory</code> flag is an argument that's passed along with the <code>Basic.Publish</code> RPC command and tells RabbitMQ that if a message isn't routable,
it should send the message back to the publisher via a <code>Basic.Return</code> RPC.
</p>


<div class="figure">
<p><img src="img/rabbit_publish_with_mandatory.png" alt="rabbit_publish_with_mandatory.png">
</p>
</div>
</div>
</div>



<div id="outline-container-org4cc58d6" class="outline-5">
<h5 id="org4cc58d6"><span class="section-number-5">1.3.4.2</span> Publisher Confirm</h5>
<div class="outline-text-5" id="text-1-3-4-2">
<p>
Prior to publishing any messages, a message publisher must issue a <code>Confirm.Select</code> RPC request to RabbitMQ and
wait for a <code>Confirm.SelectOk</code> response to know that delivery confirmations are enabled.
</p>

<p>
For each message that a publisher sends to RabbitMQ, the server will respond with an acknowledgement response (<code>Basic.Ack</code>) or
a negative acknowledgement response (<code>Basic.Nack</code>).
</p>


<div class="figure">
<p><img src="img/rabbit_publisher_confirm.png" alt="rabbit_publisher_confirm.png">
</p>
</div>


<pre class="example">
Any application that has enabled Publisher Confirms should be able to receive a confirmation at any point after sending the message.
</pre>
</div>
</div>


<div id="outline-container-org5fc2e94" class="outline-5">
<h5 id="org5fc2e94"><span class="section-number-5">1.3.4.3</span> Alternate exchange</h5>
<div class="outline-text-5" id="text-1-3-4-3">

<div class="figure">
<p><img src="img/rabbit_alternate_exchange.png" alt="rabbit_alternate_exchange.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org8764cde" class="outline-5">
<h5 id="org8764cde"><span class="section-number-5">1.3.4.4</span> Transaction</h5>
<div class="outline-text-5" id="text-1-3-4-4">

<div class="figure">
<p><img src="img/rabbit_transaction.png" alt="rabbit_transaction.png">
</p>
</div>

<pre class="example">
Transaction allows publishers more control over the SEQUENCE.
If you're considering transactions as a method of delivery confirmation, consider using Publisher Confirms as a LIGHTWEIGHT alternative.
</pre>
</div>
</div>


<div id="outline-container-org7862822" class="outline-5">
<h5 id="org7862822"><span class="section-number-5">1.3.4.5</span> HA queues</h5>
<div class="outline-text-5" id="text-1-3-4-5">
<p>
Allows queues to have redundant copies across multiple servers.
</p>

<p>
HA queues have a single primary server node, and all the other nodes are secondary.
</p>

<p>
Should the primary node fail, one of the secondary nodes will take over the role of primary node. <br>
Should a secondary node be lost in an HA queue configuration, the other nodes would continue to operate as they were, sharing the state of operations that take place across all configured nodes.
</p>

<p>
When a lost node is added back, or a new node is added to the cluster, <span class="underline">it won't contain any messages that are already in the queue across the existing nodes</span>. <br>
Instead, <span class="underline">it will receive all new messages</span> and only be in sync once <i>all the previously published messages are consumed</i>.
</p>



<div class="figure">
<p><img src="img/rabbit_ha_queues.png" alt="rabbit_ha_queues.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org6f19b83" class="outline-5">
<h5 id="org6f19b83"><span class="section-number-5">1.3.4.6</span> Delivery Mode 2</h5>
<div class="outline-text-5" id="text-1-3-4-6">
<p>
In addition to <code>delivery-mode</code> of 2, for messages to truly survive a restart of a RabbitMQ broker,
your queues must be declared as <code>durable</code> when they're created.
</p>

<pre class="example">
It's a costly way to guarantee delivery.
</pre>
</div>
</div>
</div>



<div id="outline-container-org939ad25" class="outline-4">
<h4 id="org939ad25"><span class="section-number-4">1.3.5</span> Consuming message</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Consuming messages with <code>Basic.Consume</code> means your application <span class="underline">automatically</span> receives messages from RabbitMQ as they become available
until the client issues a <code>Basic.Cancel</code>.
</p>

<p>
Application needs to <span class="underline">ACKNOWLEDGE</span> the message to let RabbitMQ know the message has been processed.
</p>



<div class="figure">
<p><img src="img/rabbit_basic_consume.png" alt="rabbit_basic_consume.png">
</p>
</div>
</div>



<div id="outline-container-orge7a722e" class="outline-5">
<h5 id="orge7a722e"><span class="section-number-5">1.3.5.1</span> Consumer Tag</h5>
<div class="outline-text-5" id="text-1-3-5-1">
<p>
When your application issues <code>Basic.Consume</code>, a unique string is created that identifies the application on the open channel with RabbitMQ.
This string, called a <b>consumer tag</b>, is sent to your application with each message from RabbitMQ.
</p>

<p>
The consumer tag can be used to <span class="underline">cancel</span> any future receipt of messages from RabbitMQ by issuing a <code>Basic.Cancel</code> RPC command.
</p>
</div>
</div>


<div id="outline-container-orga0cd695" class="outline-5">
<h5 id="orga0cd695"><span class="section-number-5">1.3.5.2</span> <code>no-ack</code> argument</h5>
<div class="outline-text-5" id="text-1-3-5-2">
<p>
There's a no-ack flag with <code>Basic.Consume</code> RPC request.
When enabled, this flag tells RabbitMQ that your consumer won't acknowledge the receipt of messages and
that RabbitMQ should just send them <span class="underline">as quickly as it is able</span>.
</p>



<p>
If the <code>no_ack</code> flag is set to false, a consumer must acknowledge each message that it receives by sending a <code>Basic.Ack</code> RPC request.
</p>


<div class="figure">
<p><img src="img/rabbit_consume_ack.png" alt="rabbit_consume_ack.png">
</p>
</div>
</div>


<div id="outline-container-org4120475" class="outline-6">
<h6 id="org4120475"><span class="section-number-6">1.3.5.2.1</span> Delivery tag</h6>
<div class="outline-text-6" id="text-1-3-5-2-1">
<p>
When the <code>Basic.Ack</code> response frame is sent, the consumer must pass with it an argument from the <code>Basic.Deliver</code> method frame
called the <b>delivery tag</b>. <br>
RabbitMQ uses the <b>delivery tag</b> along with the channel as a unique identifier to communicate message acknowledgement, rejection,
and negative acknowledgement.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb9744a7" class="outline-5">
<h5 id="orgb9744a7"><span class="section-number-5">1.3.5.3</span> Prefetching (QoS)</h5>
<div class="outline-text-5" id="text-1-3-5-3">
<p>
prefetch 允许为每个 consumer 指定最大的 unacked messages 数目。
</p>

<p>
简单来说就是用来指定一个 consumer 一次可以从 RabbitMQ 中获取多少条 message 并缓存在 client 中。 <br>
一旦缓冲区满了，RabbitMQ 将会停止投递新的 message 到该 consumer 中直到它发出 ack 。
</p>

<p>
总的来说，consumer 负责不断处理消息，不断 ack ，然后只要 unacked 数少于 <code>prefetch * consumer</code> 数目，broker 就不断将消息投递过去。
</p>
</div>
</div>


<div id="outline-container-orgf89e02c" class="outline-5">
<h5 id="orgf89e02c"><span class="section-number-5">1.3.5.4</span> <code>Basic.Get</code></h5>
<div class="outline-text-5" id="text-1-3-5-4">

<div class="figure">
<p><img src="img/rabbitmq_get.png" alt="rabbitmq_get.png">
</p>
</div>

<p>
<code>Basic.Get</code> 命令会订阅消息，获得单条消息，然后取消订阅，因此效率不高。
</p>
</div>
</div>



<div id="outline-container-org854a131" class="outline-5">
<h5 id="org854a131"><span class="section-number-5">1.3.5.5</span> <code>Basic.Reject</code></h5>
<div class="outline-text-5" id="text-1-3-5-5">
<p>
This RPC carries with it the <span class="underline">delivery tag</span> created by RabbitMQ to uniquely identify the message. <br>
When a consumer rejects a message, you can instruct RabbitMQ to either <span class="underline">discard</span> the message or to <span class="underline">requeue</span> the message with the <code>requeue</code> flag.
</p>

<p>
When a message is requeued, the <code>redelivered</code> flag is set in the message, informing the message's <b>next consumer</b> that it had been previously delivered.
</p>

<pre class="example">
Basic.Reject allows for a single message to be rejected.
You can't reject multiple messages at the same time using Basic.Reject.
</pre>
</div>
</div>


<div id="outline-container-orgbb47d3d" class="outline-5">
<h5 id="orgbb47d3d"><span class="section-number-5">1.3.5.6</span> <code>Basic.Nack</code></h5>
<div class="outline-text-5" id="text-1-3-5-6">
<p>
<code>Basic.Nack</code> method implements <span class="underline">the same behavior</span> as the <code>Basic.Reject</code>, but it adds "multiple-reject" behavior.
</p>
</div>
</div>


<div id="outline-container-orgb88a167" class="outline-5">
<h5 id="orgb88a167"><span class="section-number-5">1.3.5.7</span> Dead letter exchanges</h5>
<div class="outline-text-5" id="text-1-3-5-7">
<p>
Dead letter exchange is actually a normal exchange.
</p>

<p>
The only thing that makes an exchange a dead-letter exchange is the declared use of the exchange for rejected messages <span class="underline">when creating a queue</span>. <br>
Upon rejecting a message that isn't requeued, RabbitMQ will route the message to the exchanged specified in the queue's <code>x-dead-letter-exchange</code> argument.
</p>

<pre class="example">
Dead-letter exchanges AREN'T THE SAME AS the alternate exchanges.
An expired or rejected message is delivered via a dead-letter exchange,
whereas an alternate exchange routes messages that otherwise couldn't be routed by RabbitMQ.
</pre>


<div class="figure">
<p><img src="img/rabbit_dlx.png" alt="rabbit_dlx.png">
</p>
</div>


<p>
We can use the same exchange for dead-lettered messages as non-dead-lettered messages
<span class="underline">but to ensure that the dead-lettered messages aren't delivered to the same queue</span>. <br>
Set <code>x-dead-letter-routing-key</code>  when declaring the queue.
</p>
</div>
</div>
</div>




<div id="outline-container-orgc49d70d" class="outline-4">
<h4 id="orgc49d70d"><span class="section-number-4">1.3.6</span> <code>Basic.Properties</code></h4>
<div class="outline-text-4" id="text-1-3-6">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">For use by</th>
<th scope="col" class="org-left">Suggested or specified use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">app-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">Useful for defining the application publishing the messages.</td>
</tr>

<tr>
<td class="org-left">content-encoding</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">Specify whether your message body is encoded in some special way, such as zlib, deflate, or Base64.</td>
</tr>

<tr>
<td class="org-left">content-type</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">If the message is in reference to some other message or uniquely identifiable item, the correlation-id is a good way to indicate what the message is referencing.</td>
</tr>

<tr>
<td class="org-left">delivery-mode</td>
<td class="org-left">octet</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">A value of 1 tells RabbitMQ it can keep the message in memory; 2 indicates it should also write it to disk.</td>
</tr>

<tr>
<td class="org-left">expiration</td>
<td class="org-left">short-string</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">An epoch or Unix timestamp value as a text string that indicates when the message should expire.</td>
</tr>

<tr>
<td class="org-left">headers</td>
<td class="org-left">table</td>
<td class="org-left">Both</td>
<td class="org-left">A free-form key/value table that you can use to add additional metadata about your mes- sage; RabbitMQ can route based upon this if desired.</td>
</tr>

<tr>
<td class="org-left">message-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">A unique identifier such as a UUID that your application can use to identify the message.</td>
</tr>

<tr>
<td class="org-left">priority</td>
<td class="org-left">octet</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">A property for priority ordering in queues.</td>
</tr>

<tr>
<td class="org-left">timestamp</td>
<td class="org-left">timestamp</td>
<td class="org-left">Application</td>
<td class="org-left">An epoch or Unix timestamp value that can be used to indicate when the message was created.</td>
</tr>

<tr>
<td class="org-left">type</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">A text string your application can use to describe the message type or payload.</td>
</tr>

<tr>
<td class="org-left">user-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Both</td>
<td class="org-left">A free-form string that, if used, RabbitMQ will validate against the connected user and drop messages if they don't match.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>









<div id="outline-container-orgfff9015" class="outline-2">
<h2 id="orgfff9015"><span class="section-number-2">2</span> 交换器</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgd91712f" class="outline-3">
<h3 id="orgd91712f"><span class="section-number-3">2.1</span> 属性</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Name</li>
<li>Durability (exchanges survive broker restart)</li>
<li>Auto-delete (exchange is deleted when last queue is unbound from it)</li>
<li>Arguments (optional, used by plugins and broker-specific features)</li>
</ul>
</div>
</div>

<div id="outline-container-org45a8919" class="outline-3">
<h3 id="org45a8919"><span class="section-number-3">2.2</span> direct</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如果路由键匹配的话，消息就被投递到对应的队列。
</p>

<p>
RabbitMq 会默认实现一个类型为 direct 的，名称为空白字符串的交换器。
当声明一个队列时，一开始该队列会自动绑定到默认交换器， <b>并以队列名称作为路由键</b> 。
之后可以发送 <code>exchange.declare</code> 命令并设置合适的参数，就可以升级成具体类型交换器。
</p>


<div id="org2b256f1" class="figure">
<p><img src="img/direct-router.png" alt="direct-router.png">
</p>
<p><span class="figure-number">Figure 19: </span>direct router</p>
</div>
</div>
</div>


<div id="outline-container-org77cd312" class="outline-3">
<h3 id="org77cd312"><span class="section-number-3">2.3</span> fanout</h3>
<div class="outline-text-3" id="text-2-3">
<p>
将收到的消息广播的绑定的队列上。
</p>


<div id="orgc99cda7" class="figure">
<p><img src="img/fanout-router.png" alt="fanout-router.png">
</p>
<p><span class="figure-number">Figure 20: </span>fanout router</p>
</div>
</div>
</div>


<div id="outline-container-orgac5f9d8" class="outline-3">
<h3 id="orgac5f9d8"><span class="section-number-3">2.4</span> topic</h3>
<div class="outline-text-3" id="text-2-4">

<div id="orge948926" class="figure">
<p><img src="img/topic-router.png" alt="topic-router.png">
</p>
<p><span class="figure-number">Figure 21: </span>topic router</p>
</div>

<ul class="org-ul">
<li><code>.</code> 把路由键分为了几部分</li>
<li><code>*</code> 匹配特定位置的任意文本</li>
<li><code>#</code> 匹配所有规则</li>
</ul>
</div>
</div>


<div id="outline-container-orgf55376f" class="outline-3">
<h3 id="orgf55376f"><span class="section-number-3">2.5</span> 路由</h3>
<div class="outline-text-3" id="text-2-5">
<img src="http://javasampleapproach.com/wp-content/uploads/2017/10/springboot-rabbitmq-exchange-to-exchange-architecture.png"/>
</div>
</div>
</div>


<div id="outline-container-org146a838" class="outline-2">
<h2 id="org146a838"><span class="section-number-2">3</span> RabbitMQ 管理</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org524c307" class="outline-3">
<h3 id="org524c307"><span class="section-number-3">3.1</span> 日志</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a href="https://www.rabbitmq.com/logging.html">RabbitMQ Logging</a>
</p>
</div>
</div>



<div id="outline-container-orgd1bbd62" class="outline-3">
<h3 id="orgd1bbd62"><span class="section-number-3">3.2</span> 配置文件</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code>/etc/rabbitmq/rabbitmq.config</code>
</p>
</div>
</div>


<div id="outline-container-orgb3a44b1" class="outline-3">
<h3 id="orgb3a44b1"><span class="section-number-3">3.3</span> 接入 Eshell</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<code>erl -setcookie &lt;cookie&gt; -name test@&lt;node-name&gt; -remsh rabbit@&lt;node-name&gt; -hidden</code>
</p>

<p>
退出时要用 <code>Ctrl+G</code> 然后执行 <b>q</b> 命令退出。
</p>

<div class="org-src-container">
<pre class="src src-erlang">spawn(fun() -&gt; etop:start([{output, text}, {interval, 5}, {lines, 10}, {sort, msg_q}]) end).

spawn(fun() -&gt; etop:start([{output, text}, {interval, 5}, {lines, 10}, {sort, reductions}]) end).
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org546ffe2" class="outline-2">
<h2 id="org546ffe2"><span class="section-number-2">4</span> 代码示例</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org48b36f8" class="outline-3">
<h3 id="org48b36f8"><span class="section-number-3">4.1</span> 基本用法</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgc98e764" class="outline-4">
<h4 id="orgc98e764"><span class="section-number-4">4.1.1</span> 生产者</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)  <span style="color: #465457;"># </span><span style="color: #465457;">&#20351;&#29992;&#40664;&#35748; vhost /</span>
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

channel.exchange_declare(exchange=EXCHANGE,
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

<span style="color: #fd971f;">msg_props</span> = pika.BasicProperties()
<span style="color: #fd971f;">msg_props.content_type</span> = <span style="color: #e6db74;">'text/plain'</span>

channel.basic_publish(exchange=EXCHANGE,
                      properties=msg_props,
                      body=<span style="color: #e6db74;">'Hello World'</span>,
                      routing_key=<span style="color: #e6db74;">'hola'</span>)

conn_broker.close()
</pre>
</div>
</div>
</div>


<div id="outline-container-org51c46a3" class="outline-4">
<h4 id="org51c46a3"><span class="section-number-4">4.1.2</span> 消费者</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>
<span style="color: #fd971f;">QUEUE</span> = <span style="color: #e6db74;">'hello-exchange'</span>
<span style="color: #fd971f;">TAG</span> = <span style="color: #e6db74;">'hello-consumer'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

channel.exchange_declare(exchange=EXCHANGE,  <span style="color: #465457;"># </span><span style="color: #465457;">&#22914;&#26524;&#27809;&#26377;&#23601;&#21019;&#24314;&#65292;&#21542;&#21017;&#32487;&#32493;</span>
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

channel.queue_declare(queue=QUEUE)

channel.queue_bind(queue=QUEUE,
                   exchange=EXCHANGE,
                   routing_key=<span style="color: #e6db74;">'hola'</span>)

<span style="color: #f92672; font-weight: bold;">def</span> <span style="color: #a6e22e;">msg_consumer</span>(channel, method, header, body):
    channel.basic_ack(delivery_tag=method.delivery_tag)
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"receive: {}"</span>.<span style="color: #a6e22e;">format</span>(body))
    channel.basic_cancel(consumer_tag=TAG)
    channel.stop_consuming()


channel.basic_consume(msg_consumer,
                      queue=QUEUE,
                      consumer_tag=TAG) <span style="color: #465457;"># </span><span style="color: #465457;">&#19968;&#20010; channel &#21487;&#20197;&#26377;&#22810;&#20010;&#35746;&#38405;&#65292;&#20351;&#29992; consumer_tag &#26469;&#26631;&#35782;&#35746;&#38405;</span>


<span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">' [*] Waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org334bb11" class="outline-3">
<h3 id="org334bb11"><span class="section-number-3">4.2</span> 发送方确认模式</h3>
<div class="outline-text-3" id="text-4-2">
<p>
信道进入 confirm 模式，所有在信道上发布的消息都会被指派一个唯一的 ID 号（从 1 开始）。
一旦消息被投递给所有匹配队列后，信道会发送一个发送方确认模式给生产者应用程序（包含消息的唯一 ID ）。
这使得生产者知晓信息已经安全到达目的队列了。
</p>
</div>


<div id="outline-container-org18357aa" class="outline-4">
<h4 id="org18357aa"><span class="section-number-4">4.2.1</span> 生产者</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #465457;">#</span><span style="color: #465457;">! /usr/bin/env python3</span>
<span style="color: #465457;"># </span><span style="color: #465457;">-*- coding: utf-8 -*-</span>

<span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)  <span style="color: #465457;"># </span><span style="color: #465457;">&#20351;&#29992;&#40664;&#35748; vhost /</span>
<span style="color: #fd971f;">channel</span> = conn_broker.channel()
channel.confirm_delivery()
channel.exchange_declare(exchange=EXCHANGE,
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

<span style="color: #fd971f;">msg_props</span> = pika.BasicProperties()
<span style="color: #fd971f;">msg_props.content_type</span> = <span style="color: #e6db74;">'text/plain'</span>

<span style="color: #fd971f;">ack</span> = channel.basic_publish(exchange=EXCHANGE,
                            properties=msg_props,
                            body=<span style="color: #e6db74;">'Hello World'</span>,
                            routing_key=<span style="color: #e6db74;">'hola'</span>)

<span style="color: #f92672; font-weight: bold;">if</span> ack:
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"confirm received"</span>)
<span style="color: #f92672; font-weight: bold;">else</span>:
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"msg lost"</span>)

conn_broker.close()
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org043945d" class="outline-3">
<h3 id="org043945d"><span class="section-number-3">4.3</span> 通过 AMQP 实时访问日志</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #465457;">#</span><span style="color: #465457;">! /usr/bin/env python3</span>
<span style="color: #465457;"># </span><span style="color: #465457;">-*- coding: utf-8 -*-</span>

<span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'amq.rabbitmq.log'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

<span style="color: #fd971f;">result</span> = channel.queue_declare(exclusive=<span style="color: #ae81ff;">True</span>, auto_delete=<span style="color: #ae81ff;">True</span>)
<span style="color: #fd971f;">queue_name</span> = result.method.queue

<span style="color: #465457;"># </span><span style="color: #465457;">binding_keys = ['info', 'warning', 'error']</span>
<span style="color: #fd971f;">binding_keys</span> = [<span style="color: #e6db74;">'#'</span>]

<span style="color: #f92672; font-weight: bold;">for</span> binding_key <span style="color: #f92672; font-weight: bold;">in</span> binding_keys:
    channel.queue_bind(queue=queue_name,
                       exchange=EXCHANGE,
                       routing_key=binding_key)

<span style="color: #f92672; font-weight: bold;">def</span> <span style="color: #a6e22e;">msg_consumer</span>(channel, method, header, body):
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"[{}]: {}"</span>.<span style="color: #a6e22e;">format</span>(method.routing_key, body.decode(<span style="color: #e6db74;">'utf-8'</span>)), end=<span style="color: #e6db74;">''</span>)


channel.basic_consume(msg_consumer,
                      queue=queue_name,
                      no_ack=<span style="color: #ae81ff;">True</span>)

channel.start_consuming()

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org547a2cd" class="outline-2">
<h2 id="org547a2cd"><span class="section-number-2">5</span> 集群</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org7d062e6" class="outline-3">
<h3 id="org7d062e6"><span class="section-number-3">5.1</span> Architecture</h3>
<div class="outline-text-3" id="text-5-1">
<p>
At all times RabbitMQ is keeping track of four kinds of internal metadata:
</p>

<ul class="org-ul">
<li>Queue metadata</li>
</ul>

<p>
Queue names and their properties (durable or auto-delete)
</p>
<ul class="org-ul">
<li><p>
Exchange metadata
</p>

<p>
The exchange's name, the type of exchange it is, and what the properties are (durable and so on)
</p></li>
<li><p>
Binding metadata
</p>

<p>
A simple table showing how to route messages to queues
</p></li>
<li><p>
Vhost metadata
</p>

<p>
Namespacing and security attributes for the queues, exchanges, and bindings within a vhost
</p></li>

<li>Node location meatadata (clustering only)</li>
</ul>


<p>
RabbitMQ stores all of this information <span class="underline">in memory</span> while writing it to disk for any queues and exchanges (and their bindings) marked <b>durable</b>.
</p>
</div>


<div id="outline-container-orgcbf86f4" class="outline-4">
<h4 id="orgcbf86f4"><span class="section-number-4">5.1.1</span> Queue in cluster</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
By default, not every node in cluster has a full copy of every queue.
</p>


<div class="figure">
<p><img src="img/rabbit_cluster.png" alt="rabbit_cluster.png">
</p>
</div>

<pre class="example">
If the queues being recreated were marked as durable, redeclaring them from another node will get you an ugly 404 NOT_FOUND error.
This ensures messages in that queue on the failed node don't disappear when you restore it to the cluster.
</pre>
</div>
</div>

<div id="outline-container-org333d1db" class="outline-4">
<h4 id="org333d1db"><span class="section-number-4">5.1.2</span> Exchange in cluster</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Actually, exchanges are just a name and a list of queue bindings. <br>
The <b>channel</b> does the actual routing of the message to the queue as specified by the matching binding.
</p>


<div class="figure">
<p><img src="img/rabbit_cluster_exchange.png" alt="rabbit_cluster_exchange.png">
</p>
</div>
</div>
</div>

<div id="outline-container-orgb6049ab" class="outline-4">
<h4 id="orgb6049ab"><span class="section-number-4">5.1.3</span> RAM/DISK node</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
When nodes join or leave a cluster, they need to be able to notify <b>at least one</b> disk node of the change.
</p>

<p>
If you only have one disk node and that node happens to be down, your cluster can continue to route messages but you can't do any of the following:
</p>

<ul class="org-ul">
<li>Create queues</li>
<li>Create exchanges</li>
<li>Create bindings</li>
<li>Add users</li>
<li>Change permissions</li>
<li>Add or remove cluster nodes</li>
</ul>

<pre class="example">
The only meatadata RAM nodes store to disk are the addresses of disk nodes in the cluster.
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org81a1538" class="outline-2">
<h2 id="org81a1538"><span class="section-number-2">6</span> 持久性</h2>
<div class="outline-text-2" id="text-6">
<p>
RabbitMQ 支持消息的持久化，也就是数据写在磁盘上。消息队列持久化包括 3 个部分：
</p>

<ul class="org-ul">
<li>exchange 持久化，在声明时指定 <code>durable=1</code></li>
<li>queue 持久化，在声明时指定 <code>durable=1</code></li>
<li>消息持久化，在投递时指定 <code>delivery_mode=2</code> （1 是非持久化）</li>
</ul>


<p>
如果 exchange 和 queue 都是持久化的， <b>那么它们之间的 binding 也是持久化的</b> 。
</p>

<p>
如果 exchange 和 queue 两者之间有一个持久化，一个非持久化，其对应的 binding 就无法得到恢复。
</p>

<p>
但是，即使设置了持久化，也不能百分百保证消息不会丢失。有很小的概率在 RabbitMQ 接受到消息后，还没来得及写到磁盘，就发生重启了。
另外，RabbitMQ 也不会对每一个消息执行 <code>fsync(2)</code> ，消息可能仅仅写入到缓存，还没来得及 flush 到硬件存储。
因此 RabbitMQ 的持久性设置并非足够安全，对于普通的工作队列也许够用了。
如果需要加强的安全保证，可以把发布消息的代码封装在 <b>事务</b> 里。
</p>
</div>
</div>
</div>
</body>
</html>