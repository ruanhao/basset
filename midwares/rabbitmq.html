<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-05-14 Tue 18:00 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RabbitMQ</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Hao Ruan">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
<link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">RabbitMQ</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6384e22">1. AMQP</a>
<ul>
<li><a href="#org4b87bce">1.1. AMQP Frame</a>
<ul>
<li><a href="#orgc59b5d6">1.1.1. Frame Types</a>
<ul>
<li><a href="#org769671f">1.1.1.1. Method frame</a></li>
<li><a href="#orgd10f095">1.1.1.2. Content header frame</a></li>
<li><a href="#org24ea523">1.1.1.3. Body frame</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf109325">1.2. AMQP Model</a></li>
<li><a href="#org9ea3aba">1.3. Protocol Implement</a>
<ul>
<li><a href="#orgf5ce879">1.3.1. Declaring exchange</a></li>
<li><a href="#org4e2b888">1.3.2. Declaring queue</a></li>
<li><a href="#org41af4cd">1.3.3. Binding queue to exchange</a></li>
<li><a href="#org5132512">1.3.4. Publishing message</a>
<ul>
<li><a href="#orgbab0b4d">1.3.4.1. <code>mandatory</code> flag</a></li>
<li><a href="#org946727c">1.3.4.2. Publisher Confirm</a></li>
<li><a href="#orgb2f1322">1.3.4.3. Alternate exchange</a></li>
<li><a href="#org2918113">1.3.4.4. Transaction</a></li>
<li><a href="#orgaa43970">1.3.4.5. HA queues</a></li>
<li><a href="#orgdcef4a6">1.3.4.6. Delivery Mode 2</a></li>
</ul>
</li>
<li><a href="#orgdc28493">1.3.5. Consuming message</a>
<ul>
<li><a href="#org44943f9">1.3.5.1. Consumer Tag</a></li>
<li><a href="#org9d2e82b">1.3.5.2. <code>no-ack</code> argument</a>
<ul>
<li><a href="#org6fc0b2e">1.3.5.2.1. Delivery tag</a></li>
</ul>
</li>
<li><a href="#org5855fc2">1.3.5.3. Prefetching (QoS)</a></li>
<li><a href="#org837c7cd">1.3.5.4. <code>Basic.Get</code></a></li>
<li><a href="#org4793bf4">1.3.5.5. <code>Basic.Reject</code></a></li>
<li><a href="#org6c0e3df">1.3.5.6. <code>Basic.Nack</code></a></li>
<li><a href="#org7af365e">1.3.5.7. Dead letter exchanges</a></li>
</ul>
</li>
<li><a href="#org096c73c">1.3.6. <code>Basic.Properties</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org935027e">2. 交换器</a>
<ul>
<li><a href="#org10c1e99">2.1. 属性</a></li>
<li><a href="#org68de37f">2.2. direct</a></li>
<li><a href="#org329369d">2.3. fanout</a></li>
<li><a href="#org0dd0f69">2.4. topic</a></li>
<li><a href="#orgd1c2e60">2.5. 路由</a></li>
</ul>
</li>
<li><a href="#org85dbe2c">3. RabbitMQ 管理</a>
<ul>
<li><a href="#org6318b55">3.1. 启动停止</a>
<ul>
<li><a href="#org4ffc3b0">3.1.1. 停止节点</a></li>
<li><a href="#org0ff2b0d">3.1.2. 停止应用</a></li>
</ul>
</li>
<li><a href="#org22188e2">3.2. 配置文件</a></li>
<li><a href="#orgbe93e29">3.3. 管理用户</a>
<ul>
<li><a href="#org518782f">3.3.1. 创建</a></li>
<li><a href="#org698a3f7">3.3.2. 删除</a></li>
<li><a href="#org877feac">3.3.3. 修改密码</a></li>
<li><a href="#org8a6fe92">3.3.4. 查看</a></li>
</ul>
</li>
<li><a href="#orge2ba20a">3.4. 管理权限</a>
<ul>
<li><a href="#org2d249d5">3.4.1. 创建</a></li>
<li><a href="#org4e30cb2">3.4.2. 删除</a></li>
<li><a href="#org7325770">3.4.3. 查看</a></li>
</ul>
</li>
<li><a href="#orgadf9382">3.5. 管理 vhost</a></li>
<li><a href="#orga2c8698">3.6. 信息查询</a>
<ul>
<li><a href="#org771fcb9">3.6.1. 查看队列</a></li>
<li><a href="#org5805197">3.6.2. 查看交换器</a></li>
<li><a href="#org8469b20">3.6.3. 查看绑定信息</a></li>
<li><a href="#org032664b">3.6.4. 查看集群状态</a></li>
<li><a href="#orge384dc0">3.6.5. 接入 Eshell</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1a98d08">4. 代码示例</a>
<ul>
<li><a href="#orge47e740">4.1. 基本用法</a>
<ul>
<li><a href="#org1b12efd">4.1.1. 生产者</a></li>
<li><a href="#org7e39d52">4.1.2. 消费者</a></li>
</ul>
</li>
<li><a href="#org389c1d7">4.2. 发送方确认模式</a>
<ul>
<li><a href="#org5101496">4.2.1. 生产者</a></li>
</ul>
</li>
<li><a href="#orgfaaa2ee">4.3. 通过 AMQP 实时访问日志</a></li>
</ul>
</li>
<li><a href="#org154c449">5. 集群</a>
<ul>
<li><a href="#orgd8719cb">5.1. Architecture</a>
<ul>
<li><a href="#orgf5e6559">5.1.1. Queue in cluster</a></li>
<li><a href="#org4898350">5.1.2. Exchange in cluster</a></li>
<li><a href="#org16f9fba">5.1.3. RAM/DISK node</a></li>
</ul>
</li>
<li><a href="#org13b17ea">5.2. 集群管理</a>
<ul>
<li><a href="#org2cb4b28">5.2.1. 清空节点元数据（重设）</a></li>
<li><a href="#org388dd15">5.2.2. 加入集群</a></li>
<li><a href="#orgdec4153">5.2.3. 查看集群信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org86149d0">6. 持久性</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="meta">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Author</td>
<td class="org-left">Hao Ruan (haoru@cisco.com)</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">2019-05-14 18:00:15</td>
</tr>
</tbody>
</table>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6384e22">1. AMQP</a>
<ul>
<li><a href="#org4b87bce">1.1. AMQP Frame</a>
<ul>
<li><a href="#orgc59b5d6">1.1.1. Frame Types</a>
<ul>
<li><a href="#org769671f">1.1.1.1. Method frame</a></li>
<li><a href="#orgd10f095">1.1.1.2. Content header frame</a></li>
<li><a href="#org24ea523">1.1.1.3. Body frame</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf109325">1.2. AMQP Model</a></li>
<li><a href="#org9ea3aba">1.3. Protocol Implement</a>
<ul>
<li><a href="#orgf5ce879">1.3.1. Declaring exchange</a></li>
<li><a href="#org4e2b888">1.3.2. Declaring queue</a></li>
<li><a href="#org41af4cd">1.3.3. Binding queue to exchange</a></li>
<li><a href="#org5132512">1.3.4. Publishing message</a>
<ul>
<li><a href="#orgbab0b4d">1.3.4.1. <code>mandatory</code> flag</a></li>
<li><a href="#org946727c">1.3.4.2. Publisher Confirm</a></li>
<li><a href="#orgb2f1322">1.3.4.3. Alternate exchange</a></li>
<li><a href="#org2918113">1.3.4.4. Transaction</a></li>
<li><a href="#orgaa43970">1.3.4.5. HA queues</a></li>
<li><a href="#orgdcef4a6">1.3.4.6. Delivery Mode 2</a></li>
</ul>
</li>
<li><a href="#orgdc28493">1.3.5. Consuming message</a>
<ul>
<li><a href="#org44943f9">1.3.5.1. Consumer Tag</a></li>
<li><a href="#org9d2e82b">1.3.5.2. <code>no-ack</code> argument</a>
<ul>
<li><a href="#org6fc0b2e">1.3.5.2.1. Delivery tag</a></li>
</ul>
</li>
<li><a href="#org5855fc2">1.3.5.3. Prefetching (QoS)</a></li>
<li><a href="#org837c7cd">1.3.5.4. <code>Basic.Get</code></a></li>
<li><a href="#org4793bf4">1.3.5.5. <code>Basic.Reject</code></a></li>
<li><a href="#org6c0e3df">1.3.5.6. <code>Basic.Nack</code></a></li>
<li><a href="#org7af365e">1.3.5.7. Dead letter exchanges</a></li>
</ul>
</li>
<li><a href="#org096c73c">1.3.6. <code>Basic.Properties</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org935027e">2. 交换器</a>
<ul>
<li><a href="#org10c1e99">2.1. 属性</a></li>
<li><a href="#org68de37f">2.2. direct</a></li>
<li><a href="#org329369d">2.3. fanout</a></li>
<li><a href="#org0dd0f69">2.4. topic</a></li>
<li><a href="#orgd1c2e60">2.5. 路由</a></li>
</ul>
</li>
<li><a href="#org85dbe2c">3. RabbitMQ 管理</a>
<ul>
<li><a href="#org6318b55">3.1. 启动停止</a>
<ul>
<li><a href="#org4ffc3b0">3.1.1. 停止节点</a></li>
<li><a href="#org0ff2b0d">3.1.2. 停止应用</a></li>
</ul>
</li>
<li><a href="#org22188e2">3.2. 配置文件</a></li>
<li><a href="#orgbe93e29">3.3. 管理用户</a>
<ul>
<li><a href="#org518782f">3.3.1. 创建</a></li>
<li><a href="#org698a3f7">3.3.2. 删除</a></li>
<li><a href="#org877feac">3.3.3. 修改密码</a></li>
<li><a href="#org8a6fe92">3.3.4. 查看</a></li>
</ul>
</li>
<li><a href="#orge2ba20a">3.4. 管理权限</a>
<ul>
<li><a href="#org2d249d5">3.4.1. 创建</a></li>
<li><a href="#org4e30cb2">3.4.2. 删除</a></li>
<li><a href="#org7325770">3.4.3. 查看</a></li>
</ul>
</li>
<li><a href="#orgadf9382">3.5. 管理 vhost</a></li>
<li><a href="#orga2c8698">3.6. 信息查询</a>
<ul>
<li><a href="#org771fcb9">3.6.1. 查看队列</a></li>
<li><a href="#org5805197">3.6.2. 查看交换器</a></li>
<li><a href="#org8469b20">3.6.3. 查看绑定信息</a></li>
<li><a href="#org032664b">3.6.4. 查看集群状态</a></li>
<li><a href="#orge384dc0">3.6.5. 接入 Eshell</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1a98d08">4. 代码示例</a>
<ul>
<li><a href="#orge47e740">4.1. 基本用法</a>
<ul>
<li><a href="#org1b12efd">4.1.1. 生产者</a></li>
<li><a href="#org7e39d52">4.1.2. 消费者</a></li>
</ul>
</li>
<li><a href="#org389c1d7">4.2. 发送方确认模式</a>
<ul>
<li><a href="#org5101496">4.2.1. 生产者</a></li>
</ul>
</li>
<li><a href="#orgfaaa2ee">4.3. 通过 AMQP 实时访问日志</a></li>
</ul>
</li>
<li><a href="#org154c449">5. 集群</a>
<ul>
<li><a href="#orgd8719cb">5.1. Architecture</a>
<ul>
<li><a href="#orgf5e6559">5.1.1. Queue in cluster</a></li>
<li><a href="#org4898350">5.1.2. Exchange in cluster</a></li>
<li><a href="#org16f9fba">5.1.3. RAM/DISK node</a></li>
</ul>
</li>
<li><a href="#org13b17ea">5.2. 集群管理</a>
<ul>
<li><a href="#org2cb4b28">5.2.1. 清空节点元数据（重设）</a></li>
<li><a href="#org388dd15">5.2.2. 加入集群</a></li>
<li><a href="#orgdec4153">5.2.3. 查看集群信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org86149d0">6. 持久性</a></li>
</ul>
</div>
</div>


<div id="outline-container-org6384e22" class="outline-2">
<h2 id="org6384e22"><span class="section-number-2">1</span> AMQP</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4b87bce" class="outline-3">
<h3 id="org4b87bce"><span class="section-number-3">1.1</span> AMQP Frame</h3>
<div class="outline-text-3" id="text-1-1">
<p>
AMQP uses <span class="underline">classes</span> and <span class="underline">methods</span>, referred to as <b>AMQP commands</b>, to create a common language between clients and servers.
</p>


<div class="figure">
<p><img src="img/rabbit_frame.png" alt="rabbit_frame.png">
</p>
</div>


<div class="figure">
<p><img src="img/rabbit_frame2.png" alt="rabbit_frame2.png">
</p>
</div>
</div>

<div id="outline-container-orgc59b5d6" class="outline-4">
<h4 id="orgc59b5d6"><span class="section-number-4">1.1.1</span> Frame Types</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The AMQP specification defines five types of frames:
</p>

<ul class="org-ul">
<li>Protocol header frame
Only used once, when connecting to RabbitMQ.</li>
<li>Method frame
Carries with it the RPC request or response that's being sent to or received from RabbitMQ.</li>
<li>Content header frame
Contains the size and properties for a message.</li>
<li>Body frames
Contain the content of messages.</li>
<li>Heartbeat frame
Sent to and from RabbitMQ as a check to ensure that both sides of the connection are available and working properly.</li>
</ul>
</div>

<div id="outline-container-org769671f" class="outline-5">
<h5 id="org769671f"><span class="section-number-5">1.1.1.1</span> Method frame</h5>
<div class="outline-text-5" id="text-1-1-1-1">

<div class="figure">
<p><img src="img/rabbit_method_frame.png" alt="rabbit_method_frame.png">
</p>
</div>
</div>
</div>


<div id="outline-container-orgd10f095" class="outline-5">
<h5 id="orgd10f095"><span class="section-number-5">1.1.1.2</span> Content header frame</h5>
<div class="outline-text-5" id="text-1-1-1-2">

<div class="figure">
<p><img src="img/rabbit_content_header_frame.png" alt="rabbit_content_header_frame.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org24ea523" class="outline-5">
<h5 id="org24ea523"><span class="section-number-5">1.1.1.3</span> Body frame</h5>
<div class="outline-text-5" id="text-1-1-1-3">

<div class="figure">
<p><img src="img/rabbit_body_frame.png" alt="rabbit_body_frame.png">
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf109325" class="outline-3">
<h3 id="orgf109325"><span class="section-number-3">1.2</span> AMQP Model</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The AMQ model logically defines three abstract components in broker software that define the routing behavior of messages:
</p>

<ul class="org-ul">
<li>Exchange
The component of the message broker that routes messages to queues</li>
<li>Queue
A data structure on disk or in memory that stores messages</li>
<li>Binding
A rule that tells the exchange which queue the messages should be stored in</li>
</ul>
</div>
</div>


<div id="outline-container-org9ea3aba" class="outline-3">
<h3 id="org9ea3aba"><span class="section-number-3">1.3</span> Protocol Implement</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgf5ce879" class="outline-4">
<h4 id="orgf5ce879"><span class="section-number-4">1.3.1</span> Declaring exchange</h4>
<div class="outline-text-4" id="text-1-3-1">

<div class="figure">
<p><img src="img/rabbit_declare_exchange.png" alt="rabbit_declare_exchange.png">
</p>
</div>


<p>
If, for whatever reason, the command should fail, RabbitMQ will close the channel by sending a <code>Channel.Close</code> command. <br>
This response will include a numeric reply code and text value indicating why the <code>Exchange.Declare</code> failed and the channel was closed.
</p>
</div>
</div>

<div id="outline-container-org4e2b888" class="outline-4">
<h4 id="org4e2b888"><span class="section-number-4">1.3.2</span> Declaring queue</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">
<pre class="src src-plantuml">hide footbox
participant "Client" as c
database RabbitMQ as r

c -&gt; r : Queue.Declare
note right
exclusive:    设置私有队列，用于限制只有一个消费者的情况
auto-delete:  当最后一个消费者取消订阅的时候，队列自动移除
passive=true: 当队列存在，成功返回，否则返回错误，用于检测队列是否存在
end note
r --&gt; c : Queue.DeclareOk
</pre>
</div>


<ul class="org-ul">
<li>消费者和生产者都能使用 <code>Queue.Delare</code> 命令来创建队列。</li>
<li>如果消费者在同一信道上已订阅了另一个信道的话，则无法再声明队列了，必须先取消订阅。</li>
<li>当创建队列时，可以指定队列名称，如果不指定的话，RabbitMQ 会分配一个随机名称并在 <code>Queue.Declare</code> 命令的响应中返回。</li>
<li>如果需要临时队列只为一个消费者服务的话，可以结合使用 <code>auto-delete</code> 和 <code>exclusive</code> ，当消费者断开连接时，队列就被移除了。</li>
<li>发出去的消息如果路由到了不存在的队列的话，RabbitMQ 会忽略它们。因此，一般情况下，生产者和消费者都应该尝试创建队列。</li>
<li>Should the <code>Queue.Declare</code> command fail, the channel will be <span class="underline">closed</span>.</li>
</ul>

<pre class="example">
When declaring a queue, there's no harm in issuing the same Queue.Declare command more than once.
RabbitMQ will consider subsequent queue declares to be PASSIVE and will return useful information about the queue,
such as the number of pending messages in the queue and the number of consumers subscribed to it.
</pre>
</div>
</div>


<div id="outline-container-org41af4cd" class="outline-4">
<h4 id="org41af4cd"><span class="section-number-4">1.3.3</span> Binding queue to exchange</h4>
<div class="outline-text-4" id="text-1-3-3">

<div class="figure">
<p><img src="img/rabbit_bind_queue.png" alt="rabbit_bind_queue.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org5132512" class="outline-4">
<h4 id="org5132512"><span class="section-number-4">1.3.4</span> Publishing message</h4>
<div class="outline-text-4" id="text-1-3-4">

<div class="figure">
<p><img src="img/rabbit_publish_msg.png" alt="rabbit_publish_msg.png">
</p>
</div>
</div>


<div id="outline-container-orgbab0b4d" class="outline-5">
<h5 id="orgbab0b4d"><span class="section-number-5">1.3.4.1</span> <code>mandatory</code> flag</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<p>
The <code>mandatory</code> flag is an argument that's passed along with the <code>Basic.Publish</code> RPC command and tells RabbitMQ that if a message isn't routable,
it should send the message back to the publisher via a <code>Basic.Return</code> RPC.
</p>


<div class="figure">
<p><img src="img/rabbit_publish_with_mandatory.png" alt="rabbit_publish_with_mandatory.png">
</p>
</div>
</div>
</div>



<div id="outline-container-org946727c" class="outline-5">
<h5 id="org946727c"><span class="section-number-5">1.3.4.2</span> Publisher Confirm</h5>
<div class="outline-text-5" id="text-1-3-4-2">
<p>
Prior to publishing any messages, a message publisher must issue a <code>Confirm.Select</code> RPC request to RabbitMQ and
wait for a <code>Confirm.SelectOk</code> response to know that delivery confirmations are enabled.
</p>

<p>
For each message that a publisher sends to RabbitMQ, the server will respond with an acknowledgement response (<code>Basic.Ack</code>) or
a negative acknowledgement response (<code>Basic.Nack</code>).
</p>


<div class="figure">
<p><img src="img/rabbit_publisher_confirm.png" alt="rabbit_publisher_confirm.png">
</p>
</div>


<pre class="example">
Any application that has enabled Publisher Confirms should be able to receive a confirmation at any point after sending the message.
</pre>
</div>
</div>


<div id="outline-container-orgb2f1322" class="outline-5">
<h5 id="orgb2f1322"><span class="section-number-5">1.3.4.3</span> Alternate exchange</h5>
<div class="outline-text-5" id="text-1-3-4-3">

<div class="figure">
<p><img src="img/rabbit_alternate_exchange.png" alt="rabbit_alternate_exchange.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org2918113" class="outline-5">
<h5 id="org2918113"><span class="section-number-5">1.3.4.4</span> Transaction</h5>
<div class="outline-text-5" id="text-1-3-4-4">

<div class="figure">
<p><img src="img/rabbit_transaction.png" alt="rabbit_transaction.png">
</p>
</div>

<pre class="example">
Transaction allows publishers more control over the SEQUENCE.
If you're considering transactions as a method of delivery confirmation, consider using Publisher Confirms as a LIGHTWEIGHT alternative.
</pre>
</div>
</div>


<div id="outline-container-orgaa43970" class="outline-5">
<h5 id="orgaa43970"><span class="section-number-5">1.3.4.5</span> HA queues</h5>
<div class="outline-text-5" id="text-1-3-4-5">
<p>
Allows queues to have redundant copies across multiple servers.
</p>

<p>
HA queues have a single primary server node, and all the other nodes are secondary.
</p>

<p>
Should the primary node fail, one of the secondary nodes will take over the role of primary node. <br>
Should a secondary node be lost in an HA queue configuration, the other nodes would continue to operate as they were, sharing the state of operations that take place across all configured nodes.
</p>

<p>
When a lost node is added back, or a new node is added to the cluster, <span class="underline">it won't contain any messages that are already in the queue across the existing nodes</span>. <br>
Instead, <span class="underline">it will receive all new messages</span> and only be in sync once <i>all the previously published messages are consumed</i>.
</p>



<div class="figure">
<p><img src="img/rabbit_ha_queues.png" alt="rabbit_ha_queues.png">
</p>
</div>
</div>
</div>


<div id="outline-container-orgdcef4a6" class="outline-5">
<h5 id="orgdcef4a6"><span class="section-number-5">1.3.4.6</span> Delivery Mode 2</h5>
<div class="outline-text-5" id="text-1-3-4-6">
<p>
In addition to <code>delivery-mode</code> of 2, for messages to truly survive a restart of a RabbitMQ broker,
your queues must be declared as <code>durable</code> when they're created.
</p>

<pre class="example">
It's a costly way to guarantee delivery.
</pre>
</div>
</div>
</div>



<div id="outline-container-orgdc28493" class="outline-4">
<h4 id="orgdc28493"><span class="section-number-4">1.3.5</span> Consuming message</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Consuming messages with <code>Basic.Consume</code> means your application <span class="underline">automatically</span> receives messages from RabbitMQ as they become available
until the client issues a <code>Basic.Cancel</code>.
</p>

<p>
Application needs to <span class="underline">ACKNOWLEDGE</span> the message to let RabbitMQ know the message has been processed.
</p>



<div class="figure">
<p><img src="img/rabbit_basic_consume.png" alt="rabbit_basic_consume.png">
</p>
</div>
</div>



<div id="outline-container-org44943f9" class="outline-5">
<h5 id="org44943f9"><span class="section-number-5">1.3.5.1</span> Consumer Tag</h5>
<div class="outline-text-5" id="text-1-3-5-1">
<p>
When your application issues <code>Basic.Consume</code>, a unique string is created that identifies the application on the open channel with RabbitMQ.
This string, called a <b>consumer tag</b>, is sent to your application with each message from RabbitMQ.
</p>

<p>
The consumer tag can be used to <span class="underline">cancel</span> any future receipt of messages from RabbitMQ by issuing a <code>Basic.Cancel</code> RPC command.
</p>
</div>
</div>


<div id="outline-container-org9d2e82b" class="outline-5">
<h5 id="org9d2e82b"><span class="section-number-5">1.3.5.2</span> <code>no-ack</code> argument</h5>
<div class="outline-text-5" id="text-1-3-5-2">
<p>
There's a no-ack flag with <code>Basic.Consume</code> RPC request.
When enabled, this flag tells RabbitMQ that your consumer won't acknowledge the receipt of messages and
that RabbitMQ should just send them <span class="underline">as quickly as it is able</span>.
</p>



<p>
If the <code>no_ack</code> flag is set to false, a consumer must acknowledge each message that it receives by sending a <code>Basic.Ack</code> RPC request.
</p>


<div class="figure">
<p><img src="img/rabbit_consume_ack.png" alt="rabbit_consume_ack.png">
</p>
</div>
</div>


<div id="outline-container-org6fc0b2e" class="outline-6">
<h6 id="org6fc0b2e"><span class="section-number-6">1.3.5.2.1</span> Delivery tag</h6>
<div class="outline-text-6" id="text-1-3-5-2-1">
<p>
When the <code>Basic.Ack</code> response frame is sent, the consumer must pass with it an argument from the <code>Basic.Deliver</code> method frame
called the <b>delivery tag</b>. <br>
RabbitMQ uses the <b>delivery tag</b> along with the channel as a unique identifier to communicate message acknowledgement, rejection,
and negative acknowledgement.
</p>
</div>
</div>
</div>

<div id="outline-container-org5855fc2" class="outline-5">
<h5 id="org5855fc2"><span class="section-number-5">1.3.5.3</span> Prefetching (QoS)</h5>
<div class="outline-text-5" id="text-1-3-5-3">
<p>
prefetch 允许为每个 consumer 指定最大的 unacked messages 数目。
</p>

<p>
简单来说就是用来指定一个 consumer 一次可以从 RabbitMQ 中获取多少条 message 并缓存在 client 中。 <br>
一旦缓冲区满了，RabbitMQ 将会停止投递新的 message 到该 consumer 中直到它发出 ack 。
</p>

<p>
总的来说，consumer 负责不断处理消息，不断 ack ，然后只要 unacked 数少于 <code>prefetch * consumer</code> 数目，broker 就不断将消息投递过去。
</p>
</div>
</div>


<div id="outline-container-org837c7cd" class="outline-5">
<h5 id="org837c7cd"><span class="section-number-5">1.3.5.4</span> <code>Basic.Get</code></h5>
<div class="outline-text-5" id="text-1-3-5-4">
<div class="org-src-container">
<pre class="src src-plantuml">hide footbox
participant Client as c
database RabbitMQ as q

c -&gt; q : Basic.Get
q -&gt; c : msg
c --&gt; q : Basic.Ack
</pre>
</div>

<p>
<code>Basic.Get</code> 命令会订阅消息，获得单条消息，然后取消订阅，因此效率不高。
</p>
</div>
</div>



<div id="outline-container-org4793bf4" class="outline-5">
<h5 id="org4793bf4"><span class="section-number-5">1.3.5.5</span> <code>Basic.Reject</code></h5>
<div class="outline-text-5" id="text-1-3-5-5">
<p>
This RPC carries with it the <span class="underline">delivery tag</span> created by RabbitMQ to uniquely identify the message. <br>
When a consumer rejects a message, you can instruct RabbitMQ to either <span class="underline">discard</span> the message or to <span class="underline">requeue</span> the message with the <code>requeue</code> flag.
</p>

<p>
When a message is requeued, the <code>redelivered</code> flag is set in the message, informing the message's <b>next consumer</b> that it had been previously delivered.
</p>

<pre class="example">
Basic.Reject allows for a single message to be rejected.
You can't reject multiple messages at the same time using Basic.Reject.
</pre>
</div>
</div>


<div id="outline-container-org6c0e3df" class="outline-5">
<h5 id="org6c0e3df"><span class="section-number-5">1.3.5.6</span> <code>Basic.Nack</code></h5>
<div class="outline-text-5" id="text-1-3-5-6">
<p>
<code>Basic.Nack</code> method implements <span class="underline">the same behavior</span> as the <code>Basic.Reject</code>, but it adds "multiple-reject" behavior.
</p>
</div>
</div>


<div id="outline-container-org7af365e" class="outline-5">
<h5 id="org7af365e"><span class="section-number-5">1.3.5.7</span> Dead letter exchanges</h5>
<div class="outline-text-5" id="text-1-3-5-7">
<p>
Dead letter exchange is actually a normal exchange.
</p>

<p>
The only thing that makes an exchange a dead-letter exchange is the declared use of the exchange for rejected messages <span class="underline">when creating a queue</span>. <br>
Upon rejecting a message that isn't requeued, RabbitMQ will route the message to the exchanged specified in the queue's <code>x-dead-letter-exchange</code> argument.
</p>

<pre class="example">
Dead-letter exchanges AREN'T THE SAME AS the alternate exchanges.
An expired or rejected message is delivered via a dead-letter exchange,
whereas an alternate exchange routes messages that otherwise couldn't be routed by RabbitMQ.
</pre>


<div class="figure">
<p><img src="img/rabbit_dlx.png" alt="rabbit_dlx.png">
</p>
</div>


<p>
We can use the same exchange for dead-lettered messages as non-dead-lettered messages
<span class="underline">but to ensure that the dead-lettered messages aren't delivered to the same queue</span>. <br>
Set <code>x-dead-letter-routing-key</code>  when declaring the queue.
</p>
</div>
</div>
</div>




<div id="outline-container-org096c73c" class="outline-4">
<h4 id="org096c73c"><span class="section-number-4">1.3.6</span> <code>Basic.Properties</code></h4>
<div class="outline-text-4" id="text-1-3-6">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">For use by</th>
<th scope="col" class="org-left">Suggested or specified use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">app-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">Useful for defining the application publishing the messages.</td>
</tr>

<tr>
<td class="org-left">content-encoding</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">Specify whether your message body is encoded in some special way, such as zlib, deflate, or Base64.</td>
</tr>

<tr>
<td class="org-left">content-type</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">If the message is in reference to some other message or uniquely identifiable item, the correlation-id is a good way to indicate what the message is referencing.</td>
</tr>

<tr>
<td class="org-left">delivery-mode</td>
<td class="org-left">octet</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">A value of 1 tells RabbitMQ it can keep the message in memory; 2 indicates it should also write it to disk.</td>
</tr>

<tr>
<td class="org-left">expiration</td>
<td class="org-left">short-string</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">An epoch or Unix timestamp value as a text string that indicates when the message should expire.</td>
</tr>

<tr>
<td class="org-left">headers</td>
<td class="org-left">table</td>
<td class="org-left">Both</td>
<td class="org-left">A free-form key/value table that you can use to add additional metadata about your mes- sage; RabbitMQ can route based upon this if desired.</td>
</tr>

<tr>
<td class="org-left">message-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">A unique identifier such as a UUID that your application can use to identify the message.</td>
</tr>

<tr>
<td class="org-left">priority</td>
<td class="org-left">octet</td>
<td class="org-left">RabbitMQ</td>
<td class="org-left">A property for priority ordering in queues.</td>
</tr>

<tr>
<td class="org-left">timestamp</td>
<td class="org-left">timestamp</td>
<td class="org-left">Application</td>
<td class="org-left">An epoch or Unix timestamp value that can be used to indicate when the message was created.</td>
</tr>

<tr>
<td class="org-left">type</td>
<td class="org-left">short-string</td>
<td class="org-left">Application</td>
<td class="org-left">A text string your application can use to describe the message type or payload.</td>
</tr>

<tr>
<td class="org-left">user-id</td>
<td class="org-left">short-string</td>
<td class="org-left">Both</td>
<td class="org-left">A free-form string that, if used, RabbitMQ will validate against the connected user and drop messages if they don't match.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>









<div id="outline-container-org935027e" class="outline-2">
<h2 id="org935027e"><span class="section-number-2">2</span> 交换器</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org10c1e99" class="outline-3">
<h3 id="org10c1e99"><span class="section-number-3">2.1</span> 属性</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Name</li>
<li>Durability (exchanges survive broker restart)</li>
<li>Auto-delete (exchange is deleted when last queue is unbound from it)</li>
<li>Arguments (optional, used by plugins and broker-specific features)</li>
</ul>
</div>
</div>

<div id="outline-container-org68de37f" class="outline-3">
<h3 id="org68de37f"><span class="section-number-3">2.2</span> direct</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如果路由键匹配的话，消息就被投递到对应的队列。
</p>

<p>
RabbitMq 会默认实现一个类型为 direct 的，名称为空白字符串的交换器。
当声明一个队列时，一开始该队列会自动绑定到默认交换器， <b>并以队列名称作为路由键</b> 。
之后可以发送 <code>exchange.declare</code> 命令并设置合适的参数，就可以升级成具体类型交换器。
</p>


<div id="org510a3b6" class="figure">
<p><img src="img/direct-router.png" alt="direct-router.png">
</p>
<p><span class="figure-number">Figure 17: </span>direct router</p>
</div>
</div>
</div>


<div id="outline-container-org329369d" class="outline-3">
<h3 id="org329369d"><span class="section-number-3">2.3</span> fanout</h3>
<div class="outline-text-3" id="text-2-3">
<p>
将收到的消息广播的绑定的队列上。
</p>


<div id="orgadb6960" class="figure">
<p><img src="img/fanout-router.png" alt="fanout-router.png">
</p>
<p><span class="figure-number">Figure 18: </span>fanout router</p>
</div>
</div>
</div>


<div id="outline-container-org0dd0f69" class="outline-3">
<h3 id="org0dd0f69"><span class="section-number-3">2.4</span> topic</h3>
<div class="outline-text-3" id="text-2-4">

<div id="org369e98b" class="figure">
<p><img src="img/topic-router.png" alt="topic-router.png">
</p>
<p><span class="figure-number">Figure 19: </span>topic router</p>
</div>

<ul class="org-ul">
<li><code>.</code> 把路由键分为了几部分</li>
<li><code>*</code> 匹配特定位置的任意文本</li>
<li><code>#</code> 匹配所有规则</li>
</ul>
</div>
</div>


<div id="outline-container-orgd1c2e60" class="outline-3">
<h3 id="orgd1c2e60"><span class="section-number-3">2.5</span> 路由</h3>
<div class="outline-text-3" id="text-2-5">
<img src="http://javasampleapproach.com/wp-content/uploads/2017/10/springboot-rabbitmq-exchange-to-exchange-architecture.png"/>
</div>
</div>
</div>


<div id="outline-container-org85dbe2c" class="outline-2">
<h2 id="org85dbe2c"><span class="section-number-2">3</span> RabbitMQ 管理</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org6318b55" class="outline-3">
<h3 id="org6318b55"><span class="section-number-3">3.1</span> 启动停止</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org4ffc3b0" class="outline-4">
<h4 id="org4ffc3b0"><span class="section-number-4">3.1.1</span> 停止节点</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl stop
rabbitmqctl stop -n rabbit@&lt;nodename&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ff2b0d" class="outline-4">
<h4 id="org0ff2b0d"><span class="section-number-4">3.1.2</span> 停止应用</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl stop_app
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org22188e2" class="outline-3">
<h3 id="org22188e2"><span class="section-number-3">3.2</span> 配置文件</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code>/etc/rabbitmq/rabbitmq.config</code>
</p>
</div>
</div>


<div id="outline-container-orgbe93e29" class="outline-3">
<h3 id="orgbe93e29"><span class="section-number-3">3.3</span> 管理用户</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org518782f" class="outline-4">
<h4 id="org518782f"><span class="section-number-4">3.3.1</span> 创建</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl add_user &lt;username&gt; &lt;password&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org698a3f7" class="outline-4">
<h4 id="org698a3f7"><span class="section-number-4">3.3.2</span> 删除</h4>
<div class="outline-text-4" id="text-3-3-2">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl delete_user &lt;username&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org877feac" class="outline-4">
<h4 id="org877feac"><span class="section-number-4">3.3.3</span> 修改密码</h4>
<div class="outline-text-4" id="text-3-3-3">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl change_password &lt;username&gt; &lt;new-password&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a6fe92" class="outline-4">
<h4 id="org8a6fe92"><span class="section-number-4">3.3.4</span> 查看</h4>
<div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_users
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orge2ba20a" class="outline-3">
<h3 id="orge2ba20a"><span class="section-number-3">3.4</span> 管理权限</h3>
<div class="outline-text-3" id="text-3-4">
<p>
每条访问控制条目由四部分组成：
</p>

<ul class="org-ul">
<li>用户</li>
<li>vhost</li>
<li>需要授予的读/写/配置权限组合</li>
<li>权限范围</li>
</ul>
</div>

<div id="outline-container-org2d249d5" class="outline-4">
<h4 id="org2d249d5"><span class="section-number-4">3.4.1</span> 创建</h4>
<div class="outline-text-4" id="text-3-4-1">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl set_permission -p &lt;vhost_name&gt; <span style="color: #e6db74;">\</span>
&lt;username&gt; <span style="color: #e6db74;">".*"</span> <span style="color: #e6db74;">".*"</span> <span style="color: #e6db74;">".*"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e30cb2" class="outline-4">
<h4 id="org4e30cb2"><span class="section-number-4">3.4.2</span> 删除</h4>
<div class="outline-text-4" id="text-3-4-2">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl clear_permissions -p &lt;vhost_name&gt; &lt;username&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org7325770" class="outline-4">
<h4 id="org7325770"><span class="section-number-4">3.4.3</span> 查看</h4>
<div class="outline-text-4" id="text-3-4-3">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_permissions -p &lt;vhost_name&gt;
rabbitmqctl list_user_permissions &lt;username&gt;  <span style="color: #465457;"># </span><span style="color: #465457;">&#26597;&#30475;&#26576;&#20010;&#29992;&#25143;&#22312;&#25152;&#26377; vhost &#19978;&#30340;&#26435;&#38480;</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgadf9382" class="outline-3">
<h3 id="orgadf9382"><span class="section-number-3">3.5</span> 管理 vhost</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
查看
</p>
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_vhosts
</pre>
</div></li>
<li><p>
创建
</p>
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl add_vhost &lt;vhost_name&gt;
</pre>
</div></li>
<li><p>
删除
</p>
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl delete_vhost &lt;vhost_name&gt;
</pre>
</div></li>
</ul>
</div>
</div>



<div id="outline-container-orga2c8698" class="outline-3">
<h3 id="orga2c8698"><span class="section-number-3">3.6</span> 信息查询</h3>
<div class="outline-text-3" id="text-3-6">
</div>
<div id="outline-container-org771fcb9" class="outline-4">
<h4 id="org771fcb9"><span class="section-number-4">3.6.1</span> 查看队列</h4>
<div class="outline-text-4" id="text-3-6-1">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_queues
rabbitmqctl list_queues name messages consumers memory <span style="color: #465457;"># </span><span style="color: #465457;">memory &#21333;&#20301;&#20026;&#23383;&#33410;</span>
</pre>
</div>

<p>
信息参数包括：
</p>

<ul class="org-ul">
<li>name</li>
<li>durable</li>
<li>auto_delete</li>
<li>arguments</li>
<li>pid</li>
<li>owner_pid</li>
<li>exclusive_consumer_pid</li>
<li>exclusive_consumer_tag</li>
<li>messages_ready</li>
<li>messages_unacknowledged</li>
<li>messages_uncommitted</li>
<li>messages</li>
<li>acks_uncommitted</li>
<li>consumers</li>
<li>transactions</li>
<li>memory</li>
</ul>
</div>
</div>


<div id="outline-container-org5805197" class="outline-4">
<h4 id="org5805197"><span class="section-number-4">3.6.2</span> 查看交换器</h4>
<div class="outline-text-4" id="text-3-6-2">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_exchanges
</pre>
</div>

<p>
信息参数包括：
</p>

<ul class="org-ul">
<li>name</li>
<li>type</li>
<li>durable</li>
<li>auto_delete</li>
<li>arguments</li>
</ul>
</div>
</div>


<div id="outline-container-org8469b20" class="outline-4">
<h4 id="org8469b20"><span class="section-number-4">3.6.3</span> 查看绑定信息</h4>
<div class="outline-text-4" id="text-3-6-3">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl list_bindings
</pre>
</div>

<p>
参数信息包括：
</p>

<ul class="org-ul">
<li>source_name</li>
<li>source_kind</li>
<li>destination_name</li>
<li>destination_kind</li>
<li>routing_key</li>
<li>arguments</li>
</ul>
</div>
</div>


<div id="outline-container-org032664b" class="outline-4">
<h4 id="org032664b"><span class="section-number-4">3.6.4</span> 查看集群状态</h4>
<div class="outline-text-4" id="text-3-6-4">
<p>
包括各个节点MQ状态、镜像队列状态等
</p>

<p>
<code>rabbitmqctl report</code>
</p>
</div>
</div>

<div id="outline-container-orge384dc0" class="outline-4">
<h4 id="orge384dc0"><span class="section-number-4">3.6.5</span> 接入 Eshell</h4>
<div class="outline-text-4" id="text-3-6-5">
<p>
<code>erl -setcookie abc -name test@&lt;node-name&gt; -remsh rabbit@&lt;node-name&gt; -hidden</code>
</p>

<p>
退出时要用 <code>Ctrl+G</code> 然后执行 <b>q</b> 命令退出。
</p>

<div class="org-src-container">
<pre class="src src-erlang">spawn(fun() -&gt; etop:start([{output, text}, {interval, 5}, {lines, 10}, {sort, msg_q}]) end).

spawn(fun() -&gt; etop:start([{output, text}, {interval, 5}, {lines, 10}, {sort, reductions}]) end).
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org1a98d08" class="outline-2">
<h2 id="org1a98d08"><span class="section-number-2">4</span> 代码示例</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge47e740" class="outline-3">
<h3 id="orge47e740"><span class="section-number-3">4.1</span> 基本用法</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org1b12efd" class="outline-4">
<h4 id="org1b12efd"><span class="section-number-4">4.1.1</span> 生产者</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)  <span style="color: #465457;"># </span><span style="color: #465457;">&#20351;&#29992;&#40664;&#35748; vhost /</span>
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

channel.exchange_declare(exchange=EXCHANGE,
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

<span style="color: #fd971f;">msg_props</span> = pika.BasicProperties()
<span style="color: #fd971f;">msg_props.content_type</span> = <span style="color: #e6db74;">'text/plain'</span>

channel.basic_publish(exchange=EXCHANGE,
                      properties=msg_props,
                      body=<span style="color: #e6db74;">'Hello World'</span>,
                      routing_key=<span style="color: #e6db74;">'hola'</span>)

conn_broker.close()
</pre>
</div>
</div>
</div>


<div id="outline-container-org7e39d52" class="outline-4">
<h4 id="org7e39d52"><span class="section-number-4">4.1.2</span> 消费者</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>
<span style="color: #fd971f;">QUEUE</span> = <span style="color: #e6db74;">'hello-exchange'</span>
<span style="color: #fd971f;">TAG</span> = <span style="color: #e6db74;">'hello-consumer'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

channel.exchange_declare(exchange=EXCHANGE,  <span style="color: #465457;"># </span><span style="color: #465457;">&#22914;&#26524;&#27809;&#26377;&#23601;&#21019;&#24314;&#65292;&#21542;&#21017;&#32487;&#32493;</span>
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

channel.queue_declare(queue=QUEUE)

channel.queue_bind(queue=QUEUE,
                   exchange=EXCHANGE,
                   routing_key=<span style="color: #e6db74;">'hola'</span>)

<span style="color: #f92672; font-weight: bold;">def</span> <span style="color: #a6e22e;">msg_consumer</span>(channel, method, header, body):
    channel.basic_ack(delivery_tag=method.delivery_tag)
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"receive: {}"</span>.<span style="color: #a6e22e;">format</span>(body))
    channel.basic_cancel(consumer_tag=TAG)
    channel.stop_consuming()


channel.basic_consume(msg_consumer,
                      queue=QUEUE,
                      consumer_tag=TAG) <span style="color: #465457;"># </span><span style="color: #465457;">&#19968;&#20010; channel &#21487;&#20197;&#26377;&#22810;&#20010;&#35746;&#38405;&#65292;&#20351;&#29992; consumer_tag &#26469;&#26631;&#35782;&#35746;&#38405;</span>


<span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">' [*] Waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org389c1d7" class="outline-3">
<h3 id="org389c1d7"><span class="section-number-3">4.2</span> 发送方确认模式</h3>
<div class="outline-text-3" id="text-4-2">
<p>
信道进入 confirm 模式，所有在信道上发布的消息都会被指派一个唯一的 ID 号（从 1 开始）。
一旦消息被投递给所有匹配队列后，信道会发送一个发送方确认模式给生产者应用程序（包含消息的唯一 ID ）。
这使得生产者知晓信息已经安全到达目的队列了。
</p>
</div>


<div id="outline-container-org5101496" class="outline-4">
<h4 id="org5101496"><span class="section-number-4">4.2.1</span> 生产者</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #465457;">#</span><span style="color: #465457;">! /usr/bin/env python3</span>
<span style="color: #465457;"># </span><span style="color: #465457;">-*- coding: utf-8 -*-</span>

<span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'hello-exchange'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)  <span style="color: #465457;"># </span><span style="color: #465457;">&#20351;&#29992;&#40664;&#35748; vhost /</span>
<span style="color: #fd971f;">channel</span> = conn_broker.channel()
channel.confirm_delivery()
channel.exchange_declare(exchange=EXCHANGE,
                         exchange_type=<span style="color: #e6db74;">'direct'</span>,
                         passive=<span style="color: #ae81ff;">False</span>,
                         durable=<span style="color: #ae81ff;">True</span>,
                         auto_delete=<span style="color: #ae81ff;">False</span>)

<span style="color: #fd971f;">msg_props</span> = pika.BasicProperties()
<span style="color: #fd971f;">msg_props.content_type</span> = <span style="color: #e6db74;">'text/plain'</span>

<span style="color: #fd971f;">ack</span> = channel.basic_publish(exchange=EXCHANGE,
                            properties=msg_props,
                            body=<span style="color: #e6db74;">'Hello World'</span>,
                            routing_key=<span style="color: #e6db74;">'hola'</span>)

<span style="color: #f92672; font-weight: bold;">if</span> ack:
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"confirm received"</span>)
<span style="color: #f92672; font-weight: bold;">else</span>:
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"msg lost"</span>)

conn_broker.close()
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgfaaa2ee" class="outline-3">
<h3 id="orgfaaa2ee"><span class="section-number-3">4.3</span> 通过 AMQP 实时访问日志</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #465457;">#</span><span style="color: #465457;">! /usr/bin/env python3</span>
<span style="color: #465457;"># </span><span style="color: #465457;">-*- coding: utf-8 -*-</span>

<span style="color: #f92672; font-weight: bold;">import</span> pika

<span style="color: #fd971f;">EXCHANGE</span> = <span style="color: #e6db74;">'amq.rabbitmq.log'</span>

<span style="color: #fd971f;">conn_params</span> = pika.ConnectionParameters(host=<span style="color: #e6db74;">'10.74.68.89'</span>, port=45672, socket_timeout=3.0)
<span style="color: #fd971f;">conn_broker</span> = pika.BlockingConnection(conn_params)
<span style="color: #fd971f;">channel</span> = conn_broker.channel()

<span style="color: #fd971f;">result</span> = channel.queue_declare(exclusive=<span style="color: #ae81ff;">True</span>, auto_delete=<span style="color: #ae81ff;">True</span>)
<span style="color: #fd971f;">queue_name</span> = result.method.queue

<span style="color: #465457;"># </span><span style="color: #465457;">binding_keys = ['info', 'warning', 'error']</span>
<span style="color: #fd971f;">binding_keys</span> = [<span style="color: #e6db74;">'#'</span>]

<span style="color: #f92672; font-weight: bold;">for</span> binding_key <span style="color: #f92672; font-weight: bold;">in</span> binding_keys:
    channel.queue_bind(queue=queue_name,
                       exchange=EXCHANGE,
                       routing_key=binding_key)

<span style="color: #f92672; font-weight: bold;">def</span> <span style="color: #a6e22e;">msg_consumer</span>(channel, method, header, body):
    <span style="color: #f92672; font-weight: bold;">print</span>(<span style="color: #e6db74;">"[{}]: {}"</span>.<span style="color: #a6e22e;">format</span>(method.routing_key, body.decode(<span style="color: #e6db74;">'utf-8'</span>)), end=<span style="color: #e6db74;">''</span>)


channel.basic_consume(msg_consumer,
                      queue=queue_name,
                      no_ack=<span style="color: #ae81ff;">True</span>)

channel.start_consuming()

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org154c449" class="outline-2">
<h2 id="org154c449"><span class="section-number-2">5</span> 集群</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgd8719cb" class="outline-3">
<h3 id="orgd8719cb"><span class="section-number-3">5.1</span> Architecture</h3>
<div class="outline-text-3" id="text-5-1">
<p>
At all times RabbitMQ is keeping track of four kinds of internal metadata:
</p>

<ul class="org-ul">
<li>Queue metadata</li>
</ul>

<p>
Queue names and their properties (durable or auto-delete)
</p>
<ul class="org-ul">
<li><p>
Exchange metadata
</p>

<p>
The exchange's name, the type of exchange it is, and what the properties are (durable and so on)
</p></li>
<li><p>
Binding metadata
</p>

<p>
A simple table showing how to route messages to queues
</p></li>
<li><p>
Vhost metadata
</p>

<p>
Namespacing and security attributes for the queues, exchanges, and bindings within a vhost
</p></li>

<li>Node location meatadata (clustering only)</li>
</ul>


<p>
RabbitMQ stores all of this information <span class="underline">in memory</span> while writing it to disk for any queues and exchanges (and their bindings) marked <b>durable</b>.
</p>
</div>


<div id="outline-container-orgf5e6559" class="outline-4">
<h4 id="orgf5e6559"><span class="section-number-4">5.1.1</span> Queue in cluster</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
By default, not every node in cluster has a full copy of every queue.
</p>


<div class="figure">
<p><img src="img/rabbit_cluster.png" alt="rabbit_cluster.png">
</p>
</div>

<pre class="example">
If the queues being recreated were marked as durable, redeclaring them from another node will get you an ugly 404 NOT_FOUND error.
This ensures messages in that queue on the failed node don't disappear when you restore it to the cluster.
</pre>
</div>
</div>

<div id="outline-container-org4898350" class="outline-4">
<h4 id="org4898350"><span class="section-number-4">5.1.2</span> Exchange in cluster</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Actually, exchanges are just a name and a list of queue bindings. <br>
The <b>channel</b> does the actual routing of the message to the queue as specified by the matching binding.
</p>


<div class="figure">
<p><img src="img/rabbit_cluster_exchange.png" alt="rabbit_cluster_exchange.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org16f9fba" class="outline-4">
<h4 id="org16f9fba"><span class="section-number-4">5.1.3</span> RAM/DISK node</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
When nodes join or leave a cluster, they need to be able to notify <b>at least one</b> disk node of the change.
</p>

<p>
If you only have one disk node and that node happens to be down, your cluster can continue to route messages but you can't do any of the following:
</p>

<ul class="org-ul">
<li>Create queues</li>
<li>Create exchanges</li>
<li>Create bindings</li>
<li>Add users</li>
<li>Change permissions</li>
<li>Add or remove cluster nodes</li>
</ul>

<pre class="example">
The only meatadata RAM nodes store to disk are the addresses of disk nodes in the cluster.
</pre>
</div>
</div>
</div>

<div id="outline-container-org13b17ea" class="outline-3">
<h3 id="org13b17ea"><span class="section-number-3">5.2</span> 集群管理</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org2cb4b28" class="outline-4">
<h4 id="org2cb4b28"><span class="section-number-4">5.2.1</span> 清空节点元数据（重设）</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
当重设的节点是集群的一部分时，该命令也会和集群中的磁盘节点进行通信。
</p>

<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl -n &lt;node&gt; reset
</pre>
</div>
</div>
</div>

<div id="outline-container-org388dd15" class="outline-4">
<h4 id="org388dd15"><span class="section-number-4">5.2.2</span> 加入集群</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
将新节点加入到集群时，必须列出在集群中的所有磁盘节点，并作为集群命令的参数。
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #465457;"># </span><span style="color: #465457;">&#23558; my_node &#21152;&#20837;&#38598;&#32676;&#65292;&#24182;&#20351;&#20854;&#33258;&#24049;&#20063;&#31216;&#20026;&#30913;&#30424;&#33410;&#28857;</span>
rabbitmqctl -n &lt;my_node&gt; cluster &lt;other_node&gt; &lt;my_node&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdec4153" class="outline-4">
<h4 id="orgdec4153"><span class="section-number-4">5.2.3</span> 查看集群信息</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">
<pre class="src src-sh">rabbitmqctl cluster_status
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org86149d0" class="outline-2">
<h2 id="org86149d0"><span class="section-number-2">6</span> 持久性</h2>
<div class="outline-text-2" id="text-6">
<p>
RabbitMQ 支持消息的持久化，也就是数据写在磁盘上。消息队列持久化包括 3 个部分：
</p>

<ul class="org-ul">
<li>exchange 持久化，在声明时指定 <code>durable=1</code></li>
<li>queue 持久化，在声明时指定 <code>durable=1</code></li>
<li>消息持久化，在投递时指定 <code>delivery_mode=2</code> （1 是非持久化）</li>
</ul>


<p>
如果 exchange 和 queue 都是持久化的， <b>那么它们之间的 binding 也是持久化的</b> 。
</p>

<p>
如果 exchange 和 queue 两者之间有一个持久化，一个非持久化，其对应的 binding 就无法得到恢复。
</p>

<p>
但是，即使设置了持久化，也不能百分百保证消息不会丢失。有很小的概率在 RabbitMQ 接受到消息后，还没来得及写到磁盘，就发生重启了。
另外，RabbitMQ 也不会对每一个消息执行 <code>fsync(2)</code> ，消息可能仅仅写入到缓存，还没来得及 flush 到硬件存储。
因此 RabbitMQ 的持久性设置并非足够安全，对于普通的工作队列也许够用了。
如果需要加强的安全保证，可以把发布消息的代码封装在 <b>事务</b> 里。
</p>
</div>
</div>
</div>
</body>
</html>