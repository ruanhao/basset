#+TITLE:     MongoDB
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t
#+STARTUP:   showall
#+TOC:       headlines 5
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../org-html-themes/readtheorg/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>



* CRUD 概念

** [[https://docs.mongodb.com/manual/reference/sql-comparison/][SQL to MongoDB Mapping]]


** [[https://docs.mongodb.com/manual/reference/write-concern/][Write Concern]]

Write concern (Write Acknowledgement) describes the *level of acknowledgment*.

** Read Concern

Read concern (Read Isolation) controls the consistency and isolation of the data read from replica sets and replica set shards.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/read-concern-write-timeline.svg"/>


|-------+----------------------------------------------------------------------------------------------------------------------------------|
| Time  | Event                                                                                                                            |
|-------+----------------------------------------------------------------------------------------------------------------------------------|
| t_{0} | Primary applies write_{0}                                                                                                        |
| t_{1} | Secondary1 applies write_{0}                                                                                                     |
| t_{2} | Secondary2 applies write_{0}                                                                                                     |
| t_{3} | Primary is aware of successful replication to Secondary1 and sends acknowledgement to client                                     |
| t_{4} | Primary is aware of successful replication to Secondary2                                                                         |
| t_{5} | Secondary1 receives notice (through regular replication mechanism) to update its snapshot of its most recent =w: majority= write |
| t_{6} | Secondary2 receives notice (through regular replication mechanism) to update its snapshot of its most recent =w: majority= write |
|-------+----------------------------------------------------------------------------------------------------------------------------------|


*** local

| Target        | Time         | State of Data              |
| Primary       | After t_{0}  | Data reflects Write_{0}    |
| Secondary_{1} | Before t_{1} | Data reflects Write_{prev} |
| Secondary_{1} | After t_{1}  | Data reflects Write_{0}    |
| Secondary_{2} | Before t_{2} | Data reflects Write_{prev} |
| Secondary_{2} | After t_{2}  | Data reflects Write_{0}    |

*** majority

| Target        | Time         | State of Data              |
| Primary       | Begore t_{3} | Data reflects Write_{prev} |
| Primary       | After t_{3}  | Data reflects Write_{0}    |
| Secondary_{1} | Before t_{5} | Data reflects Write_{prev} |
| Secondary_{1} | After t_{5}  | Data reflects Write_{0}    |
| Secondary_{2} | Before t_{6} | Data reflects Write_{prev} |
| Secondary_{2} | After t_{6}  | Data reflects Write_{0}    |



*** available

For unsharded collections (including collections in a standalone deployment or a replica set deployment),
=local= and =available= read concerns behave *identically*.




*** linearizable

"Linearizable" read concern was introduced in MongoDb 3.4 to solve a possible issue with "majority" Read concern.

See [[https://stackoverflow.com/questions/42615319/the-difference-between-majority-and-linearizable][The difference between "majority" and "linearizable"]]




** 原子性

In MongoDB, a write operation is atomic *on the level of a single document.*

When a single write operation (e.g. db.collection.updateMany()) modifies multiple documents, \\
the modification of each document is atomic, but the operation *as a whole is not atomic.*

#+BEGIN_EXAMPLE
  For many scenarios, modeling your data appropriately will minimize the need for multi-document transactions.
#+END_EXAMPLE

** 并发控制

Concurrency control allows multiple applications to run concurrently without causing data inconsistency or conflicts.

1. One approach is to create a _unique index_.
2. Another approach is to specify the expected current value of a field in the query predicate for the write operations. (乐观锁)



** [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/][Causal Consistency]]

Four causal consistency guarantees:

1. Read own writes
2. Monotonic reads
3. monotonic writes
4. Writes follow reads



*** Network partition example

The read concern "majority" and write concern "majority" ensure that the four causal consistency guarantees hold even in network partition circumstances
where two members in a replica set transiently believe that they are the primary:

#+HTML: <img src="https://docs.mongodb.com/manual/_images/network-partition-two-primaries.svg"/>

- Writes with "majority" write concern can complete on P_{new} but cannot complete on P_old.
- Writes with ={ w: 1 }= write concern can complete on either P_old or P_new. \\
  However, the writes to P_old (as well as the writes replicated to S_1) *roll back once these members regain communication with the rest of the replica set*.
- After a successful write with "majority" write concern on P_new, causally consistent reads with "majority" read concern can observe the write on P_new, S_2, and S_3. \\
  The reads can also observe the write on P_old and S_1 _once they can communicate with the rest of the replica set and sync from the other members of the replica set_. \\
  Any writes made to P_old and/or replicated to S_1 during the partition are rolled back.

**** 场景分析

- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-majority-wc-majority][Read Concern "majority" and Write concern "majority"]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-majority-wc-1][Read Concern "majority" and Write concern {w: 1}]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-local-wc-majority][Read Concern "local" and Write concern "majority"]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-local-wc-1][Read Concern "local" and Write concern {w: 1}]]









* Replica Set

A replica set contains several _data bearing nodes_ and optionally one _arbiter node_ (only used to vote). \\
Of the data bearing nodes, *one and only one member is deemed the primary node, while the other nodes are deemed secondary nodes.*

MongoDB applies write operations on the primary and then records the operations on the primary’s _oplog_. \\
Secondary members *replicate this log* and apply the operations to their data sets.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/replica-set-read-write-operations-primary.bakedsvg.svg"/>


** Automatic Failover

- The replica set *cannot process write operations* until the election completes successfully.

- The replica set can *continue to serve read queries* while the primary is offline.

- Application connection logic should include tolerance for automatic failovers and the subsequent elections.


** 选举

Replica sets can trigger an election in response to a variety of events, such as:

- Adding a new node to the replica set.
- Initiating a replica set.
- Performing replica set maintenance using methods such as =rs.stepDown()= or =rs.reconfig()=.
- Secondary members losing connectivity to the primary for more than the configured timeout (10 seconds by default).


*** Member Priority

Secondaries with higher priority call elections relatively *sooner* than secondaries with lower priority, and are also *more likely to win*.

Members with a priority value of =0= cannot become primary and do not seek election.


*** 网络分区

When the primary detects that it can only see a *minority* of nodes in the replica set, the primary steps down and _becomes a secondary_. \\
A member in the partition that can communicate with a *majority* of the nodes (including itself) _holds an election to become the new primary_.



** Rollback

- A rollback is necessary *only if* the primary had accepted write operations that the secondaries had not successfully replicated before the primary stepped down.
- MongoDB attempts to avoid rollbacks.
- A rollback does not occur if the write operations replicate to another member of the replica set before the primary steps down.
- To prevent rollbacks of data that have been acknowledged to the client, run all voting members *with journaling enabled* and use =w: majority= write concern.

** [[https://docs.mongodb.com/manual/core/replica-set-write-concern/][Write Concern]]

Write concern for replica sets describe the *number* of data-bearing members that must acknowledge a write operation before the operation returns as successful. \\
A member can only acknowledge a write operation after it has received and applied the write successfully.

For replica sets, the default write concern of =w: 1= requires that only the primary replica set member acknowledge the write before returning write concern acknowledgment.


*** w: majority

#+HTML: <img src="https://docs.mongodb.com/manual/_images/crud-write-concern-w-majority.bakedsvg.svg"/>

With =writeConcernMajorityJournalDefault= set to false, MongoDB does not wait for =w: majority= writes to be written to the on-disk journal before acknowledging the writes. \\
As such, majority write operations could possibly roll back in the event of a transient loss (e.g. crash and restart) of a majority of nodes in a given replica set.

** Read Preference

Read preference describes how MongoDB clients *route* read operations to the members of a replica set.

#+BEGIN_EXAMPLE
  By default, an application directs its read operations to the primary member in a replica set.
#+END_EXAMPLE

#+HTML: <img src="https://docs.mongodb.com/manual/_images/replica-set-read-preference.bakedsvg.svg"/>


* Sharding

MongoDB uses sharding to support deployments with _very large data sets_ and _high throughput operations_.

MongoDB shards data at the collection level, distributing the collection data across the shards in the cluster.

** Components

#+HTML: <img src="https://docs.mongodb.com/manual/_images/sharded-cluster-production-architecture.bakedsvg.svg"/>

#+BEGIN_EXAMPLE
Production Configuration:
  - Deploy Config Servers as a 3 member replica set
  - Deploy *each Shard* as a 3 member replica set
  - Deploy one or more mongos routers
#+END_EXAMPLE


*** Shard

- A shard contains a *subset* of sharded data for a sharded cluster.
- Performing queries on a single shard only returns a subset of data. \\
  Connect to the mongos to perform cluster level operations, including read or write operations.

*** Config Servers

- Config servers store *metadata* and configuration settings for the cluster.
- Users should avoid writing directly to the config database in the course of normal operation or maintenance.
- If the config server replica set loses its primary and cannot elect a primary, the cluster's metadata becomes *read only*. \\
  You can still read and write data from the shards, but no chunk migration or chunk splits will occur \\
  until the replica set can elect a primary.

*** mongos

- =mongos= acts as a query *router*, providing an interface between client applications and the sharded cluster.
- =mongos= provide the only interface to a sharded cluster from the perspective of applications.
- =mongos= tracks what data is on which shard by caching the metadata from the config servers.
- =mongos= has no persistent state and consumes minimal system resources.

#+BEGIN_EXAMPLE
  mongos can route queries that include the shard key or the prefix of a compound shard key a specific shard or set of shards.
  mongos uses the shard key value to locate the chunk whose range includes the shard key value and
  directs the query at the shard containing that chunk.
#+END_EXAMPLE

** Shard Key

- The shard key consists of an immutable field or fields that exist in every document in the target collection.
- A sharded collection can have *only one* shard key.
- To shard a non-empty collection, the collection must have an index that starts with the shard key.
- If queries do not include the shard key or the prefix of a compound shard key, mongos performs a broadcast operation, \\
  querying all shards in the sharded cluster.

*** Chunk

MongoDB *partitions* data in the collection using ranges of shard key values. \\
Each range defines a non-overlapping range of shard key values and is associated with a chunk.

MongoDB attempts to distribute chunks evenly among the shards in the cluster. \\
The shard key has a direct relationship to the effectiveness of chunk distribution.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/sharding-range-based.bakedsvg.svg"/>


** Sharded Cluster


You must connect to a mongos router to interact with any collection in the sharded cluster.
This includes sharded and unsharded collections.
*Clients should never connect to a single shard in order to perform read or write operations.*

#+HTML: <img src="https://docs.mongodb.com/manual/_images/sharded-cluster-mixed.bakedsvg.svg"/>