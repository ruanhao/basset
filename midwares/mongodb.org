#+TITLE:     MongoDB
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t
#+STARTUP:   showall
#+TOC:       headlines 5
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../org-html-themes/readtheorg/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>



* CRUD 概念

** [[https://docs.mongodb.com/manual/reference/sql-comparison/][SQL to MongoDB Mapping]]


** [[https://docs.mongodb.com/manual/reference/write-concern/][Write Concern]]

Write concern (Write Acknowledgement) describes the *level of acknowledgment*.

** Read Concern

Read concern (Read Isolation) controls the consistency and isolation of the data read from replica sets and replica set shards.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/read-concern-write-timeline.svg"/>


|-------+----------------------------------------------------------------------------------------------------------------------------------|
| Time  | Event                                                                                                                            |
|-------+----------------------------------------------------------------------------------------------------------------------------------|
| t_{0} | Primary applies write_{0}                                                                                                        |
| t_{1} | Secondary1 applies write_{0}                                                                                                     |
| t_{2} | Secondary2 applies write_{0}                                                                                                     |
| t_{3} | Primary is aware of successful replication to Secondary1 and sends acknowledgement to client                                     |
| t_{4} | Primary is aware of successful replication to Secondary2                                                                         |
| t_{5} | Secondary1 receives notice (through regular replication mechanism) to update its snapshot of its most recent =w: majority= write |
| t_{6} | Secondary2 receives notice (through regular replication mechanism) to update its snapshot of its most recent =w: majority= write |
|-------+----------------------------------------------------------------------------------------------------------------------------------|


*** local

| Target        | Time         | State of Data              |
| Primary       | After t_{0}  | Data reflects Write_{0}    |
| Secondary_{1} | Before t_{1} | Data reflects Write_{prev} |
| Secondary_{1} | After t_{1}  | Data reflects Write_{0}    |
| Secondary_{2} | Before t_{2} | Data reflects Write_{prev} |
| Secondary_{2} | After t_{2}  | Data reflects Write_{0}    |

*** majority

| Target        | Time         | State of Data              |
| Primary       | Begore t_{3} | Data reflects Write_{prev} |
| Primary       | After t_{3}  | Data reflects Write_{0}    |
| Secondary_{1} | Before t_{5} | Data reflects Write_{prev} |
| Secondary_{1} | After t_{5}  | Data reflects Write_{0}    |
| Secondary_{2} | Before t_{6} | Data reflects Write_{prev} |
| Secondary_{2} | After t_{6}  | Data reflects Write_{0}    |



*** available

For unsharded collections (including collections in a standalone deployment or a replica set deployment),
=local= and =available= read concerns behave *identically*.




*** linearizable

"Linearizable" read concern was introduced in MongoDb 3.4 to solve a possible issue with "majority" Read concern.

See [[https://stackoverflow.com/questions/42615319/the-difference-between-majority-and-linearizable][The difference between "majority" and "linearizable"]]




** 原子性

In MongoDB, a write operation is atomic *on the level of a single document.*

When a single write operation (e.g. db.collection.updateMany()) modifies multiple documents, \\
the modification of each document is atomic, but the operation *as a whole is not atomic.*

#+BEGIN_EXAMPLE
  For many scenarios, modeling your data appropriately will minimize the need for multi-document transactions.
#+END_EXAMPLE

** 并发控制

Concurrency control allows multiple applications to run concurrently without causing data inconsistency or conflicts.

1. One approach is to create a _unique index_.
2. Another approach is to specify the expected current value of a field in the query predicate for the write operations. (乐观锁)



** [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/][Causal Consistency]]

Four causal consistency guarantees:

1. Read own writes
2. Monotonic reads
3. monotonic writes
4. Writes follow reads



*** Network partition example

The read concern "majority" and write concern "majority" ensure that the four causal consistency guarantees hold even in network partition circumstances
where two members in a replica set transiently believe that they are the primary:

#+HTML: <img src="https://docs.mongodb.com/manual/_images/network-partition-two-primaries.svg"/>

- Writes with "majority" write concern can complete on P_{new} but cannot complete on P_old.
- Writes with ={ w: 1 }= write concern can complete on either P_old or P_new. \\
  However, the writes to P_old (as well as the writes replicated to S_1) *roll back once these members regain communication with the rest of the replica set*.
- After a successful write with "majority" write concern on P_new, causally consistent reads with "majority" read concern can observe the write on P_new, S_2, and S_3. \\
  The reads can also observe the write on P_old and S_1 _once they can communicate with the rest of the replica set and sync from the other members of the replica set_. \\
  Any writes made to P_old and/or replicated to S_1 during the partition are rolled back.

**** 场景分析

- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-majority-wc-majority][Read Concern "majority" and Write concern "majority"]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-majority-wc-1][Read Concern "majority" and Write concern {w: 1}]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-local-wc-majority][Read Concern "local" and Write concern "majority"]]
- [[https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/#causal-rc-local-wc-1][Read Concern "local" and Write concern {w: 1}]]









* Replica Set

A replica set contains several _data bearing nodes_ and optionally one _arbiter node_ (only used to vote). \\
Of the data bearing nodes, *one and only one member is deemed the primary node, while the other nodes are deemed secondary nodes.*

MongoDB applies write operations on the primary and then records the operations on the primary’s _oplog_. \\
Secondary members *replicate this log* and apply the operations to their data sets.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/replica-set-read-write-operations-primary.bakedsvg.svg"/>


** Automatic Failover

- The replica set *cannot process write operations* until the election completes successfully.

- The replica set can *continue to serve read queries* while the primary is offline.

- Application connection logic should include tolerance for automatic failovers and the subsequent elections.


** 选举

Replica sets can trigger an election in response to a variety of events, such as:

- Adding a new node to the replica set.
- Initiating a replica set.
- Performing replica set maintenance using methods such as =rs.stepDown()= or =rs.reconfig()=.
- Secondary members losing connectivity to the primary for more than the configured timeout (10 seconds by default).


*** Member Priority

Secondaries with higher priority call elections relatively *sooner* than secondaries with lower priority, and are also *more likely to win*.

Members with a priority value of =0= cannot become primary and do not seek election.


*** 网络分区

When the primary detects that it can only see a *minority* of nodes in the replica set, the primary steps down and _becomes a secondary_. \\
A member in the partition that can communicate with a *majority* of the nodes (including itself) _holds an election to become the new primary_.



** Rollback

- A rollback is necessary *only if* the primary had accepted write operations that the secondaries had not successfully replicated before the primary stepped down.
- MongoDB attempts to avoid rollbacks.
- A rollback does not occur if the write operations replicate to another member of the replica set before the primary steps down.
- To prevent rollbacks of data that have been acknowledged to the client, run all voting members *with journaling enabled* and use =w: majority= write concern.

** [[https://docs.mongodb.com/manual/core/replica-set-write-concern/][Write Concern]]

Write concern for replica sets describe the *number* of data-bearing members that must acknowledge a write operation before the operation returns as successful. \\
A member can only acknowledge a write operation after it has received and applied the write successfully.

For replica sets, the default write concern of =w: 1= requires that only the primary replica set member acknowledge the write before returning write concern acknowledgment.


*** w: majority

#+HTML: <img src="https://docs.mongodb.com/manual/_images/crud-write-concern-w-majority.bakedsvg.svg"/>

With =writeConcernMajorityJournalDefault= set to false, MongoDB does not wait for =w: majority= writes to be written to the on-disk journal before acknowledging the writes. \\
As such, majority write operations could possibly roll back in the event of a transient loss (e.g. crash and restart) of a majority of nodes in a given replica set.

** Read Preference

Read preference describes how MongoDB clients *route* read operations to the members of a replica set.

#+BEGIN_EXAMPLE
  By default, an application directs its read operations to the primary member in a replica set.
#+END_EXAMPLE

#+HTML: <img src="https://docs.mongodb.com/manual/_images/replica-set-read-preference.bakedsvg.svg"/>


* Sharding

MongoDB supports horizontal scaling through sharding.

MongoDB sharded cluster consists of the following components:

- shard: Each shard contains a subset of the sharded data. Each shard can be deployed as a replica set.
- mongos: The mongos acts as a query router, providing an interface between client applications and the sharded cluster.
- config servers: Config servers store metadata and configuration settings for the cluster.

#+HTML: <img src="https://docs.mongodb.com/manual/_images/sharded-cluster-production-architecture.bakedsvg.svg"/>

You must connect to a mongos router to interact with any collection in the sharded cluster.
This includes sharded and unsharded collections.
*Clients should never connect to a single shard in order to perform read or write operations.*

#+HTML: <img src="https://docs.mongodb.com/manual/_images/sharded-cluster-mixed.bakedsvg.svg"/>