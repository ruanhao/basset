#+TITLE:     RabbitMQ
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 5


* KEY 操作

** 设置过期时间

=EXPIRE <key> <seconds>=

** 查看还有多少秒过期

=TTL <key>=

- -1 表示永不过期
- -2 表示已过期

** 查看当前数据库 key 的数量

=DBSIZE=

** 清空 key

- =FLUSHDB=
  清空当前数据库
- =FLUSHALL=
  清空所有数据库


* String

- String 类型是二进制安全的，意味着可以包含任何数据，如 jpg 图片或者序列化后的对象
- String 类型的 value 最多可以是 512M

** SET,SETNX,GET,APPEND,STRLEN
#+BEGIN_SRC sh
  127.0.0.1:6379> set k1 v1
  OK
  127.0.0.1:6379> get k1
  "v1"
  127.0.0.1:6379> append k1 test
  (integer) 6
  127.0.0.1:6379> get k1
  "v1test"
  127.0.0.1:6379> strlen k1
  (integer) 6
  127.0.0.1:6379> setnx k1 v2     # 只有在 key 不存在时才设置
  (integer) 0
  127.0.0.1:6379> get k1
  "v1test"
  127.0.0.1:6379>
#+END_SRC

** MSET,MGET,MSETNX

#+BEGIN_SRC sh
  127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3
  OK
  127.0.0.1:6379> mget k1 k2 k3
  1) "v1"
  2) "v2"
  3) "v3"
  127.0.0.1:6379> msetnx k4 v4 k5 v5 k6 v6
  (integer) 1
  127.0.0.1:6379> msetnx k1 v1 k2 v2 k3 v3
  (integer) 0
#+END_SRC

** INCR,DECR,INCRBY,DECRBY
#+BEGIN_SRC sh
  127.0.0.1:6379> set num 1
  OK
  127.0.0.1:6379> incr num
  (integer) 2
  127.0.0.1:6379> get num
  "2"
  127.0.0.1:6379> decr num
  (integer) 1
  127.0.0.1:6379> incrby num 3
  (integer) 4
  127.0.0.1:6379> get num
  "4"
  127.0.0.1:6379> decrby num 3
  (integer) 1
#+END_SRC

** SETEX
设置键值的同时设置过期时间
** GETSET


* List

[[file:img/redis-list.png]]


** LPUSH,RPUSH,LPOP,RPOP,RPOPLPUSH

#+BEGIN_SRC sh
  127.0.0.1:6379> lpush list1 v1 v2 v3
  (integer) 3
  127.0.0.1:6379> lrange list1 0 -1
  1) "v3"
  2) "v2"
  3) "v1"
  127.0.0.1:6379> rpush list1 v4 v5 v6
  (integer) 6
  127.0.0.1:6379> lrange list1 0 -1
  1) "v3"
  2) "v2"
  3) "v1"
  4) "v4"
  5) "v5"
  6) "v6"
  127.0.0.1:6379> lpop list1
  "v3"
  127.0.0.1:6379> rpop list1
  "v6"
  127.0.0.1:6379> RPOPLPUSH list1 newList
  "v5"
#+END_SRC

** LRANGE,LINDEX,LLEN

#+BEGIN_SRC sh
  127.0.0.1:6379> lpush list1 v1 v2 v3 v4 v5 v6
  (integer) 6
  127.0.0.1:6379> lrange list1 0 -1
  1) "v6"
  2) "v5"
  3) "v4"
  4) "v3"
  5) "v2"
  6) "v1"
  127.0.0.1:6379> LINDEX list1 0
  "v6"
  127.0.0.1:6379> LINDEX list1 -1
  "v1"
  127.0.0.1:6379> LLEN list1
  (integer) 6
#+END_SRC

** LINSERT,LREM

- =LINSERT <key> [before|after] <value> <new-value>=
- =LREM <key> <n> <value>=

  n 为正：从左删除 n 个 value \\
  n 为负：从右删除 n 个 value \\
  n 为零：将列表中符合 value 的值全部删除


* Set

[[file:img/redis-set.png]]

** SADD,SMEMBERS,SISMEMBER

#+BEGIN_SRC sh
  127.0.0.1:6379> SADD s1 v1 v2 v3 v3
  (integer) 3
  127.0.0.1:6379> SMEMBERS s1
  1) "v2"
  2) "v1"
  3) "v3"
  127.0.0.1:6379> SISMEMBER s1 v5
  (integer) 0
  127.0.0.1:6379> SISMEMBER s1 v3
  (integer) 1
  127.0.0.1:6379> SREM s1 v3
  (integer) 1
  127.0.0.1:6379> SMEMBERS s1
  1) "v2"
  2) "v1"
  127.0.0.1:6379>
#+END_SRC

** SCARD,SPOP,SRANDMEMBER

#+BEGIN_SRC sh
  127.0.0.1:6379> SADD s1 v1 v2 v3 v4 v5
  (integer) 5
  127.0.0.1:6379> SCARD s1 # 集合数量
  (integer) 5
  127.0.0.1:6379> SPOP s1 # 随机弹出
  "v5"
  127.0.0.1:6379> SMEMBERS s1
  1) "v1"
  2) "v2"
  3) "v3"
  4) "v4"
  127.0.0.1:6379> SRANDMEMBER s1 2 # 随机选出
  1) "v2"
  2) "v1"
  127.0.0.1:6379> SMEMBERS s1
  1) "v1"
  2) "v2"
  3) "v3"
  4) "v4"
#+END_SRC

** SINTER,SUNION,SDIFF

#+BEGIN_SRC sh
  127.0.0.1:6379> sadd s1 1 2 3 4 5
  (integer) 5
  127.0.0.1:6379> sadd s2 4 5 6 7 8
  (integer) 5
  127.0.0.1:6379> SINTER s1 s2
  1) "4"
  2) "5"
  127.0.0.1:6379> SUNION s1 s2
  1) "1"
  2) "2"
  3) "3"
  4) "4"
  5) "5"
  6) "6"
  7) "7"
  8) "8"
  127.0.0.1:6379> SDIFF s1 s2
  1) "1"
  2) "2"
  3) "3"
  127.0.0.1:6379> SDIFF s2 s1
  1) "6"
  2) "7"
  3) "8"
#+END_SRC


* Hash

[[file:img/redis-hash.png]]

file:img/redis-hash-example.png


** HSET,HMSET,HGET,HGETALL
#+BEGIN_SRC sh
  127.0.0.1:6379> hset h1 name zhangsan
  (integer) 1
  127.0.0.1:6379> hget h1 name
  "zhangsan"
  127.0.0.1:6379> HMSET h1 city shanghai gender male
  OK
  127.0.0.1:6379> HGETALL h1
  1) "name"
  2) "zhangsan"
  3) "city"
  4) "shanghai"
  5) "gender"
  6) "male"
#+END_SRC


** HEXISTS,HKEYS,HVALS,HINCRBY,HSETNX


* Zset

[[file:img/redis-zset.png]]


* 事务

- 事务是一个单独的隔离操作：事务中所有命令都会序列化，按顺序执行。执行过程中不会被客户端发送来的命令请求打断
- Redis 事务的主要作用是 *串联* 多个命令防止别的命令插队


[[file:img/redis-transaction.png]]

file:img/redis-transaction2.png

file:img/redis-transaction3.png


参考：[[https://www.youtube.com/watch?v=4-vWCotst64&list=PLmOn9nNkQxJEi-V3CqOaOyTruYhTViQDc&index=9][09 Redis 验证码案例演示 校验验证码 & 事务简介(23:00)]]

** MULTI 和 PIPELINE 区别

- pipeline 选择客户端缓冲，multi 选择服务端缓冲
- 请求次数的不一致，multi 需要每个命令都发送一次给服务端，pipeline 最后一次性发送给服务端，请求次数相对于 multi 减少
- multi/exec 可以保证原子性，而 pipeline 不保证原子性

参考：[[https://juejin.im/post/5b42e025f265da0fa332d4dc][redis中multi与pipeline介绍分析]]


* 持久化

** RDB (Redis DataBase)

在指定时间内将内存中的数据集 *快照* 写入磁盘。

[[file:img/redis-rdb.png]]

file:img/redis-rdb2.png

** AOF

[[file:img/redis-aof.png]]

file:img/redis-aof2.png

file:img/redis-aof3.png



* 主从复制

*主从复制不属于集群的概念*

[[file:img/redis-cluster.png]]

** 复制原理
file:img/redis-cluster1.png

file:img/redis-cluster2.png

** 哨兵机制

file:img/redis-cluster3.png

file:img/redis-cluster4.png

file:img/redis-sentinel.png

*** 启动哨兵

=redis-sentinel /myredis/sentinel.conf=

*** 故障恢复原理

file:img/redis-failover.png


* 集群

*集群至少要有 6 台，其中 3 个 master ，每个 master 有一个 slave*

file:img/redis-cluster5.png

** slots

file:img/redis-slots.png

* 参考资料

- [[https://www.jianshu.com/p/2639549bedc8][使用python来操作redis用法详解]]
- [[https://www.youtube.com/watch?v=p3AOOU8wzO0&list=PLmOn9nNkQxJEi-V3CqOaOyTruYhTViQDc&index=14][Redis 主从复制 读写分离 1]]
- [[http://redisdoc.com/topic/cluster-tutorial.html][集群教程]]