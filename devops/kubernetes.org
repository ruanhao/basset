#+TITLE:     Kubernetes
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 5



* Resources

** Pod


*** YAML Definition

定义文件主要包含：

1. API version
2. Resource type
3. Metadata \\
   Includes the name, namespace, labels, and other information about the pod.
4. Spec \\
   Contains the actual description of the pod’s contents, such as the pod’s con- tainers, volumes, and other data.
5. Status\\
   Contains read-only runtime data that shows the state of the resource at a given moment.\\
   *When creating a new pod, you never need to provide the status part.*


[[file:img/k8s_pod_def.png]]


#+BEGIN_EXAMPLE
  在 POD 定义文件中定义 ports 是可选的行为，端口始终可以被访问，主要是为了方便用户清楚的了解提供了哪些服务。
#+END_EXAMPLE



*** Label

A label is an arbitrary key-value pair you attach to a resource, \\
which is then utilized when selecting resources using *label selectors* \\
(resources are filtered based on whether they include the label specified in the selector).

[[file:img/k8s_labels.png]]

A label selector can select resources based on whether the resource:

1. Contains (or doesn’t contain) a label with a certain key \\
2. Contains a label with a certain key and value \\
3. Contains a label with a certain key, but with a value not equal to the one you specify


*** Annotation

Annotations are also key-value pairs, so in essence, they’re similar to labels,
but they aren’t meant to hold identifying information.

They can’t be used to group objects the way labels can.
While objects can be selected through label selectors, *there’s no such thing as an annotation selector.*

Annotations can hold much larger pieces of information (up to 256 KB in total) and are primarily *meant to be used by tools.*

#+BEGIN_EXAMPLE
  Annotations are also commonly used when introducing new features to Kubernetes.
  Usually, alpha and beta versions of new features don’t introduce any new fields to API objects.
  Annotations are used instead of fields, and then once the required API changes have become clear and been agreed upon by the Kubernetes developers, new fields are introduced and the related annotations deprecated.

  A great use of annotations is adding descriptions for each pod or other API object, so that everyone using the cluster can quickly look up information about each individual object.
  For example, an annotation used to specify the name of the person who created the object can make collaboration between everyone working on the cluster much easier.
#+END_EXAMPLE


*** Deleting

By deleting a pod, you’re instructing Kubernetes to terminate all the containers that are part of that pod.

Kubernetes sends a *SIGTERM* signal to the process and waits a certain number of seconds (30 by default) for it to shut down gracefully.

If it doesn’t shut down in time, the process is then killed through *SIGKILL*.
To make sure your processes are always shut down gracefully, they need to handle the SIGTERM signal properly.


*** Liveness probes

As soon as a pod is scheduled to a node, the Kubelet on that node will run its containers and, from then on, *keep them running as long as the pod exists.*

If the container’s main process crashes, *the Kubelet will restart the container.*

Kubernetes can check if a *container* is still alive through =liveness probes=.

You can specify a liveness probe for each container in the pod’s specification.
Kubernetes will periodically execute the probe and restart the container if the probe fails.

#+BEGIN_EXAMPLE
  Kubernetes also supports readiness probes. Be sure not to confuse the two. They’re used for two different things.
#+END_EXAMPLE


[[file:img/k8s_pod_liveness.png]]

#+BEGIN_EXAMPLE
  Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3

  The delay=0s part shows that the probing begins immediately after the container is started.
  If you don’t set the initial delay, the prober will start probing the container as soon as it starts,
  which usually leads to the probe failing, because the app isn’t ready to start receiving requests.

  The timeout is set to only 1 second, so the container must return a response in 1 second or the probe is counted as failed.

  The container is probed every 10 seconds (period=10s) and the container is restarted after the probe fails three consecutive times (#failure=3).
#+END_EXAMPLE




** ReplicationController

A ReplicationController’s job is to make sure that an exact number of pods always *matches its label selector.* \\
If it doesn’t, the ReplicationController takes the appropriate action to reconcile the actual with the desired number.

[[file:img/k8s_rc_loop.png]]


*** Three Parts Of A Replicationcontroller

[[file:img/k8s_rc_3parts.png]]


A ReplicationController’s replica count, the label selector, and even the pod template can all be modified at any time,
*but only changes to the replica count affect existing pods.*


*** Create

[[file:img/k8s_rc_def.png]]

The pod labels in the template must obviously match the label selector of the ReplicationController;
otherwise the controller would create new pods indefinitely, because spinning up a new pod wouldn’t bring the actual replica count any closer to the desired number of replicas.

To prevent such scenarios, the API server verifies the ReplicationController definition and will not accept it if it’s misconfigured.
*Not specifying the selector at all is also an option.* In that case, it will be configured automatically from the labels in the pod template.


#+BEGIN_EXAMPLE
  Don’t specify a pod selector when defining a ReplicationController.
  Let Kubernetes extract it from the pod template. This will keep your YAML shorter and simpler.
#+END_EXAMPLE

Although a pod isn’t tied to a ReplicationController, the pod does reference it in the =metadata.ownerReferences= field, \\
which you can use to easily find which ReplicationController a pod belongs to.


*** Change Pod Template

A ReplicationController’s pod template can be modified at any time. \\
Changing the pod template is like replacing a cookie cutter with another one. \\
It will only affect the cookies you cut out afterward and will have no effect on the ones you’ve already cut. \\
To modify the old pods, you’d need to delete them and let the ReplicationController replace them with new ones based on the new template.

[[file:img/k8s_rc_change_pod_tmpl.png]]


*** Deleting a ReplicationController Without Deleting Pods

When you delete a ReplicationController through kubectl delete, the pods are also deleted.\\
But because pods created by a ReplicationController aren’t an integral part of the ReplicationController, and are only managed by it, \\
*you can delete only the ReplicationController and leave the pods running:*

#+BEGIN_SRC sh
  kubectl delete rc <rc-name> --cascade=false
#+END_SRC


** ReplicaSet

You usually won’t create them directly, but instead have them created automatically *when you create the higher-level Deployment resource.*

A ReplicaSet behaves exactly like a ReplicationController, but it has *more expressive pod selectors.*

*** More Expressive Label Selectors

[[file:img/k8s_rs_label_selector.png]]

Each expression must contain _a key_, _an operator_, and possibly (depending on the operator) _a list of values_. \\
Four valid operators:

+ In :: Label’s value must match one of the specified _values_.
+ NotIn :: Label’s value must not match any of the specified _values_.
+ Exists :: Pod must include a label with the specified key (the value isn’t important). When using this operator, you shouldn’t specify the _values_ field.
+ DoesNotExist :: Pod must not include a label with the specified key. The _values_ property must not be specified.


** DaemonSet

DaemonSet is used when you want *a pod to run on each and every node in the cluster* \\
(and each node needs to run exactly *one instance of the pod*).

[[file:img/k8s_ds.png]]

To run a pod on all cluster nodes, you create a DaemonSet object, which is much like a ReplicationController or a ReplicaSet, \\
except that pods created by a DaemonSet already have a target node specified and *skip the Kubernetes Scheduler.*


** Job

*In the event of a node failure*, the pods on that node that are managed by a Job will be rescheduled to other nodes the way ReplicaSet pods are. \\
*In the event of a failure of the process itself* (when the process returns an error exit code), \\
the Job can be configured to either restart the container or not.


*** Definition

[[file:img/k8s_job_def.png]]


Job pods can't use the default policy, because they're not meant to run indefinitely. \\
Need to explicitly set the restart policy to either =OnFailure= or =Never=.


*** Limiting the time allowed for a Job pod to complete

A pod's time can be limited by setting the =activeDeadlineSeconds= property in the pod spec. \\
If the pod runs longer than that, the system will try to terminate it and will mark the Job as failed.

#+BEGIN_EXAMPLE
  You can configure how many times a Job can be retried before it is marked as failed by specifying the spec.backoffLimit field in the Job manifest.
  If you don't explicitly specify it, it defaults to 6.
#+END_EXAMPLE



** CronJob

A CronJob creates Job resources from the =jobTemplate= property configured in the CronJob spec. \\
The Job then creates the pods.


** Service

*** Overall

Although the primary purpose of services is exposing groups of pods to other pods *in the cluster*, \\
*Both* internal (by DNS or ENV) and external (by IP) clients usually connect to pods through services:

[[file:img/k8s_svc_overall.png]]

*Label selectors* determine which pods belong to the Service:

[[file:img/k8s_svc_label.png]]


*** Creation

**** By =kubectl expose=


**** By YAML

[[file:img/k8s_svc_def.png]]

***** Exposing Multiple Ports In The Same Service

#+BEGIN_EXAMPLE
  When creating a service with multiple ports, you must specify a name for each port.
#+END_EXAMPLE

#+BEGIN_SRC yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec: ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8443
  selector:
    app: kubia
#+END_SRC


***** Using Named Ports

[[file:img/k8s_svc_named_ports_container.png]]

You can then refer to those ports by name in the service spec:

[[file:img/k8s_svc_named_ports_pod.png]]

#+BEGIN_EXAMPLE
  The biggest benefit of doing so is that it enables you to change port numbers later without having to change the service spec.
#+END_EXAMPLE





*** Session Affinity

If you want all requests made by a certain client to be redirected to the *same* pod every time, \\
you can set the service's _sessionAffinity_ property to =ClientIP= (instead of =None=, which is the default).

This makes the service proxy redirect all requests originating *from the same client IP to the same pod.*


#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Service
  spec:
    sessionAffinity: ClientIP
  ...
#+END_SRC





*** Discovering Service

**** Through ENV

#+BEGIN_EXAMPLE
  Dashes in the service name are converted to underscores and all letters are uppercased
  when the service name is used as the prefix in the environment variable's name.
#+END_EXAMPLE

**** Through DNS

#+BEGIN_EXAMPLE
  kubia        .default  .svc.cluster.local
  ------------
  service name
               ---------
               namespace
                         ------------------
                         configurable cluster domain suffix
#+END_EXAMPLE

*You can omit the =svc.cluster.local= suffix and even the namespace, when pods are in the same namespace.* \\
(This is because how =/etc/resolv.conf= is configured)


#+BEGIN_EXAMPLE
  Whether a pod uses the internal DNS server or not is configurable through the 'dnsPolicy' property in each pod's spec.
#+END_EXAMPLE


*** Endpoints

Services don't link to pods directly, but *Endpoints*. \\
An Endpoints resource (plural) is *a list of IP addresses and ports* exposing a service.

[[file:img/k8s_svc_endpoints.png]]


#+BEGIN_EXAMPLE
  Although the pod selector is defined in the service spec, it's not used directly when redirecting incoming connections.
  Instead, the selector is used to build a list of IPs and ports, which is then stored in the Endpoints resource.

  If you create a service without a pod selector, Kubernetes won't even create the Endpoints resource
  (after all, without a selector, it can't know which pods to include in the service).
  It's up to you to create the Endpoints resource to specify the list of endpoints for the service.
#+END_EXAMPLE

**** Manually configuring service endpoints

To create a service with manually managed endpoints, you need to create both a Service and an Endpoints resource.

Define a service called external-service that will accept incoming connections on port 80 (didn't define a pod selector for the service):

[[file:img/k8s_svc_manual_ep_svc.png]]


The Endpoints object needs to *have the same name as the service* and contain the list of target IP addresses and ports for the service:

[[file:img/k8s_svc_manual_ep_ep.png]]

After both the Service and the Endpoints resource are posted to the server, \\
the service is ready to be used like any regular service with a pod selector:

[[file:img/k8s_svc_manual_ep_external.png]]

If you later decide to migrate the external service to pods running inside Kubernetes, \\
you can add a selector to the service, thereby making its Endpoints managed automatically.
The same is also true in reverse by removing the selector from a Service, Kubernetes stops updating its Endpoints. \\
This means a service IP address can remain constant while the actual implementation of the service is changed.





**** Creating an alias for an external service

[[file:img/k8s_svc_external_name.png]]

After the service is created, pods can connect to the external service through the =external-service.default.svc.cluster.local= domain name.

#+BEGIN_EXAMPLE
  ExternalName services are implemented solely at the DNS level: a simple CNAME DNS record is created for the service.
  Therefore, clients connecting to the service will connect to the external service directly, bypassing the service proxy completely.
  For this reason, these types of services don't even get a cluster IP.
#+END_EXAMPLE



*** Exposing Services To External Clients

A few ways to make a service accessible externally:

1. Setting the service type to NodePort
2. Setting the service type to LoadBalancer, an extension of the NodePort type
3. Creating an Ingress resource

**** NodePort

[[file:img/k8s_svc_node_port_overall.png]]

An incoming connection to one of those ports will be redirected to a randomly selected pod, \\
which may or may not be the one running on the node the connection is being made to.

#+BEGIN_EXAMPLE
  If you only point your clients to the first node, when that node fails, your clients can't access the service anymore.
  That's why it makes sense to put a load balancer in front of the nodes to make sure you're spreading requests across all healthy nodes and never sending them to a node that's offline at that moment.
#+END_EXAMPLE

***** YAML Definition

[[file:img/k8s_svc_node_port_def.png]]

#+BEGIN_EXAMPLE
  Specifying the port isn't mandatory; Kubernetes will choose a random port if you omit it.
#+END_EXAMPLE



**** LoadBalancer

Kubernetes clusters running on cloud providers usually support the automatic provision of a load balancer from the cloud infrastructure. \\
The load balancer will have its own unique, publicly accessible IP address and will redirect all connections to your service. \\
You can thus access your service through the load balancer's IP address.

If Kubernetes is running in an environment that doesn't support LoadBalancer services, \\
the load balancer will not be provisioned, but the service will still behave like a NodePort service. \\
That's because *a LoadBalancer service is an extension of a NodePort service.* \\
(LoadBalancer type service is still a NodePort service but with an additional infrastructure-provided load balancer)


[[file:img/k8s_svc_lb_overall.png]]


***** YAML Definition

[[file:img/k8s_svc_lb_def.png]]


**** Ingress

One important reason is that each LoadBalancer service requires its own load balancer with its own public IP address, \\
whereas an Ingress *only requires one*, even when providing access to dozens of services.

Ingresses operate at the application layer of the network stack (HTTP) and can provide features such as cookie-based session affinity and the like, \\
which services can’t.


[[file:img/k8s_svc_ingress_overall.png]]

#+BEGIN_EXAMPLE
  Ingress controller provisions a load balancer behind the scenes.
#+END_EXAMPLE




***** YAML Definition

[[file:img/k8s_svc_ingress_def.png]]

[[file:img/k8s_svc_ingress_process.png]]


Ingress controller didn’t forward the request to the service. *It only used it to select a pod*. (Most controllers work like this) \\
This affects the preservation of client IPs when external clients connect through the Ingress controller,
which makes them preferred over Services in certain use cases.


*** Readiness Probe

Kubernetes invokes the probe periodically and acts based on the result of the readiness probe. \\
If a pod reports that it’s not ready, it’s removed from the service. If the pod then becomes ready again, it’s re-added.

Unlike liveness probes, if a container fails the readiness check, it won’t be killed or restarted. \\
The effect is the same as when the pod doesn’t match the service’s label selector at all:

[[file:img/k8s_svc_readiness_probe.png]]


*** Headless

Kubernetes allows clients to *discover pod IPs* through DNS lookups. \\
Usually, when you perform a DNS lookup for a service, the DNS server returns a single IP (the service’s cluster IP). \\
By setting the =clusterIP= field to =None= in the service specification, the DNS server will return the pod IPs instead of the single service IP.

Instead of returning a single DNS A record, the DNS server will return multiple A records for the service, \\
each pointing to the IP of an individual pod backing the service at that moment.

#+BEGIN_EXAMPLE
  A headless services still provides load balancing across pods,
  but through the DNS round-robin mechanism instead of through the service proxy.
#+END_EXAMPLE

*** External Traffic Issue

When an external client connects to a service through the node port (this also includes cases when it goes through the load balancer first), \\
the randomly chosen pod may or may not be running on the same node that received the connection. \\
An additional network hop is required to reach the pod, but this may not always be desirable.

You can prevent this additional hop by configuring the service to redirect external traffic only to pods running on the node that received the connection. \\
This is done by setting the =externalTrafficPolicy= field in the service's spec section:

#+BEGIN_SRC yaml
  spec:
    externalTrafficPolicy: Local
    ...
#+END_SRC

f a service definition includes this setting and an external connection is opened through the service's node port, \\
the service proxy will choose a locally running pod. If no local pods exist, the connection will *hang*. \\
You therefore need to ensure the load balancer forwards connections only to nodes that *have at least one such pod*.

**** Non-Preservation Of The Client's IP Issue

Usually, when clients inside the cluster connect to a service, the pods backing the service *can obtain the client's IP address*. \\
But when the connection is received through a node port, the packets' *source IP is changed*, because SNAT is performed on the packets.

The _Local_ external traffic policy (externalTrafficPolicy: Local) described in the previous section affects the preservation of the client's IP, \\
because there's no additional hop between the node receiving the connection and the node hosting the target pod (*SNAT isn't performed*).


** Volume

Volumes aren't top-level resources like pods, but are instead defined as *a part of a pod* and *share the same lifecycle as the pod.* \\
This means _a volume is created when the pod is started and is destroyed when the pod is deleted._

#+BEGIN_EXAMPLE
  Kubernetes volumes are a component of a pod and are thus defined in the pod's specification-much like containers.
  They aren't a standalone Kubernetes object and can not be created or deleted on their own.
#+END_EXAMPLE

[[file:img/k8s_vol.png]]

*** Volume Types

- emptyDir :: A simple empty directory used for storing transient data.
- hostPath :: Used for mounting directories from the worker node's filesystem into the pod.
- gitRepo :: A volume initialized by checking out the contents of a Git repository.
- nfs :: An NFS share mounted into the pod.
- gcePersistentDisk, awsElasticBlockStore, azureDisk :: Cloud provider.
- cinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphere- Volume, photonPersistentDisk, scaleIO :: Network storage.
- configMap, secret, downwardAPI ::
- persistentVolumeClaim ::


*** emptyDir

An =emptyDir= volume is especially useful for sharing files between containers running in the same pod.

An =emptyDir= volume is the simplest type of volume, but *other types build upon it*. (After the empty directory is created, they then populate it with data)

[[file:img/k8s_vol_empty_def.png]]





**** The medium used

The =emptyDir= used as the volume was created on the actual disk of the worker node hosting the pod. \\
Kubernetes can create the =emptyDir= on a tmpfs filesystem (in memory instead of on disk). \\
To do this, set the =emptyDir='s medium to =Memory=:

#+BEGIN_SRC yaml
  volumes:
    - name: html
      emptyDir:
        medium: Memory
#+END_SRC












*** hostPath

[[file:img/k8s_vol_host.png]]

It’s not a good idea to use a hostPath volume for regular pods, because it makes the pod sensitive to what node it’s scheduled to.

#+BEGIN_EXAMPLE
  Remember to use hostPath volumes only if you need to read or write system files on the node. Never use them to persist data across pods.
#+END_EXAMPLE



*** PV/PVC

[[file:img/k8s_vol_pv_pvc.png]]


Instead of the developer adding a technology-specific volume to their pod, it’s the *cluster administrator* who sets up the underlying storage and then \\
registers it in Kubernetes by creating a PersistentVolume resource through the Kubernetes API server.

When a cluster user needs to use persistent storage in one of their pods, they first create a PersistentVolumeClaim manifest,
specifying the minimum size and the access mode they require. \\
The user then submits the PersistentVolumeClaim manifest to the Kubernetes API server,
and Kubernetes finds the appropriate PersistentVolume and *binds the volume to the claim.* \\
The PersistentVolumeClaim can then be used as one of the volumes inside a pod.

#+BEGIN_EXAMPLE
  Other users cannot use the same PersistentVolume until it has been released by deleting the bound PersistentVolumeClaim.
#+END_EXAMPLE

**** Creating PersistentVolume

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: mongodb-pv
  spec:
    capacity:
      storage: 1Gi                # Defining the PersistentVolume's size
    accessModes:                  # Cwhether it can be read from and/or written to by a single node or by multiple nodes at the same time.
      - ReadWriteOnce
      - ReadOnlyMany
    persistentVolumeReclaimPolicy: Retain # After the claim is released, the PersistentVolume should be retained (not erased or deleted).
                                          # Have to manually delete pv when it is no more needed. (no deleted when pvc is deleted)
    hostPath:
      path: /tmp/mongodb
#+END_SRC

#+BEGIN_EXAMPLE
  PersistentVolumes don’t belong to any namespace. They’re cluster-level resources like nodes.
#+END_EXAMPLE

(*注:* =spec.capacity.storage= 看起来只是用于匹配 PVC ，实际容量应以 Actual storage 为准)

[[file:img/k8s_vol_pv_pvc_overall.png]]


***** Access Mode

- ReadWriteOnce :: Only a single node can mount the volume for reading and writing.
- ReadOnlyMany :: Multiple nodes can mount the volume for reading.
- ReadWriteMany :: Multiple nodes can mount the volume for both reading and writing.

#+BEGIN_EXAMPLE
  RWO, ROX, and RWX pertain to the number of worker nodes that can use the volume at the same time, not to the number of pods!
#+END_EXAMPLE




**** Creating PersistentVolumeClaim

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: mongodb-pvc
  spec:
    resources:
      requests:
        storage: 1Gi
    accessModes:
    - ReadWriteOnce
    storageClassName: ""  # Specifying an empty string as the storage class name ensures the PVC binds to a pre-provisioned PV instead of dynamically provisioning a new one.
#+END_SRC


As soon as you create the claim, Kubernetes finds the appropriate PersistentVolume and binds it to the claim. \\
The PersistentVolume’s capacity must be *large enough* to accommodate what the claim requests.
Additionally, the volume’s access modes must *include* the access modes requested by the claim.


**** Using PersistentVolumeClaim in Pod

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: mongodb
  spec:
    containers:
    - image: mongo
      name: mongodb
      volumeMounts:
      - name: mongodb-data
        mountPath: /data/db
      ports:
      - containerPort: 27017
        protocol: TCP
    volumes:
    - name: mongodb-data
      persistentVolumeClaim:
        claimName: mongodb-pvc    # referenced by name

#+END_SRC


[[file:img/k8s_vol_pv_pvc_logic.png]]


**** Dynamic Provisioning of PV

Cluster administrator can define =StorageClass= and let the system create a new PersistentVolume *each time* one is requested through a PersistentVolumeClaim.

#+BEGIN_EXAMPLE
  Similar to PersistentVolumes, StorageClass resources aren’t namespaced.
#+END_EXAMPLE

[[file:img/k8s_vol_pv_dp.png]]

***** Defining StorageClass

#+BEGIN_SRC yaml
  apiVersion: storage.k8s.io/v1
  kind: StorageClass
  metadata:
    name: fast
  provisioner: k8s.io/minikube-hostpath # The volume plugin to use for provisioning the PersistentVolume
  parameters:                           # Parameterd passed to the provisioner
    type: pd-ssd
#+END_SRC


***** Requesting the SC in a PVC

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: mongodb-pvc
  spec:
    storageClassName: fast
    resources:
      requests:
        storage: 100Mi
    accessModes:
      - ReadWriteOnce
#+END_SRC

#+BEGIN_EXAMPLE
  The provisioner is used even if an existing manually provisioned PersistentVolume matches the PersistentVolumeClaim.
#+END_EXAMPLE


***** Creating a PVC Without SC

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: mongodb-pvc2
  spec:
    resources:
      requests:
        storage: 100Mi
    accessModes:
      - ReadWriteOnce
#+END_SRC

#+BEGIN_EXAMPLE
  The default storage class is what's used to dynamically provision a PersistentVolume if the PersistentVolumeClaim doesn't explicitly say which storage class to use.
#+END_EXAMPLE




***** Forcing a PVC to Be Bound to One of The Pre-Provisioned PVs

#+BEGIN_EXAMPLE
  Explicitly set storageClassName to "" if you want the PVC to use a pre-provisioned PersistentVolume.
#+END_EXAMPLE






** ConfigMap & Secret

*** Basic

**** Overriding the command and arguments

In Kubernetes, when specifying a container, you can choose to override both =ENTRYPOINT= and =CMD=.

[[file:img/k8s_config_overriding.png]]


In most cases, you’ll only set custom arguments and rarely override the command
(except in *general-purpose images such as busybox*, which doesn’t define an =ENTRYPOINT= at all).

#+BEGIN_EXAMPLE
  The command and args fields can’t be updated after the pod is created.
#+END_EXAMPLE


**** Specifing env variables

#+BEGIN_SRC yaml
  kind: Pod
  spec:
   containers:
   - image: luksa/fortune:env
     env:                         # Adding a single variable to the environment variable list
     - name: INTERVAL
       value: "30"
     name: html-generator
#+END_SRC

#+BEGIN_SRC yaml
  env:
  - name: FIRST_VAR
    value: "foo"
  - name: SECOND_VAR
    value: "$(FIRST_VAR)bar"      # Referring to other environment variables
#+END_SRC


*** ConfigMap

[[file:img/k8s_config_map.png]]


**** Creating


***** CLI

#+BEGIN_SRC sh
  kubectl create configmap my-config \
          --from-file=foo.json \  # A single file
          --from-file=bar=foobar.conf \ # A file stored under a custom key
          --from-file=config-opts/ \ A whole directory
          --from-literal=some=thing # A literal value
#+END_SRC


[[file:img/k8s_config_map_cli.png]]



***** YAML

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: fortune-config
  data:
    sleep-interval: "25"
#+END_SRC




**** Passing CM to Container

***** As ENV

[[file:img/k8s_config_map_env.png]]

- Passing all entries of a ConfigMap as environment variables at once

  #+BEGIN_SRC yaml
    spec:
      containers:
      - image: some-image
        envFrom:                    # Using envFrom instead of env
        - prefix: CONFIG_           # All environment variables will be prefixed with CONFIG_.
          configMapRef:
            name: my-config-map     # Referencing the ConfigMap called my-config-map

  #+END_SRC

#+BEGIN_EXAMPLE
  The prefix is optional, so if you omit it the environment variables will have the same name as the keys.
#+END_EXAMPLE

- Passing a ConfigMap entry as a command-line argument

  You can’t reference ConfigMap entries directly in the =pod.spec.containers.args= field,
  but you can first initialize an environment variable from the ConfigMap entry and then refer to the variable inside the arguments:

  [[file:img/k8s_config_map_env_args.png]]




***** As Volume

A =configMap= volume will expose each entry of the ConfigMap *as a file.*
The process running in the container can obtain the entry’s value by reading the contents of the file.

[[file:img/k8s_config_map_vol_yaml.png]]

[[file:img/k8s_config_map_vol.png]]


- Exposing Certain ConfigMap Entries in the Volume

  [[file:img/k8s_config_map_vol_with_items.png]]


- Mounting Individual ConfigMap Entries as Files without Hiding Other Files in the Directory

  [[file:img/k8s_config_map_vol_with_specific_items.png]]

  [[file:img/k8s_config_map_vol_with_specific_items_pic.png]]


  #+BEGIN_EXAMPLE
  The 'subPath' property can be used when mounting any kind of volume. Instead of mounting the whole volume, you can mount part of it.
  #+END_EXAMPLE




- Setting the File Permissions for Files in a ConfigMap Volume

  #+BEGIN_SRC yaml
    volumes:
    - name: config
      configMap:
        name: fortune-config
        defaultMode: "6600"         # This sets the permissions for all files to -rw-rw------
  #+END_SRC


*** Secret

Kubernetes helps keep your Secrets safe by making sure each Secret *is only distributed to the nodes* that run the pods that need access to the Secret. \\
Also, on the nodes themselves, Secrets are always *stored in memory and never written to physical storage.*

#+BEGIN_EXAMPLE
  The maximum size of a Secret is limited to 1MB.
#+END_EXAMPLE


**** Default Token Secret

*Every pod has a secret volume* attached to it automatically, which represent everything you need to securely talk to the Kubernetes API server from within your pods, should you need to do that.

#+BEGIN_EXAMPLE
  By default, the default-token Secret is mounted into every container, but you can disable that in each pod
  by setting the automountServiceAccountToken field in the pod spec to false or by setting it to false on the service account the pod is using.
#+END_EXAMPLE


[[file:img/k8s_secret_default_token.png]]


**** Image Pull Secret

#+BEGIN_SRC sh
  kubectl create secret docker-registry mydockerhubsecret \
    --docker-username=myusername --docker-password=mypassword \
    --docker-email=my.email@provider.com

#+END_SRC

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: private-pod
  spec:
    imagePullSecrets:             #| This enables pulling images
    - name: mydockerhubsecret     #| from a private image registry.
    containers:
    - image: username/private:tag
      name: main

#+END_SRC

**** Passing Secret to Container

***** As Volume

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: fortune-https
  spec:
    containers:
    - image: luksa/fortune:env
      name: html-generator
      env:
      - name: INTERVAL
        valueFrom:
          configMapKeyRef:
            name: fortune-config
            key: sleep-interval
      volumeMounts:
      - name: html
        mountPath: /var/htdocs
    - image: nginx:alpine
      name: web-server
      volumeMounts:
      - name: html
        mountPath: /usr/share/nginx/html
        readOnly: true
      - name: config
        mountPath: /etc/nginx/conf.d
        readOnly: true
      - name: certs                    # | Configured Nginx to read the cert and
        mountPath: /etc/nginx/certs/   # | key file from /etc/nginx/certs, so you
        readOnly: true                 # | need to mount the Secret volume there.
      ports:
      - containerPort: 80
      - containerPort: 443
    volumes:
    - name: html
      emptyDir: {}
    - name: config
      configMap:
        name: fortune-config
        items:
        - key: my-nginx-config.conf
          path: https.conf
    - name: certs                 # | Define the secret
      secret:                     # | volume here, referring to
        secretName: fortune-https # | the fortune-https Secret.

#+END_SRC


[[file:img/k8s_secret_vol.png]]




***** As ENV

#+BEGIN_SRC yaml
  env:
  - name: FOO_SECRET
    valueFrom:                    #| The variable should be set
      secretKeyRef:               #| from the entry of a Secret.
        name: fortune-https       # The name of the Secret holding the key
        key: foo                  # The key of the Secret to exopse
#+END_SRC

#+BEGIN_EXAMPLE
  Think twice before using environment variables to pass your Secrets to your container, because they may get exposed inadvertently.
  To be safe, always use secret volumes for exposing Secrets.
#+END_EXAMPLE


** Deployment

Deployment sits *on top of ReplicaSets* and enables declarative application updates.

#+BEGIN_EXAMPLE
  The ReplicaSet(created by Deployment)'s name also contains the hash value of its pod template.
#+END_EXAMPLE

[[file:img/k8s_deploy.png]]

*** Updating Strategies

You have two ways of updating all those pods. You can do one of the following:

- Delete all existing pods first and then start the new ones (Recreate)

  [[file:img/k8s_deploy_recreate.png]]


- Start new ones and, once they're up, delete the old ones

  You can do this either by adding all the new pods and then deleting all the old ones at once, or sequentially,
  by adding new pods and removing old ones gradually.

  - Spinning up new pods and then deleting the old ones (blue-green deployment)

    [[file:img/k8s_deploy_blue_green.png]]


  - RollingUpdate

    Should use this strategy only when your app can handle running both the old and new version *at the same time.*


    [[file:img/k8s_deploy_rolling.png]]



*** Performing RU with =kubectl=

#+BEGIN_SRC sh
  kubectl rolling-update   kubia-v1      kubia-v2   --image=luksa/kubia:v2
  #                      ===old rc===  ===new rc===
#+END_SRC

**** Steps Required Before RU

1. Copying old controller to new controller and changing the image in its pod template.
2. Add an additional =deployment= label in *both* origin and new contoller.
3. Modify the labels of the live pods.

[[file:img/k8s_deploy_cli_warmup.png]]

After setting up all this, kubectl starts replacing pods by first scaling up the new controller to 1.
The controller thus creates the first v2 pod.
kubectl then scales down the old ReplicationController by 1.

[[file:img/k8s_deploy_cli_doing.png]]














*** Creating Deployment

#+BEGIN_SRC yaml
  apiVersion: apps/v1beta1        # Deployments are in the apps API group, version v1beta1.
  kind: Deployment
  metadata:
    name: kubia                   # There's no need to include the version info in the name of the Deployment.
  spec:
    replicas: 3
    template:
      metadata:
        name: kubia
        labels:
          app: kubia
      spec:
        containers:
        - image: luksa/kubia:v1
          name: nodejs
#+END_SRC

#+BEGIN_SRC sh
  kubectl create -f kubia-deployment-v1.yaml --record
#+END_SRC

#+BEGIN_EXAMPLE
  Be sure to include the --record command-line option when creating it. This records the command in the revision history.
#+END_EXAMPLE


*** Updating Deployment

The only thing you need to do is modify the pod template defined in the Deployment resource and
Kubernetes will take all the steps necessary to get the actual system state to what's defined in the resource.

[[file:img/k8s_deploy_update_image.png]]


[[file:img/k8s_deploy_update_process.png]]

*** Rolling Back

Deployments make it easy to roll back to the previously deployed version by telling Kubernetes to undo the last rollout of a Deployment:

#+BEGIN_SRC sh
  $ kubectl rollout undo deployment kubia
  deployment "kubia" rolled back
#+END_SRC

#+BEGIN_EXAMPLE
  The undo command can also be used while the rollout process is still in progress to essentially abort the rollout.
  Pods already created during the roll- out process are removed and replaced with the old ones again.
#+END_EXAMPLE

The length of the revision history is limited by the =revisionHistoryLimit= property on the Deployment resource.









*** maxSurge/maxUnavailable

#+BEGIN_SRC yaml
  spec:
    strategy:
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0
      type: RollingUpdate
#+END_SRC

- maxSurge

  Determines how many pod instances you allow to exist *above* the desired replica count configured on the Deployment. \\
  It defaults to 25%, so there can be at most 25% more pod instances than the desired count. \\
  The value can also be an absolute value.
- maxUnavailable

  Determines how many pod instances can be unavailable relative to the desired replica count during the update. \\
  It also defaults to 25%, so the number of available pod instances must never fall below 75% of the desired replica count. \\
  Can also specify an absolute value instead of a percentage.


[[file:img/k8s_deploy_rollout_rate.png]]


*** Pausing Rollout Process

A Deployment can also be paused during the rollout process. \\
This *allows you to verify that everything is fine with the new version* before proceeding with the rest of the rollout.

#+BEGIN_SRC sh
  $ kubectl set image deployment kubia nodejs=luksa/kubia:v4
  deployment "kubia" image updated

  $ kubectl rollout pause deployment kubia
  deployment "kubia" paused

  # A single new pod should have been created, but all original pods should also still be running.
  # Once the new pod is up, a part of all requests to the service will be redirected to the new pod.

  # Once you're confident the new version works as it should, you can resume the deployment to replace all the old pods with new ones:
  $ kubectl rollout resume deployment kubia
  deployment "kubia" resumed
#+END_SRC

#+BEGIN_EXAMPLE
  If a Deployment is paused, the 'undo' command won't undo it until you resume the Deployment.
#+END_EXAMPLE


*** Blocking Rollout (minReadySeconds)

=minReadySeconds= can be used to slow down the rollout, so you could see it was indeed performing a rolling update and not replacing all the pods at once. \\
But the main function of =minReadySeconds= is to prevent deploying malfunctioning versions, *not slowing down a deployment for fun.*

- This property specifies how long a newly created pod should be ready before the pod is treated as available.
- *Until the pod is available, the rollout process will not continue.*
- If a new pod's readiness probe starts failing before minReadySeconds have passed, the rollout of the new version will effectively *be blocked.*


#+BEGIN_EXAMPLE
  With a properly configured readiness probe and a proper minReadySeconds setting,
  Kubernetes would have prevented us from deploying buggy version at an earlier stage.

  If only define the readiness probe without setting 'minReadySeconds' properly,
  new pods are considered available immediately when the first invocation of the readiness probe succeeds.
  If the readiness probe starts failing shortly after, the bad version is rolled out across all pods.
  Therefore, you should set 'minReadySeconds' appropriately.
#+END_EXAMPLE

When the rollout will never continue, the only thing to do now is abort the rollout by undoing it:

#+BEGIN_SRC sh
  $ kubectl rollout undo deployment kubia
  deployment "kubia" rolled back
#+END_SRC


** StatefulSet

StatefulSet makes sure pods are rescheduled in such a way that they retain their identity and state.

StatefulSets were more like ReplicaSets and not like Deployments, so they *don't perform a rollout when the template is modified.*

#+BEGIN_EXAMPLE
  Starting from Kubernetes version 1.7, StatefulSets support rolling updates the same way Deployments and DaemonSets do.
  See the StatefulSet's spec.updateStrategy field documentation using kubectl explain for more information.
#+END_EXAMPLE

*** 设计思想

**** Stable Identity

Each pod created by a StatefulSet is assigned an ordinal index (zero-based),
which is then used to derive the pod's name and hostname, and to attach stable storage to the pod. \\
The names of the pods are thus *predictable*.

[[file:img/k8s_sts_stable_id.png]]


***** Governing Service

StatefulSet requires to create a corresponding *governing headless Service* that's used to provide the actual network identity to each pod. \\
Through this Service, *each pod gets its own DNS entry*, so its peers and possibly other clients in the cluster can *address the pod by its hostname:*

#+BEGIN_EXAMPLE
  a-0       .foo          .default   .svc.cluster.local
  --------  ------------  ---------  ----------------------------------
  pod name  service name  namespace  configurable cluster domain suffix
#+END_EXAMPLE

Additionally, we can also use DNS to look up all the StatefulSet's pods' names by looking up *SRV records* for the =foo.default.svc.cluster.local= domain.

#+BEGIN_EXAMPLE
  SRV records are used to point to hostnames and ports of servers providing a specific service.
  Kubernetes creates SRV records to point to the hostnames of the pods backing a HEADLESS SERVICE.
#+END_EXAMPLE


***** Scaling

- Scaling the StatefulSet creates a new pod instance with the *next unused ordinal index.*
- Scaling down a StatefulSet always removes the instances with the *highest ordinal index first.*

#+BEGIN_EXAMPLE
  ONLY ONE POD INSTANCE AT A TIME WHEN SCALING DOWN/UP:

  Because some stateful applications don't handle rapid scale-downs nicely,
  StatefulSets scale down ONLY ONE POD INSTANCE AT A TIME
  (for example: distributed data store may lose data if multiple nodes go down at the same time).
  For this exact reason, StatefulSets also never permit scale-down operations IF ANY OF THE INSTANCES ARE UNHEALTHY.
  If an instance is unhealthy, and you scale down by one at the same time, you've effectively lost two cluster members at once.
#+END_EXAMPLE








**** Stable Dedicated Storage

Each stateful pod instance needs to use its *own* storage, if a stateful pod is rescheduled
the new instance must have the *same* storage attached to it.

StatefulSet uses volume claim *templates* to _stamp out_ PersistentVolumeClaims along with each pod instance:

[[file:img/k8s_sts_stable_vol.png]]

PersistentVolumeClaim remains after a scale-down:

[[file:img/k8s_sts_stable_vol2.png]]


**** Guarantees

A StatefulSet must guarantee *at-most-one semantics* for stateful pod instances. \\
This means a StatefulSet must be _absolutely certain_ that a pod is no longer running before it can create a replacement pod.

Kubernetes master can only know that *when the cluster administrator tells it so.* \\
To do that, the admin needs to *either* _delete the pod forcibly_ or _delete the whole node._


#+BEGIN_EXAMPLE
  UNDERSTANDING WHAT HAPPENS TO PODS WHOSE STATUS IS UNKNOWN

  If the pod's status remains UNKNOWN for more than a few minutes (this time is configurable),
  the pod is marked for deletion, and will be removed as soon as the Kubelet notifies the API server that the pod's containers have terminated.
  The only thing you can do is tell the API server to delete the pod without waiting for the Kubelet to confirm that the pod is no longer running:
  kubectl delete po <name> --force --grace-period 0
#+END_EXAMPLE


*** Deploying App through StatefulSet

To deploy app, you'll need to create two (or three) different types of objects:
- PersistentVolumes for storing your data files

  Need to create these *only if* the cluster doesn't support dynamic provisioning of PersistentVolumes.
- A governing Service required by the StatefulSet.
- The StatefulSet itself.



* Internals

** Architecture

[[file:img/k8s_components.png]]

- components of the control plane
  - etcd
  - api server
  - scheduler
  - controller manager
- components running on the worker nodes
  - kubelet
  - Kubernetes service proxy (kube-proxy)
  - container runtime (Docker, rkt, or others)
- add-on components
  - DNS server
  - dashboard
  - ingress controller
  - heapster
  - container network interface network plugin



Kubernetes system components communicate only with the API server.
The API server is *the only component* that communicates with etcd.

Components on the worker nodes all need to run *on the same node*,
the components of the Control Plane can easily be split *across multiple servers.*


*** etcd

Kubernetes stores all its data in etcd under =/registry=.

**** Optimistic Concurrency Control

#+HTML: <img src="https://img.mukewang.com/5b5c698900010e0004970285.jpg"/>

All Kubernetes resources include a =metadata.resourceVersion= field, which clients need to pass back to the API server when updating an object. \\
If the version doesn't match the one stored in etcd, the API server rejects the update.


**** RAFT

[[http://thesecretlivesofdata.com/raft/][Understandable Distributed Consensus by Animation]]




*** API Server

[[file:img/k8s_api_server.png]]


- Authentication Plugins

  Extracts the client's username, user ID, and groups the user belongs to, that are then used in the next stage (Authorization).\\
  Plugins are called *in turn* until one of them determines who is sending the request.
- Authorization Plugins

  Determine whether the authenticated user can perform the requested action on the requested resource.\\
  Plugins are called *in turn* until one plugin says the user can perform the action.
- Admission Control Plugins
  Modify the resource (or other related resources). \\
  The resource passes through *all* plugins. \\
  When the request is _only trying to read data_, the request doesn't go through the Admission Control.


**** Resource Changes Notification

API server doesn't create resources. That's what *controllers in the Controller Manager* do. \\
Control Plane components can request *to be notified* when a resource is created, modified, or deleted.

[[file:img/k8s_api_server_notify.png]]






*** Scheduler

Scheduler *doesn't instruct the selected node* (or the Kubelet running on that node) to run the pod. \\
All the Scheduler does is update the pod definition through the API server. The API server then notifies the Kubelet
(through the WATCHING MECHANISM) that the pod has been scheduled.


*** Controller Manager

Actual work (create, update, delete...) is done by controllers running inside the Controller Manager.

[[file:img/k8s_controller_manager.png]]

(Replication Manager is a controller for ReplicationController resources)


*** Kublet

Kubelet is the component responsible for *everything* running on a worker node:

- Monitors running containers and reports their status, events, and resource consumption to the API server.
- Runs the container liveness probes, restarting containers when the probes fail.
- Terminates containers when their Pod is deleted from the API server and notifies the server that the pod has terminated.

**** Run Static Pods without API Server

Instead of running Kubernetes system components natively, you can put their pod manifests into the Kubelet's manifest directory
and have the Kubelet run and manage them.

[[file:img/k8s_kubelet.png]]

#+BEGIN_EXAMPLE
  You can also use the same method to run your custom system containers, but doing it through a DaemonSet is the recommended method.
#+END_EXAMPLE


*** Kube-Proxy

kube-proxy's purpose is to make sure clients can connect to the services you define through the Kubernetes API.

[[file:img/k8s_kubeproxy_iptables.png]]



*** Add-on

Add-on components are deployed as pods by submitting YAML manifests to the API server. \\
Some of these components are deployed through a Deployment resource or a ReplicationController resource, and some through a DaemonSet.




** Cooperation between controllers

[[file:img/k8s_controllers_cope.png]]

[[file:img/k8s_controllers_cope2.png]]




** Pod

*** Infrastructure Container

The _pause container_ is the infrastructure container that holds all the containers of a pod together. \\
All other user-defined containers of the pod then *use the namespaces* of the pod infrastructure container.

[[file:img/k8x_pod_infra_container.png]]

Actual application containers may die and get restarted. When such a container starts up again, it needs to become part of the same Linux namespaces as before. \\
If the infrastructure pod is killed in the meantime, the Kubelet *recreates it and all the pod’s containers.*

*** Inter-pod networking

The network is set up by Container Network Interface (CNI) plugin, not by Kubernetes itself.

**** Pods are connected NAT-less

[[file:img/k8s_pod_natless.png]]


**** Communication between nodes

Bridges across the nodes must use non-overlapping address ranges to prevent pods on different nodes from getting the same IP.

[[file:img/k8s_pod_communicate_between_nodes.png]]

- Node’s physical network interface needs to be con- nected to the bridge as well.
- Routing tables on node A need to be configured so all packets destined for 10.1.2.0/24 are routed to node B.
- Node B’s routing tables need to be configured so packets sent to 10.1.1.0/24 are routed to node A.

#+BEGIN_EXAMPLE
  This works only when nodes are connected to the same network switch, without any routers in between.

  It’s easier to use a Software Defined Network (SDN), which makes the nodes appear as though they’re connected to the same network switch,
  regardless of the actual underlying network topology, no matter how complex it is.
  Packets sent from the pod are encapsulated and sent over the network to the node running the other pod,
  where they are de-encapsulated and delivered to the pod in their original form.
#+END_EXAMPLE

**** Container Network Interface

To make it easier to connect containers into a network, a project called Container Network Interface (CNI) was started. \\
The CNI allows Kubernetes to be configured to use any CNI plugin that’s out there. These plugins include:

- Calico
- Flannel
- Romana
- Weave Net

See [[https://kubernetes.io/docs/concepts/cluster-administration/addons/][Reference]].



* 核心原理

** 资源对象

*** POD

**** 基本 YAML 定义



*apiVersion, kind, metadata, spec 是必填项*

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx
    labels:
      app: nginx
  spec:
    containers:
    - name: nginx
      image: nginx
      ports:
      - containerPort: 80
#+END_SRC






#+BEGIN_SRC sh
kubectl get pods
kubectl describe pod <pod_name>
#+END_SRC



**** 设计理念

Pod 是在 K8s 集群中运行部署应用或服务的最小单元，它是可以支持多容器的。

Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。

Pod 是 K8s 集群中所有业务类型的基础，不同类型的业务就需要不同类型的 *控制器* 去执行。

目前 K8s 中的业务主要可以分为：

- 长期伺服型 (long-running)
- 批处理型 (batch)
- 节点后台支撑型 (node-daemon)
- 有状态应用型 (stateful application)

分别对应的控制器类型为：

- Deployment
- Job
- DaemonSet
- StatefulSet

直接创建的 Pod 一旦被调度后就跟 Node 绑定，即使 Node 挂掉也不会被重新调度（ *而是被自动删除* ），因此推荐使用 Deployment、Daemonset 等控制器来容错。



**** 生命周期

- Pending :: Pod 已经在 apiserver 中创建，但还没有调度到 Node 上面
- Running :: Pod 已经调度到 Node 上面，所有容器都已经创建，并且至少有一个容器还在运行或者正在启动
- Succeeded :: Pod 调度到 Node 上面后成功运行结束，并且不会重启
- Failed :: Pod 调度到 Node 上面后至少有一个容器运行失败（即退出码不为 0 或者被系统终止）
- Unknonwn :: 状态未知，通常是由于 apiserver 无法与 kubelet 通信导致



**** 重启策略(restartPolicy)

PodSpec 中的 =restartPolicy= 可以用来设置是否对退出的 Pod 重启，可选项包括:

- Always :: 只要退出就重启
- OnFailure :: 失败退出（exit code 不等于 0）时重启
- Never :: 只要退出就不再重启

*注意，这里的重启是指在 Pod 所在 Node 上面本地重启，并不会调度到其他 Node 上去。*

- 单容器的 Pod ，容器成功退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: Pod phase 变成 Succeeded.
  - Never: Pod phase 变成 Succeeded.

- 单容器的 Pod ，容器失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: Pod phase 变成 Failed.

- 2 个容器的 Pod，其中一个容器在运行而另一个失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: 不重启 Container; Pod phase 保持 Running.

- 2 个容器的 Pod，其中一个容器停止而另一个失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: Pod phase 变成 Failed.

- 单容器的 Pod，容器内存不足（OOM），不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: 记录失败事件; Pod phase 变成 Failed.

其他情况的处理逻辑：

- Pod 还在运行，但磁盘不可访问时
  1. 终止所有容器
  2. Pod phase 变成 Failed
  3. 如果 Pod 是由某个控制器管理的，则重新创建一个 Pod 并调度到其他 Node 运行

- Pod 还在运行，但由于网络分区故障导致 Node 无法访问
  1. Node controller等待 Node 事件超时
  2. Node controller 将 Pod phase 设置为 Failed.
  3. 如果 Pod 是由某个控制器管理的，则重新创建一个 Pod 并调度到其他 Node 运行




**** 使用 Volume

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: redis
  spec:
    containers:
    - name: redis
      image: redis
      volumeMounts:
      - name: redis-storage
        mountPath: /data/redis
    volumes:
    - name: redis-storage
      emptyDir: {}

#+END_SRC



**** 环境变量

Pod 的名字、命名空间、IP 以及容器的计算资源限制等可以通过 [[https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/][Downward API]] 的方式获取并存储到环境变量中。



**** 镜像拉取策略(ImagePullPolicy)

支持三种 =ImagePullPolicy=:

- Always :: 不管镜像是否存在都会进行一次拉取
- Never :: 不管镜像是否存在都不会进行拉取
- IfNotPresent :: 只有镜像不存在时，才会进行镜像拉取

*注意：*

默认为 =IfNotPresent= ，但 :latest 标签的镜像默认为 =Always= 。

拉取镜像时 docker 会进行校验，如果镜像中的 MD5 码没有变，则不会拉取镜像数据。

生产环境中应该尽量避免使用 :latest 标签，而开发环境中可以借助 :latest 标签自动拉取最新的镜像。


**** DNS 策略

通过设置 =dnsPolicy= 参数，设置 Pod 中容器访问 DNS 的策略：

- ClusterFirst :: 优先基于 cluster domain （如 default.svc.cluster.local） 后缀，通过 kube-dns 查询 (默认策略)
- Default :: 优先从 Node 中配置的 DNS 查询


**** Health Probe

为了确保容器在部署后确实处在正常运行状态，Kubernetes 提供了两种探针（Probe）来探测容器的状态：

- LivenessProbe :: 探测应用是否处于健康状态，如果不健康则删除并重新创建容器
- ReadinessProbe :: 探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量

Kubernetes 支持三种方式来执行探针：

- exec :: 在容器中执行一个命令，如果 命令退出码 返回 0 则表示探测成功，否则表示失败
- tcpSocket :: 对指定的容器 IP 及端口执行一个 TCP 检查，如果端口是开放的则表示探测成功，否则表示失败
- httpGet :: 对指定的容器 IP、端口及路径执行一个 HTTP Get 请求，如果返回的 状态码 在 [200,400) 之间则表示探测成功，否则表示失败


#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
    name: nginx
  spec:
      containers:
      - image: nginx
        imagePullPolicy: Always
        name: http
        livenessProbe:
          httpGet:
            path: /
            port: 80
            httpHeaders:
            - name: X-Custom-Header
              value: Awesome
          initialDelaySeconds: 15
          timeoutSeconds: 1
        readinessProbe:
          exec:
            command:
            - cat
            - /usr/share/nginx/html/index.html
          initialDelaySeconds: 5
          timeoutSeconds: 1
      - name: goproxy
        image: gcr.io/google_containers/goproxy:0.1
        ports:
        - containerPort: 8080
        readinessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
#+END_SRC


**** 调度到指定 Node 上

可以通过 =nodeSelector=, =nodeAffinity=, =podAffinity= 以及 =Taints= 和 =tolerations= 等来将 Pod 调度到需要的 Node 上。

#+BEGIN_EXAMPLE yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx
    labels:
      env: test
  spec:
    containers:
    - name: nginx
      image: nginx
      imagePullPolicy: IfNotPresent
    nodeSelector:
      <label>: <value>
#+END_EXAMPLE


**** 常用命令

***** 查看 Pod 状态

=kubectl get pod <pod_name> -o jsonpath="{.status.phase}"=




*** Replica Set

ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，
并且 ReplicaSet 支持集合式的 selector（ReplicationController 仅支持等式）。

Deployment 使用了 Replica Set ，是更高一层的概念。
除非需要自定义升级功能或根本不需要升级 Pod ，一般情况下，推荐使用 Deployment 而不直接使用 Replica Set 。
这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持），
并且还支持版本记录、回滚、暂停升级等高级特性。


**** YAML 定义

=spec.template= 可以从 Pod 定义文件中复制过来：

[[file:img/k8s_replica-set-tmpl.png]]


**** 常用命令

#+BEGIN_SRC sh
kubectl replace -f rs-def.yml
kubectl scale --replicas=6 -f rs-def.yml
kubectl scale --replicas=6 replicaset <name>
#+END_SRC


* Utils

** YAML Basic

[[https://plugins.jetbrains.com/plugin/9354-kubernetes-and-openshift-resource-support][IDEA Kubernetes YAML 插件]]

*** Key Value Pair

#+BEGIN_SRC yaml
  fruit: apple
  vegetable: carrot
  liquid: water
  meat: chicken
#+END_SRC


*** Array / List

#+BEGIN_SRC yaml
  fruits:
    - orange
    - apple
    - banana

  vegetables:
    - carrot
    - cauliflower
    - tomato
#+END_SRC


*** Dictionary / Map

#+BEGIN_SRC yaml
  banana:
    calories: 105
    fat: 0.4
    carbs: 27

  grape:
    calories: 62
    fat: 0.3
    carbs: 16
#+END_SRC




** Bash completion

#+BEGIN_SRC sh
  source <(kubectl completion bash | sed s/kubectl/<your_alias>/g)
#+END_SRC


** Show all resources

#+BEGIN_SRC sh
  kubectl get
#+END_SRC


** Run Temporary Pod

#+BEGIN_SRC sh
  kubectl run -it srvlookup --image=tutum/dnsutils --rm --restart=Never -- dig SRV kubia.default.svc.cluster.local
#+END_SRC

The command runs a _one-off_ pod (--restart=Never) called srvlookup,
which is attached to the console (-it) and is deleted as soon as it terminates (--rm).

** Discover possible API object fields

#+BEGIN_SRC sh
  kubectl explain pods
#+END_SRC

You can then drill deeper to find out more about each attribute.

#+BEGIN_SRC sh
  kubectl explain pod.spec
#+END_SRC


** Quickly switch to a different namespace

#+BEGIN_SRC sh
  alias kcd='kubectl config set-context $(kubectl config current- context) --namespace '
#+END_SRC

You can then switch between namespaces using =kcd <some-namespace>=


** Forwarding a local network port to a port in the pod

Using port forwarding like this is an effective way to test an individual pod.

#+BEGIN_SRC sh
  kubectl port-forward <pod-name> <local-port>:<pod-port>
#+END_SRC


** Communicating with Pods through API Server

One useful feature of the API server is the ability to proxy connections directly to individual pods. \\
If you want to perform requests against your kubia-0 pod, you hit the following URL:
#+BEGIN_SRC sh
  <apiServerHost>:<port>/api/v1/namespaces/default/pods/kubia-0/proxy/<path>
#+END_SRC


** Connecting to Cluster-Internal Services through API Server

Instead of using a piggyback pod to access the service from inside the cluster, \\
you can use the same proxy feature provided by the API server to access the service:

#+BEGIN_SRC sh
 /api/v1/namespaces/<namespace>/services/<service name>/proxy/<path>
#+END_SRC


** Obtaining the application log of a crashed container

You can print the application’s log with kubectl logs. If your container is restarted, the kubectl logs command will show the log of the current container.

When you want to figure out why the previous container terminated, you’ll want to see those logs instead of the current container’s logs.
This can be done by using the =--previous= option:

#+BEGIN_SRC sh
  kubectl logs <pod> --previous
#+END_SRC


** Get IPs of all nodes

#+BEGIN_SRC sh
  kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="ExternalIP")].address}'
#+END_SRC

To learn more about how to use JSONPath with kubectl, refer to the [To learn more about how to use JSONPath with kubectl, refer to the [[http://kubernetes.io/docs/user-guide/jsonpath][documentation]].


** Talking to API Server

*** kubectl proxy

#+BEGIN_SRC sh
  kubectl proxy --port 8081
#+END_SRC

#+BEGIN_SRC sh
  curl http://localhost:8081
#+END_SRC


*** From in POD

#+BEGIN_SRC sh
  export CURL_CA_BUNDLE=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
  TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
  NS=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
  curl -H "Authorization: Bearer $TOKEN" https://kubernetes
  # Listing pods in the pod's own namespace
  curl -H "Authorization: Bearer $TOKEN" https://kubernetes/api/v1/namespaces/$NS/pods
#+END_SRC

[[file:img/k8s_api_server_access.png]]


- Using Ambassador Container

  [[file:img/k8s_api_server_ambassador.png]]


** Ways of modifying Deployments and other resources

*** edit

Opens the object's manifest in your default editor. \\
After making changes, saving the file, and exiting the editor, the object is updated.

Example: =kubectl edit deployment kubia=


*** patch

Modifies individual properties of an object. \\
Example:

#+BEGIN_SRC sh
  kubectl patch deployment kubia -p '{"spec": {"template": {"spec": {"containers": [{"name": "nodejs", "image": "luksa/kubia:v2"}]}}}}'
#+END_SRC


*** apply

Modifies the object by applying property values from a full YAML or JSON file. \\
If the object specified in the YAML/JSON *doesn't exist yet, it's created.* \\
The file needs to contain the *full* definition of the resource
(it can't include only the fields you want to update, as is the case with =kubectl patch=).

Example: =kubectl apply -f kubia-deployment-v2.yaml=


*** replace

Replaces the object with a new one from a YAML/JSON file. \\
In contrast to the apply command, this command *requires the object to exist*; otherwise it prints an error.

Example: =kubectl replace -f kubia-deployment-v2.yaml=

*** set image

Changes the container image defined in a Pod, ReplicationController's template, Deployment, DaemonSet, Job, or ReplicaSet.

Example: =kubectl set image deployment kubia nodejs=luksa/kubia:v2=


** Checking the status of the Control Plane components

#+BEGIN_SRC sh
$ kubectl get componentstatuses
NAME                 STATUS    MESSAGE            ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-0               Healthy   {"health": "true"}

#+END_SRC


** WATCHING Resources

#+BEGIN_SRC sh
  kubectl get po --watch
#+END_SRC


** Observing cluster events

Both the Control Plane components and the Kubelet *emit events to the API server as they perform these actions.*

If an event occurs multiple times, the event is displayed *only once* by =kubectl get events=,
showing when it was first seen, when it was last seen, and the number of times it occurred.

Watching events with the =--watch= option is much easier on the eyes and useful for seeing what’s happening in the cluster:

#+BEGIN_SRC sh
  kubectl get events --watch
#+END_SRC
