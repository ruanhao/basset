#+TITLE:     Kubernetes
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>
#+TOC: headlines 5



* Resources

** Pod

*** YAML Definition

定义文件主要包含：

1. API version
2. Resource type
3. Metadata \\
   Includes the name, namespace, labels, and other information about the pod.
4. Spec \\
   Contains the actual description of the pod’s contents, such as the pod’s con- tainers, volumes, and other data.
5. Status\\
   Contains read-only runtime data that shows the state of the resource at a given moment.\\
   *When creating a new pod, you never need to provide the status part.*


[[file:img/k8s_pod_def.png]]


*注意：*

在 POD 定义文件中定义 ports 是可选的行为，端口始终可以被访问，主要是为了方便用户清楚的了解提供了哪些服务。





*** Label

A label is an arbitrary key-value pair you attach to a resource, \\
which is then utilized when selecting resources using *label selectors* \\
(resources are filtered based on whether they include the label specified in the selector).

[[file:img/k8s_labels.png]]

A label selector can select resources based on whether the resource:

1. Contains (or doesn’t contain) a label with a certain key \\
2. Contains a label with a certain key and value \\
3. Contains a label with a certain key, but with a value not equal to the one you specify


*** Annotation

Annotations are also key-value pairs, so in essence, they’re similar to labels,
but they aren’t meant to hold identifying information.

They can’t be used to group objects the way labels can.
While objects can be selected through label selectors, *there’s no such thing as an annotation selector.*

Annotations can hold much larger pieces of information (up to 256 KB in total) and are primarily *meant to be used by tools.*

#+BEGIN_EXAMPLE
  Annotations are also commonly used when introducing new features to Kubernetes.
  Usually, alpha and beta versions of new features don’t introduce any new fields to API objects.
  Annotations are used instead of fields, and then once the required API changes have become clear and been agreed upon by the Kubernetes developers, new fields are introduced and the related annotations deprecated.

  A great use of annotations is adding descriptions for each pod or other API object, so that everyone using the cluster can quickly look up information about each individual object.
  For example, an annotation used to specify the name of the person who created the object can make collaboration between everyone working on the cluster much easier.
#+END_EXAMPLE


*** Deleting

By deleting a pod, you’re instructing Kubernetes to terminate all the containers that are part of that pod.

Kubernetes sends a *SIGTERM* signal to the process and waits a certain number of seconds (30 by default) for it to shut down gracefully.

If it doesn’t shut down in time, the process is then killed through *SIGKILL*.
To make sure your processes are always shut down gracefully, they need to handle the SIGTERM signal properly.

** ReplicaSet



* Internals

** Container Vs VM

[[file:img/k8s_container_vs_vm.png]]

file:img/k8s_container_vs_vm_cpu.png


** K8S components

[[file:img/k8s_components.png]]













* YAML

[[https://plugins.jetbrains.com/plugin/9354-kubernetes-and-openshift-resource-support][IDEA Kubernetes YAML 插件]]

** Key Value Pair

#+BEGIN_SRC yaml
  fruit: apple
  vegetable: carrot
  liquid: water
  meat: chicken
#+END_SRC


** Array / List

#+BEGIN_SRC yaml
  fruits:
    - orange
    - apple
    - banana

  vegetables:
    - carrot
    - cauliflower
    - tomato
#+END_SRC


** Dictionary / Map

#+BEGIN_SRC yaml
  banana:
    calories: 105
    fat: 0.4
    carbs: 27

  grape:
    calories: 62
    fat: 0.3
    carbs: 16
#+END_SRC


* 命令行

#+BEGIN_SRC sh
$ kubectl COMMAND RESOURCE OPTIONS
#+END_SRC



* 核心原理

** 资源对象

*** POD

**** 基本 YAML 定义



*apiVersion, kind, metadata, spec 是必填项*

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx
    labels:
      app: nginx
  spec:
    containers:
    - name: nginx
      image: nginx
      ports:
      - containerPort: 80
#+END_SRC






#+BEGIN_SRC sh
kubectl get pods
kubectl describe pod <pod_name>
#+END_SRC



**** 设计理念

Pod 是在 K8s 集群中运行部署应用或服务的最小单元，它是可以支持多容器的。

Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。

Pod 是 K8s 集群中所有业务类型的基础，不同类型的业务就需要不同类型的 *控制器* 去执行。

目前 K8s 中的业务主要可以分为：

- 长期伺服型 (long-running)
- 批处理型 (batch)
- 节点后台支撑型 (node-daemon)
- 有状态应用型 (stateful application)

分别对应的控制器类型为：

- Deployment
- Job
- DaemonSet
- StatefulSet

直接创建的 Pod 一旦被调度后就跟 Node 绑定，即使 Node 挂掉也不会被重新调度（ *而是被自动删除* ），因此推荐使用 Deployment、Daemonset 等控制器来容错。



**** 生命周期

- Pending :: Pod 已经在 apiserver 中创建，但还没有调度到 Node 上面
- Running :: Pod 已经调度到 Node 上面，所有容器都已经创建，并且至少有一个容器还在运行或者正在启动
- Succeeded :: Pod 调度到 Node 上面后成功运行结束，并且不会重启
- Failed :: Pod 调度到 Node 上面后至少有一个容器运行失败（即退出码不为 0 或者被系统终止）
- Unknonwn :: 状态未知，通常是由于 apiserver 无法与 kubelet 通信导致



**** 重启策略(restartPolicy)

PodSpec 中的 =restartPolicy= 可以用来设置是否对退出的 Pod 重启，可选项包括:

- Always :: 只要退出就重启
- OnFailure :: 失败退出（exit code 不等于 0）时重启
- Never :: 只要退出就不再重启

*注意，这里的重启是指在 Pod 所在 Node 上面本地重启，并不会调度到其他 Node 上去。*

- 单容器的 Pod ，容器成功退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: Pod phase 变成 Succeeded.
  - Never: Pod phase 变成 Succeeded.

- 单容器的 Pod ，容器失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: Pod phase 变成 Failed.

- 2 个容器的 Pod，其中一个容器在运行而另一个失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: 不重启 Container; Pod phase 保持 Running.

- 2 个容器的 Pod，其中一个容器停止而另一个失败退出时，不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: Pod phase 变成 Failed.

- 单容器的 Pod，容器内存不足（OOM），不同 restartPolicy 时的动作为
  - Always: 重启 Container; Pod phase 保持 Running.
  - OnFailure: 重启 Container; Pod phase 保持 Running.
  - Never: 记录失败事件; Pod phase 变成 Failed.

其他情况的处理逻辑：

- Pod 还在运行，但磁盘不可访问时
  1. 终止所有容器
  2. Pod phase 变成 Failed
  3. 如果 Pod 是由某个控制器管理的，则重新创建一个 Pod 并调度到其他 Node 运行

- Pod 还在运行，但由于网络分区故障导致 Node 无法访问
  1. Node controller等待 Node 事件超时
  2. Node controller 将 Pod phase 设置为 Failed.
  3. 如果 Pod 是由某个控制器管理的，则重新创建一个 Pod 并调度到其他 Node 运行




**** 使用 Volume

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: redis
  spec:
    containers:
    - name: redis
      image: redis
      volumeMounts:
      - name: redis-storage
        mountPath: /data/redis
    volumes:
    - name: redis-storage
      emptyDir: {}

#+END_SRC



**** 环境变量

Pod 的名字、命名空间、IP 以及容器的计算资源限制等可以通过 [[https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/][Downward API]] 的方式获取并存储到环境变量中。



**** 镜像拉取策略(ImagePullPolicy)

支持三种 =ImagePullPolicy=:

- Always :: 不管镜像是否存在都会进行一次拉取
- Never :: 不管镜像是否存在都不会进行拉取
- IfNotPresent :: 只有镜像不存在时，才会进行镜像拉取

*注意：*

默认为 =IfNotPresent= ，但 :latest 标签的镜像默认为 =Always= 。

拉取镜像时 docker 会进行校验，如果镜像中的 MD5 码没有变，则不会拉取镜像数据。

生产环境中应该尽量避免使用 :latest 标签，而开发环境中可以借助 :latest 标签自动拉取最新的镜像。


**** DNS 策略

通过设置 =dnsPolicy= 参数，设置 Pod 中容器访问 DNS 的策略：

- ClusterFirst :: 优先基于 cluster domain （如 default.svc.cluster.local） 后缀，通过 kube-dns 查询 (默认策略)
- Default :: 优先从 Node 中配置的 DNS 查询


**** Health Probe

为了确保容器在部署后确实处在正常运行状态，Kubernetes 提供了两种探针（Probe）来探测容器的状态：

- LivenessProbe :: 探测应用是否处于健康状态，如果不健康则删除并重新创建容器
- ReadinessProbe :: 探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量

Kubernetes 支持三种方式来执行探针：

- exec :: 在容器中执行一个命令，如果 命令退出码 返回 0 则表示探测成功，否则表示失败
- tcpSocket :: 对指定的容器 IP 及端口执行一个 TCP 检查，如果端口是开放的则表示探测成功，否则表示失败
- httpGet :: 对指定的容器 IP、端口及路径执行一个 HTTP Get 请求，如果返回的 状态码 在 [200,400) 之间则表示探测成功，否则表示失败


#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
    name: nginx
  spec:
      containers:
      - image: nginx
        imagePullPolicy: Always
        name: http
        livenessProbe:
          httpGet:
            path: /
            port: 80
            httpHeaders:
            - name: X-Custom-Header
              value: Awesome
          initialDelaySeconds: 15
          timeoutSeconds: 1
        readinessProbe:
          exec:
            command:
            - cat
            - /usr/share/nginx/html/index.html
          initialDelaySeconds: 5
          timeoutSeconds: 1
      - name: goproxy
        image: gcr.io/google_containers/goproxy:0.1
        ports:
        - containerPort: 8080
        readinessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
#+END_SRC


**** 调度到指定 Node 上

可以通过 =nodeSelector=, =nodeAffinity=, =podAffinity= 以及 =Taints= 和 =tolerations= 等来将 Pod 调度到需要的 Node 上。

#+BEGIN_EXAMPLE yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx
    labels:
      env: test
  spec:
    containers:
    - name: nginx
      image: nginx
      imagePullPolicy: IfNotPresent
    nodeSelector:
      <label>: <value>
#+END_EXAMPLE


**** 常用命令

***** 查看 Pod 状态

=kubectl get pod <pod_name> -o jsonpath="{.status.phase}"=



*** Deployment



*** Replica Set

ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，
并且 ReplicaSet 支持集合式的 selector（ReplicationController 仅支持等式）。

Deployment 使用了 Replica Set ，是更高一层的概念。
除非需要自定义升级功能或根本不需要升级 Pod ，一般情况下，推荐使用 Deployment 而不直接使用 Replica Set 。
这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持），
并且还支持版本记录、回滚、暂停升级等高级特性。


**** YAML 定义

=spec.template= 可以从 Pod 定义文件中复制过来：

[[file:img/k8s_replica-set-tmpl.png]]


**** 常用命令

#+BEGIN_SRC sh
kubectl replace -f rs-def.yml
kubectl scale --replicas=6 -f rs-def.yml
kubectl scale --replicas=6 replicaset <name>
#+END_SRC


* Utils

** Bash completion

#+BEGIN_SRC sh
  source <(kubectl completion bash | sed s/kubectl/<your_alias>/g)
#+END_SRC


** Show all resources

#+BEGIN_SRC sh
  kubectl get
#+END_SRC

** Discover possible API object fields

#+BEGIN_SRC sh
  kubectl explain pods
#+END_SRC

You can then drill deeper to find out more about each attribute.

#+BEGIN_SRC sh
  kubectl explain pod.spec
#+END_SRC

** Quickly switch to a different namespace

#+BEGIN_SRC sh
  alias kcd='kubectl config set-context $(kubectl config current- context) --namespace '
#+END_SRC

You can then switch between namespaces using =kcd <some-namespace>=

** Forwarding a local network port to a port in the pod

Using port forwarding like this is an effective way to test an individual pod.

#+BEGIN_SRC sh
  kubectl port-forward <pod-name> <local-port>:<pod-port>
#+END_SRC
