#+TITLE:     Ansible
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS: h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author | {{{author}}} ({{{email}}})    |
| Date   | {{{time(%Y-%m-%d %H:%M:%S)}}} |

#+HTML: <pre class="example">
Ansible is used to:
  -> execute /tasks/ for an /inventory/,
  -> utilizing some /modules/,
  -> using or populating some /variables/,
  -> processing some file /templates/,
  -> in a /playbook/, which can be organized in /roles/.
#+HTML: </pre>

#+HTML: </div>
#+TOC: headlines 5

* 工作架构与原理

#+HTML: <img src="https://qiankunli.github.io/public/upload/tool/ansible_framework.png"/>

** 相关配置文件

*** 主配置文件 (=/etc/ansible/ansible.cfg=)

#+BEGIN_SRC sh

  # config file for ansible -- https://ansible.com/
  # ===============================================

  # nearly all parameters can be overridden in ansible-playbook
  # or with command line flags. ansible will read ANSIBLE_CONFIG,
  # ansible.cfg in the current working directory, .ansible.cfg in
  # the home directory or /etc/ansible/ansible.cfg, whichever it
  # finds first

  [defaults]

  # some basic default values...

  #inventory      = /etc/ansible/hosts
  #library        = /usr/share/my_modules/
  #module_utils   = /usr/share/my_module_utils/
  #remote_tmp     = ~/.ansible/tmp
  #local_tmp      = ~/.ansible/tmp
  #plugin_filters_cfg = /etc/ansible/plugin_filters.yml
  #forks          = 5
  #poll_interval  = 15
  #sudo_user      = root
  #ask_sudo_pass = True
  #ask_pass      = True
  #transport      = smart
  #remote_port    = 22
  #module_lang    = C
  #module_set_locale = False

  # plays will gather facts by default, which contain information about
  # the remote system.
  #
  # smart - gather by default, but don't regather if already gathered
  # implicit - gather by default, turn off with gather_facts: False
  # explicit - do not gather by default, must say gather_facts: True
  #gathering = implicit

  # This only affects the gathering done by a play's gather_facts directive,
  # by default gathering retrieves all facts subsets
  # all - gather all subsets
  # network - gather min and network facts
  # hardware - gather hardware facts (longest facts to retrieve)
  # virtual - gather min and virtual facts
  # facter - import facts from facter
  # ohai - import facts from ohai
  # You can combine them using comma (ex: network,virtual)
  # You can negate them using ! (ex: !hardware,!facter,!ohai)
  # A minimal set of facts is always gathered.
  #gather_subset = all

  # some hardware related facts are collected
  # with a maximum timeout of 10 seconds. This
  # option lets you increase or decrease that
  # timeout to something more suitable for the
  # environment.
  # gather_timeout = 10

  # Ansible facts are available inside the ansible_facts.* dictionary
  # namespace. This setting maintains the behaviour which was the default prior
  # to 2.5, duplicating these variables into the main namespace, each with a
  # prefix of 'ansible_'.
  # This variable is set to True by default for backwards compatibility. It
  # will be changed to a default of 'False' in a future release.
  # ansible_facts.
  # inject_facts_as_vars = True

  # additional paths to search for roles in, colon separated
  #roles_path    = /etc/ansible/roles

  # uncomment this to disable SSH key host checking
  host_key_checking = False # 检查对应服务器的 host_key ，建议取消注释

  # change the default callback, you can only have one 'stdout' type  enabled at a time.
  #stdout_callback = skippy


  ## Ansible ships with some plugins that require whitelisting,
  ## this is done to avoid running all of a type by default.
  ## These setting lists those that you want enabled for your system.
  ## Custom plugins should not need this unless plugin author specifies it.

  # enable callback plugins, they can output to stdout but cannot be 'stdout' type.
  #callback_whitelist = timer, mail

  # Determine whether includes in tasks and handlers are "static" by
  # default. As of 2.0, includes are dynamic by default. Setting these
  # values to True will make includes behave more like they did in the
  # 1.x versions.
  #task_includes_static = False
  #handler_includes_static = False

  # Controls if a missing handler for a notification event is an error or a warning
  #error_on_missing_handler = True

  # change this for alternative sudo implementations
  #sudo_exe = sudo

  # What flags to pass to sudo
  # WARNING: leaving out the defaults might create unexpected behaviours
  #sudo_flags = -H -S -n

  # SSH timeout
  #timeout = 10

  # default user to use for playbooks if user is not specified
  # (/usr/bin/ansible will use current user as default)
  #remote_user = root

  # logging is off by default unless this path is defined
  # if so defined, consider logrotate
  log_path = /var/log/ansible.log # 日志文件位置

  # default module name for /usr/bin/ansible
  #module_name = command

  # use this shell for commands executed under sudo
  # you may need to change this to bin/bash in rare instances
  # if sudo is constrained
  #executable = /bin/sh

  # if inventory variables overlap, does the higher precedence one win
  # or are hash values merged together?  The default is 'replace' but
  # this can also be set to 'merge'.
  #hash_behaviour = replace

  # by default, variables from roles will be visible in the global variable
  # scope. To prevent this, the following option can be enabled, and only
  # tasks and handlers within the role will see the variables there
  #private_role_vars = yes

  # list any Jinja2 extensions to enable here:
  #jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n

  # if set, always use this private key file for authentication, same as
  # if passing --private-key to ansible or ansible-playbook
  #private_key_file = /path/to/file

  # If set, configures the path to the Vault password file as an alternative to
  # specifying --vault-password-file on the command line.
  #vault_password_file = /path/to/vault_password_file

  # format of string {{ ansible_managed }} available within Jinja2
  # templates indicates to users editing templates files will be replaced.
  # replacing {file}, {host} and {uid} and strftime codes with proper values.
  #ansible_managed = Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}
  # {file}, {host}, {uid}, and the timestamp can all interfere with idempotence
  # in some situations so the default is a static string:
  #ansible_managed = Ansible managed

  # by default, ansible-playbook will display "Skipping [host]" if it determines a task
  # should not be run on a host.  Set this to "False" if you don't want to see these "Skipping"
  # messages. NOTE: the task header will still be shown regardless of whether or not the
  # task is skipped.
  #display_skipped_hosts = True

  # by default, if a task in a playbook does not include a name: field then
  # ansible-playbook will construct a header that includes the task's action but
  # not the task's args.  This is a security feature because ansible cannot know
  # if the *module* considers an argument to be no_log at the time that the
  # header is printed.  If your environment doesn't have a problem securing
  # stdout from ansible-playbook (or you have manually specified no_log in your
  # playbook on all of the tasks where you have secret information) then you can
  # safely set this to True to get more informative messages.
  #display_args_to_stdout = False

  # by default (as of 1.3), Ansible will raise errors when attempting to dereference
  # Jinja2 variables that are not set in templates or action lines. Uncomment this line
  # to revert the behavior to pre-1.3.
  #error_on_undefined_vars = False

  # by default (as of 1.6), Ansible may display warnings based on the configuration of the
  # system running ansible itself. This may include warnings about 3rd party packages or
  # other conditions that should be resolved if possible.
  # to disable these warnings, set the following value to False:
  #system_warnings = True

  # by default (as of 1.4), Ansible may display deprecation warnings for language
  # features that should no longer be used and will be removed in future versions.
  # to disable these warnings, set the following value to False:
  #deprecation_warnings = True

  # (as of 1.8), Ansible can optionally warn when usage of the shell and
  # command module appear to be simplified by using a default Ansible module
  # instead.  These warnings can be silenced by adjusting the following
  # setting or adding warn=yes or warn=no to the end of the command line
  # parameter string.  This will for example suggest using the git module
  # instead of shelling out to the git command.
  # command_warnings = False


  # set plugin path directories here, separate with colons
  #action_plugins     = /usr/share/ansible/plugins/action
  #become_plugins     = /usr/share/ansible/plugins/become
  #cache_plugins      = /usr/share/ansible/plugins/cache
  #callback_plugins   = /usr/share/ansible/plugins/callback
  #connection_plugins = /usr/share/ansible/plugins/connection
  #lookup_plugins     = /usr/share/ansible/plugins/lookup
  #inventory_plugins  = /usr/share/ansible/plugins/inventory
  #vars_plugins       = /usr/share/ansible/plugins/vars
  #filter_plugins     = /usr/share/ansible/plugins/filter
  #test_plugins       = /usr/share/ansible/plugins/test
  #terminal_plugins   = /usr/share/ansible/plugins/terminal
  #strategy_plugins   = /usr/share/ansible/plugins/strategy


  # by default, ansible will use the 'linear' strategy but you may want to try
  # another one
  #strategy = free

  # by default callbacks are not loaded for /bin/ansible, enable this if you
  # want, for example, a notification or logging callback to also apply to
  # /bin/ansible runs
  #bin_ansible_callbacks = False


  # don't like cows?  that's unfortunate.
  # set to 1 if you don't want cowsay support or export ANSIBLE_NOCOWS=1
  #nocows = 1

  # set which cowsay stencil you'd like to use by default. When set to 'random',
  # a random stencil will be selected for each task. The selection will be filtered
  # against the `cow_whitelist` option below.
  #cow_selection = default
  #cow_selection = random

  # when using the 'random' option for cowsay, stencils will be restricted to this list.
  # it should be formatted as a comma-separated list with no spaces between names.
  # NOTE: line continuations here are for formatting purposes only, as the INI parser
  #       in python does not support them.
  #cow_whitelist=bud-frogs,bunny,cheese,daemon,default,dragon,elephant-in-snake,elephant,eyes,\
  #              hellokitty,kitty,luke-koala,meow,milk,moofasa,moose,ren,sheep,small,stegosaurus,\
  #              stimpy,supermilker,three-eyes,turkey,turtle,tux,udder,vader-koala,vader,www

  # don't like colors either?
  # set to 1 if you don't want colors, or export ANSIBLE_NOCOLOR=1
  #nocolor = 1

  # if set to a persistent type (not 'memory', for example 'redis') fact values
  # from previous runs in Ansible will be stored.  This may be useful when
  # wanting to use, for example, IP information from one group of servers
  # without having to talk to them in the same playbook run to get their
  # current IP information.
  #fact_caching = memory

  #This option tells Ansible where to cache facts. The value is plugin dependent.
  #For the jsonfile plugin, it should be a path to a local directory.
  #For the redis plugin, the value is a host:port:database triplet: fact_caching_connection = localhost:6379:0

  #fact_caching_connection=/tmp



  # retry files
  # When a playbook fails a .retry file can be created that will be placed in ~/
  # You can enable this feature by setting retry_files_enabled to True
  # and you can change the location of the files by setting retry_files_save_path

  #retry_files_enabled = False
  #retry_files_save_path = ~/.ansible-retry

  # squash actions
  # Ansible can optimise actions that call modules with list parameters
  # when looping. Instead of calling the module once per with_ item, the
  # module is called once with all items at once. Currently this only works
  # under limited circumstances, and only with parameters named 'name'.
  #squash_actions = apk,apt,dnf,homebrew,pacman,pkgng,yum,zypper

  # prevents logging of task data, off by default
  #no_log = False

  # prevents logging of tasks, but only on the targets, data is still logged on the master/controller
  #no_target_syslog = False

  # controls whether Ansible will raise an error or warning if a task has no
  # choice but to create world readable temporary files to execute a module on
  # the remote machine.  This option is False by default for security.  Users may
  # turn this on to have behaviour more like Ansible prior to 2.1.x.  See
  # https://docs.ansible.com/ansible/become.html#becoming-an-unprivileged-user
  # for more secure ways to fix this than enabling this option.
  #allow_world_readable_tmpfiles = False

  # controls the compression level of variables sent to
  # worker processes. At the default of 0, no compression
  # is used. This value must be an integer from 0 to 9.
  #var_compression_level = 9

  # controls what compression method is used for new-style ansible modules when
  # they are sent to the remote system.  The compression types depend on having
  # support compiled into both the controller's python and the client's python.
  # The names should match with the python Zipfile compression types:
  # * ZIP_STORED (no compression. available everywhere)
  # * ZIP_DEFLATED (uses zlib, the default)
  # These values may be set per host via the ansible_module_compression inventory
  # variable
  #module_compression = 'ZIP_DEFLATED'

  # This controls the cutoff point (in bytes) on --diff for files
  # set to 0 for unlimited (RAM may suffer!).
  #max_diff_size = 1048576

  # This controls how ansible handles multiple --tags and --skip-tags arguments
  # on the CLI.  If this is True then multiple arguments are merged together.  If
  # it is False, then the last specified argument is used and the others are ignored.
  # This option will be removed in 2.8.
  #merge_multiple_cli_flags = True

  # Controls showing custom stats at the end, off by default
  #show_custom_stats = True

  # Controls which files to ignore when using a directory as inventory with
  # possibly multiple sources (both static and dynamic)
  #inventory_ignore_extensions = ~, .orig, .bak, .ini, .cfg, .retry, .pyc, .pyo

  # This family of modules use an alternative execution path optimized for network appliances
  # only update this setting if you know how this works, otherwise it can break module execution
  #network_group_modules=eos, nxos, ios, iosxr, junos, vyos

  # When enabled, this option allows lookups (via variables like {{lookup('foo')}} or when used as
  # a loop with `with_foo`) to return data that is not marked "unsafe". This means the data may contain
  # jinja2 templating language which will be run through the templating engine.
  # ENABLING THIS COULD BE A SECURITY RISK
  #allow_unsafe_lookups = False

  # set default errors for all plays
  #any_errors_fatal = False

  [inventory]
  # enable inventory plugins, default: 'host_list', 'script', 'auto', 'yaml', 'ini', 'toml'
  #enable_plugins = host_list, virtualbox, yaml, constructed

  # ignore these extensions when parsing a directory as inventory source
  #ignore_extensions = .pyc, .pyo, .swp, .bak, ~, .rpm, .md, .txt, ~, .orig, .ini, .cfg, .retry

  # ignore files matching these patterns when parsing a directory as inventory source
  #ignore_patterns=

  # If 'true' unparsed inventory sources become fatal errors, they are warnings otherwise.
  #unparsed_is_failed=False

  [privilege_escalation]
  #become=True
  #become_method=sudo
  #become_user=root
  #become_ask_pass=False

  [paramiko_connection]

  # uncomment this line to cause the paramiko connection plugin to not record new host
  # keys encountered.  Increases performance on new host additions.  Setting works independently of the
  # host key checking setting above.
  #record_host_keys=False

  # by default, Ansible requests a pseudo-terminal for commands executed under sudo. Uncomment this
  # line to disable this behaviour.
  #pty=False

  # paramiko will default to looking for SSH keys initially when trying to
  # authenticate to remote devices.  This is a problem for some network devices
  # that close the connection after a key failure.  Uncomment this line to
  # disable the Paramiko look for keys function
  #look_for_keys = False

  # When using persistent connections with Paramiko, the connection runs in a
  # background process.  If the host doesn't already have a valid SSH key, by
  # default Ansible will prompt to add the host key.  This will cause connections
  # running in background processes to fail.  Uncomment this line to have
  # Paramiko automatically add host keys.
  #host_key_auto_add = True

  [ssh_connection]

  # ssh arguments to use
  # Leaving off ControlPersist will result in poor performance, so use
  # paramiko on older platforms rather than removing it, -C controls compression use
  #ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s

  # The base directory for the ControlPath sockets.
  # This is the "%(directory)s" in the control_path option
  #
  # Example:
  # control_path_dir = /tmp/.ansible/cp
  #control_path_dir = ~/.ansible/cp

  # The path to use for the ControlPath sockets. This defaults to a hashed string of the hostname,
  # port and username (empty string in the config). The hash mitigates a common problem users
  # found with long hostnames and the conventional %(directory)s/ansible-ssh-%%h-%%p-%%r format.
  # In those cases, a "too long for Unix domain socket" ssh error would occur.
  #
  # Example:
  # control_path = %(directory)s/%%h-%%r
  #control_path =

  # Enabling pipelining reduces the number of SSH operations required to
  # execute a module on the remote server. This can result in a significant
  # performance improvement when enabled, however when using "sudo:" you must
  # first disable 'requiretty' in /etc/sudoers
  #
  # By default, this option is disabled to preserve compatibility with
  # sudoers configurations that have requiretty (the default on many distros).
  #
  #pipelining = False

  # Control the mechanism for transferring files (old)
  #   * smart = try sftp and then try scp [default]
  #   * True = use scp only
  #   * False = use sftp only
  #scp_if_ssh = smart

  # Control the mechanism for transferring files (new)
  # If set, this will override the scp_if_ssh option
  #   * sftp  = use sftp to transfer files
  #   * scp   = use scp to transfer files
  #   * piped = use 'dd' over SSH to transfer files
  #   * smart = try sftp, scp, and piped, in that order [default]
  #transfer_method = smart

  # if False, sftp will not use batch mode to transfer files. This may cause some
  # types of file transfer failures impossible to catch however, and should
  # only be disabled if your sftp version has problems with batch mode
  #sftp_batch_mode = False

  # The -tt argument is passed to ssh when pipelining is not enabled because sudo
  # requires a tty by default.
  #usetty = True

  # Number of times to retry an SSH connection to a host, in case of UNREACHABLE.
  # For each retry attempt, there is an exponential backoff,
  # so after the first attempt there is 1s wait, then 2s, 4s etc. up to 30s (max).
  #retries = 3

  [persistent_connection]

  # Configures the persistent connection timeout value in seconds.  This value is
  # how long the persistent connection will remain idle before it is destroyed.
  # If the connection doesn't receive a request before the timeout value
  # expires, the connection is shutdown. The default value is 30 seconds.
  #connect_timeout = 30

  # The command timeout value defines the amount of time to wait for a command
  # or RPC call before timing out. The value for the command timeout must
  # be less than the value of the persistent connection idle timeout (connect_timeout)
  # The default value is 30 second.
  #command_timeout = 30

  [accelerate]
  #accelerate_port = 5099
  #accelerate_timeout = 30
  #accelerate_connect_timeout = 5.0

  # The daemon timeout is measured in minutes. This time is measured
  # from the last activity to the accelerate daemon.
  #accelerate_daemon_timeout = 30

  # If set to yes, accelerate_multi_key will allow multiple
  # private keys to be uploaded to it, though each user must
  # have access to the system via SSH to add a new key. The default
  # is "no".
  #accelerate_multi_key = yes

  [selinux]
  # file systems that require special treatment when dealing with security context
  # the default behaviour that copies the existing context or uses the user default
  # needs to be changed to use the file system dependent context.
  #special_context_filesystems=nfs,vboxsf,fuse,ramfs,9p,vfat

  # Set this to yes to allow libvirt_lxc connections to work without SELinux.
  #libvirt_lxc_noseclabel = yes

  [colors]
  #highlight = white
  #verbose = blue
  #warn = bright purple
  #error = red
  #debug = dark gray
  #deprecate = purple
  #skip = cyan
  #unreachable = red
  #ok = green
  #changed = yellow
  #diff_add = green
  #diff_remove = red
  #diff_lines = cyan


  [diff]
  # Always print diff when running ( same as always running with -D/--diff )
  # always = no

  # Set how many context lines to show in diff
  # context = 3
#+END_SRC

*** 主机清单配置文件 (=/etc/ansible/hosts=)

**** 对主机进行分组

#+BEGIN_SRC sh
  [master]
  server-master        ansible_ssh_host=10.0.0.5    ansible_ssh_user=ubuntu ansible_sudo_pass=!qaz2wsx

  [standbys]
  server-standby-01    ansible_ssh_host=10.0.0.6    ansible_ssh_user=ubuntu
  server-standby-02    ansible_ssh_host=10.0.0.7    ansible_ssh_user=ubuntu

  [replication]
  master
  standbys
#+END_SRC


** 相关命令

*** 临时命令执行工具 (=/usr/bin/ansible=)

**** 执行过程

1. 加载配置文件 =ansible.cfg=
2. 加载模块文件
3. 将模块生成的临时 python 文件传输至服务器
4. 执行并返回结果
5. 删除临时 python 文件
6. 退出

**** 执行状态

- 绿色
  执行成功且无改变的操作
- 黄色
  执行成功且对目标主机做出改变的操作
- 红色
  执行失败

**** 显示所有主机

=ansible all --list=


*** 模块查看工具 (=/usr/bin/ansible-doc=)

**** 显示所有模块

=ansible-doc -l=


**** 查看模块用法
=ansible-doc [-s] <module_name>=


*** 模块下载工具 (=/usr/bin/ansible-galaxy=)

用于从 galaxy 服务器上下载相应的 Role 。

使用 =ansible-galaxy list= 列出已安装的 galaxy 。

#+BEGIN_SRC sh
  > ansible-galaxy install geerlingguy.nginx
  > tree ~/.ansible/roles/geerlingguy.nginx
  ~/.ansible/roles/geerlingguy.nginx
  ├── LICENSE
  ├── README.md
  ├── defaults
  │   └── main.yml
  ├── handlers
  │   └── main.yml
  ├── meta
  │   └── main.yml
  ├── molecule
  │   └── default
  │       ├── molecule.yml
  │       ├── playbook.yml
  │       └── yaml-lint.yml
  ├── tasks
  │   ├── main.yml
  │   ├── setup-Archlinux.yml
  │   ├── setup-Debian.yml
  │   ├── setup-FreeBSD.yml
  │   ├── setup-OpenBSD.yml
  │   ├── setup-RedHat.yml
  │   ├── setup-Ubuntu.yml
  │   └── vhosts.yml
  ├── templates
  │   ├── nginx.conf.j2
  │   ├── nginx.repo.j2
  │   └── vhost.j2
  └── vars
      ├── Archlinux.yml
      ├── Debian.yml
      ├── FreeBSD.yml
      ├── OpenBSD.yml
      └── RedHat.yml
#+END_SRC


*** 编排剧本工具 (=/usr/bin/ansible-playbook=)


*** 文件加密工具 (=/usr/bin/ansible-vault=)



* 模块 (Module)

** 远程执行

*** command (默认模块)

*对管道和特殊字符的支持有限，可以选择使用 shell 模块*

#+BEGIN_SRC sh
  ansible all -a 'df -h'
  ansible all -a 'chdir=/tmp ls' # 切换目录

#+END_SRC

- creates ::

  指定一个文件名，如果给文件存在，则不执行。

- removes ::

  指定一个文件名，如果给文件不存在，则不执行。

- chdir ::

  执行命令前，切换到指定目录。


*** shell

和 =command= 类似， *但支持管道与特殊字符* 。


#+BEGIN_SRC sh
  ansible all -m shell -b -a 'useradd haoru'
  ansible all -m shell -b -a 'echo haoru:mypassword | chpasswd' # 修改密码
  ansible all -m shell -a 'getent passwd haoru'
#+END_SRC


*** script

#+BEGIN_SRC sh
  ansible all -m script -a '/path/to/local/script.sh'
#+END_SRC


** 文件管理

*** copy

#+BEGIN_SRC sh
  ansible all -m copy -a 'src=/path/to/local/file dest=/path/to/remote/file backup=yes mode=777 owner=root'
  ansible all -m copy -a 'content="hello\nworld" dest=/path/to/remote/file'

#+END_SRC

- src

  本地文件地址，可以是绝对路径，也可以是相对路径。 如果路径是一个目录，它将递归复制。

  如果路径使用 =/= 来结尾，则只复制目录里的内容；\\
  如果没有使用 =/= 来结尾，则包含目录在内的整个内容全部复制，类似于 =rsync= 。
- dest

  远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录。



*** fetch

从服务器下载文件，和 =copy= 作用相反。（ _当前不支持下载目录_ ）

#+BEGIN_SRC sh
  ansible all -m fetch -a 'src=~/test.txt dest=/tmp'
#+END_SRC


*** file

设置文件属性

#+BEGIN_SRC sh
  ansible all -m file -a 'dest=/tmp/test.txt state=touch' # 创建文件
  ansible all -m file -a 'dest=/tmp/test.txt state=absent' # 删除文件
  ansible all -m file -a 'dest=/tmp/testdir state=directory' # 创建文件夹
  ansible all -m file -a 'src=/etc/fstab dest=/tmp/fstab.link state=link' # 创建软链接
#+END_SRC


*** synchronize

#+BEGIN_SRC sh
  synchronize: src=some/relative/path dest=/some/absolute/path rsync_path="sudo rsync"
  synchronize: src=some/relative/path dest=/some/absolute/path archive=no   links=yes
  synchronize: src=some/relative/path dest=/some/absolute/path checksum=yes times=no
  synchronize: src=some/relative/path dest=/some/absolute/path rsync_opts=--no-motd,--exclude=.git mode=pull
#+END_SRC



*** get_url

#+BEGIN_SRC sh
  get_url: url=http://example.com/path/file.conf dest=/etc/foo.conf mode=0440
#+END_SRC





** 网络管理

*** ping

=ansible <pattern> -m ping=


** 服务管理

*** service

- enabled

  是否开机启动
- name

  服务名称
- pattern

  就会通过 =ps= 命令在进程中根据该模式进行查找，如果找到，则认为该服务依然在运行。
- sleep

  如果执行了 =restarted= ，在则 stop 和 start 之间等待几秒。
- state

  =started= , =stopped= , =restarted= , =reloaded=


#+BEGIN_SRC sh
  service: name=httpd state=started enabled=yes
  service: name=foo pattern=/usr/bin/foo state=started # 若启动后发现 /usr/bin/foo 这个进程存在，则认为启动成功

  ansible all -m service -a 'name=vsftpd state=started enabled=true'
  ansible all -a 'systemctl is-enabled vsftpd'
  ansible all -a 'systemctl status vsftpd'
#+END_SRC


*** cron

- backup ::

  先备份原任务计划内容


- job ::

  执行的任务（命令）

- name ::

  任务的描述


- special_time ::

  =reboot= , =yearly= , =annually= , =monthly= , =weekly= , =daily= , =hourly=


- state ::

  创建 (=present=) / 删除(=absent=)

- user ::

  执行用户身份


#+BEGIN_SRC sh
  cron: name=do_something_when_reboot special_time=reboot job="/some/job.sh"
  cron: name=do_something_when_reboot state=absent

  ansible all -m cron -a 'minute=* weekday=1,3,5 job="/usr/bin/wall hello" name=warningcron'
#+END_SRC



** 用户（组）管理

*** user

#+BEGIN_SRC sh
  ansible all -m user -a 'name=nginx shell=/sbin/nologin system=yes home=/var/nginx groups=root,bin comment="nginx service"'
  ansible all -m user -a 'name=nginx state=absent remove=yes' # 删除用户，包括家目录
#+END_SRC

- system

  是否是系统账号

*** group

#+BEGIN_SRC sh
  ansible all -m group -a 'name=nginx system=yes'
#+END_SRC


** 主机信息

*** setup

#+BEGIN_SRC sh
  ansible <pattern> -m setup -a 'filter=ansible_*_mb'     # 查看主机内存信息
  ansible <pattern> -m setup -a 'filter=ansible_eth[0-2]' # 查看地接口为eth0-2的网卡信息
  ansible <pattern> -m setup --tree /tmp/facts            # 将所有主机的信息输入到 /tmp/facts 目录下
#+END_SRC




** 主要用于 Playbook 的模块

*** pause

执行的过程中暂停一定时间或者提示用户进行某些操作。

#+BEGIN_SRC sh
  pause: prompt="ENTER to continue CTRL-C a to quit"
  pause: seconds=30
#+END_SRC


*** wait_for

执行过程中等待某些操作完成以后再进行后续操作。

#+BEGIN_SRC sh
  # 等待 8080 端口已正常监听，才开始下一个任务
  wait_for: port=8080 state=started

  # 等待 8000 端口正常监听，每隔 10s 检查一次，直至等待超时
  wait_for: port=8000 delay=10

  # 等待 8000 端口直至有连接建立
  wait_for: host=0.0.0.0 port=8000 delay=10 state=drained

  # 等待 8000 端口有连接建立，如果连接来自10.2.1.2或者10.2.1.3，则忽略
  wait_for: host=0.0.0.0 port=8000 state=drained exclude_hosts=10.2.1.2,10.2.1.3

  # 等待 /tmp/foo 文件已创建
  wait_for: path=/tmp/foo

  # 等待 /tmp/foo 文件已创建，而且该文件中需要包含 completed 字符串
  wait_for: path=/tmp/foo search_regex=completed

  # 等待 /var/lock/file.lock 被删除
  wait_for: path=/var/lock/file.lock state=absent

  # 等待指定的进程被销毁
  wait_for: path=/proc/3466/status state=absent



#+END_SRC



*** add_host

执行的过程中动态的添加主机到指定的主机组中。


*** group_by

执行的过程中动态的创建主机组。

#+BEGIN_SRC yaml
  - name: Create operating system group
    hosts: all
    tasks:
      - group_by: key=os_{{ ansible_distribution }}

  - name: Run on CentOS hosts only
    hosts: os_CentOS
    tasks:
      - name: Install Apache
        yum: name=httpd state=latest

  - name: Run on Ubuntu hosts only
    hosts: os_Ubuntu
    tasks:
      - name: Install Apache
        apt: pkg=apache2 state=latest
#+END_SRC


*** debug

用于在调试中输出信息。

#+BEGIN_SRC yaml
  debug: msg="System {{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}"
  debug: var=result verbosity=2

#+END_SRC


*** fail

通常与条件语句组合使用，当满足条件时，终止当前 play 的运行。

#+BEGIN_SRC yaml
  fail: msg="..."
#+END_SRC







* Playbook

ansbile-playbook 是一系列 ansible 命令的集合，使用 yaml 语言编写。
playbook 命令根据自上而下的顺序依次执行。

playbook 允许你传输某个命令的状态到后面的指令, 如可以从一台机器的文件中抓取内容并附为变量,
然后在另一台机器中使用, 这使得可以实现一些复杂的部署机制, 这是 adhoc 方式无法实现的。

#+CAPTION: Playbook 组织结构
#+NAME: ansible-playbook
[[file:img/ansible-playbook.png]]

** Variable

*** 在 Inventory 中定义变量

#+BEGIN_SRC ini
  [mygroup]
  host1
  host2

  [mygroup:vars]
  proxy=1.2.3.4
#+END_SRC


*** 在 Playbook 中定义变量

**** vars, vars_files 关键字

#+BEGIN_SRC yaml
  - hosts: all
    user: root
    vars:
      var1: a
      var2: b
    vars_files:
      - /vars/nginx_vars.yml
#+END_SRC

=/vars/nginx_vars.yml=:

#+BEGIN_EXAMPLE
  http_port: 80
  server_name: localhost
  cert_file: /etc/nginx/ssl/nginx.crt
  key_file: /etc/nginx/ssh/nginx.key
  conf_file: /etc/nginx/conf/default.conf
#+END_EXAMPLE

**** vars_prompt 实现人机交互

#+BEGIN_SRC yaml
  hosts: all
  user: root
  vars_prompt:
    - name: 'https_passphrase'          # 变量名
      prompt: 'Please input:'
      private: yes                      # 输入内容不会在终端显示
#+END_SRC


**** 通过 roles 带入变量


*** 注册变量

使用 =register= 将任务的执行结果保存到变量中

#+BEGIN_SRC yaml
  - hosts: all
      tasks:
          - shell: cat /etc/hosts
            register: result
          - shell: echo "/etc/hosts contains localhost"
            when: result.stdout.find('localhost') != -1
#+END_SRC

#+BEGIN_SRC yaml
  - hosts: all
      tasks:
        - command: ls /home
          register: result
        - file: path=/mnt/home/{{ item }} src=/home/{{ item }} state=link
          with_items: result.stdout_lines # same as with_items: result.stdout.split()

#+END_SRC


*** 通过 fact 获取/设置变量

#+BEGIN_SRC yaml
  - name: Configure MySql
    hosts: sqlservers
    tasks:
      - name: Install MySql
        yum: name=mysql-server state=installed

      - name: Calculate InnoDB buffer pool size
        set_fact: innodb_buffer_pool_size_mb="{{ ansible_memtotal_mb / 2 }}"

      - name: Configure MySql
        template: src=templates/mysql.cnf dest=/etc/mysql.cnf owner=root group=root mode=0644
        notify: restart mysql

      - name: Start MySql
        service: name=mysqld state=started enabled=yes

    handlers:
      - name: Restart MySql
        service: name=mysqld state=restarted
#+END_SRC


*** 内置变量

**** hostvars

用于获取某台指定的主机的相关变量。

={{ hostvars['db.example.com'].ansible_eth0.ipv4.address }}=

需要注意的是 =db.example.com= 不能使用 ip 地址来取代， *只能使用主机名或别名* 。


**** inventory_hostname

利用 hostvars 和 inventory_hostname 变量，可以输出与当前主机相关联的所有变量：

=- debug: var=hostvars[inventory_hostname]=


**** inventory_hostname_short

如果一台主机的 inventory_hostname 为 =server1.exmaple.com= ，则 inventory_hostname_short 的值为 server1 。


**** group_names

用于标识当前正在执行 task 的目标主机位于的主机组。


**** groups

当需要访问一组主机的变量时，groups 变量会很有用。

在所有的 dbservers 组的服务器上创建一个数据库用户 test ：

#+BEGIN_SRC yaml
  - name: Create a user for all db servers
    mysql_user: name=test password=test host={{ hostvars.[item].ansible_eth0.ipv4.address }} state=present
    with_items: groups['dbservers']
#+END_SRC


**** play_hosts

当前 playbook 会在哪些 hosts 上运行。


**** ansible_version

当前 ansible 的版本。


**** inventory_dir

主机清单所在目录。


**** inventory_file

主机清单文件。


*** 通过命令行设置变量

#+BEGIN_SRC sh
  --extra-vars 'user=starbucks'
  --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
#+END_SRC


** Tasks

每个任务需要包含的信息：

- 用到的模块
- 模块参数
- 用于描述的名称 [可选]
- 执行条件 [可选]

#+BEGIN_SRC yaml
  - name: Example
    hosts: all
    remote_user: root
    gather_facts: True
    vars:
      user: test
    tasks:
      - name: Create User
        user: name="{{ user }}"
      - name: Install Apache on CentOS
          yum: name=httpd state=present
          when: ansible_os_family =="CentOS"

#+END_SRC



** Handlers

用于当关注的资源发生变化时采取一定的操作。

notify 这个 action 可用于在每个 play 的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，
而仅在所有的变化发生完成后 *一次性* 地执行指定操作。

#+BEGIN_SRC yaml
  ---
  - hosts: 10.74.68.55
    remote_user: cisco

    tasks:
      - name: create a file       # 描述
        file: name=/tmp/newfile state=touch # 使用模块
        notify: restart ssh service
      - name: run this command and ignore error
        shell: /usr/bin/nocommand
        ignore_errors: true
      - name: start ssh service
        service: name=ssh state=started enabled=yes
        become: true

    handlers:
      - name: restart ssh service
        service: name=ssh state=restarted
        become: true
#+END_SRC




** Template

#+BEGIN_SRC sh
  options {
      listen-on port 53 {
          127.0.0.1;
          {% for ip in ansible_all_ipv4_addresses %}
          {{ ip }};
          {% endfor %}
      };
  };

  {# Variables for zone config #}

  {% if 'authorativenames' in group_names %}
      {% set zone_type = 'master' %}
  {% else %}
      {% set zone_type = 'slave' %}
  {% endif %}

  type {{ zone_type }};

  {% if 'authorativenames' not in group_names %}
  masters { 192.168.2.2; };
  {% endif %}
#+END_SRC



** When

*** 变量不存在

#+BEGIN_SRC yaml
  tasks:
    - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
      when: foo is defined
    - fail: msg="Bailing out. this play requires 'bar'"
      when: bar is not defined
#+END_SRC


*** 用于循环

#+BEGIN_SRC yaml
  tasks:
    - command: echo {{ item }}
      with_items: [ 0, 2, 4, 6, 8, 10 ]
      when: item > 56
#+END_SRC


*** 用于 include

#+BEGIN_SRC yaml
  - include: tasks/sometasks.yml
    when: "'reticulating splines' in output"
#+END_SRC


*** 用于 roles

#+BEGIN_SRC yaml
  - hosts: webservers
    roles:
       - { role: debian_stock_config, when: ansible_os_family == 'Debian' }
#+END_SRC




** 循环

*** with_items

#+BEGIN_SRC yaml
  ---
  - hosts: 10.74.68.55
    remote_user: cisco

    tasks:
      - name: create files
        file: name=/tmp/{{item}} state=touch
        with_items:
          - a
          - b
          - c
#+END_SRC

#+BEGIN_SRC yaml
  ---
  - hosts: 10.74.68.55
    remote_user: cisco

    tasks:
      - name: create users
        user: name={{item.name}} group={{item.group}}
        with_items:
          - {name: 'user1', group: 'g1'}
          - {name: 'user2', group: 'g2'}
          - {name: 'user3', group: 'g3'}

#+END_SRC


*** with_nested

*** with_dict

*** with_subelement

*** with_sequence

*** with_random_choice

*** do_util




* Role

在 Ansible 中，Playbook 组织 Task ，Role 组织 Playbook 。

用于层次性，结构化地组织 playbook 。Roles 能够根据层次型结构自动装载变量文件，tasks 以及 handlers 。\\
要使用 roles 只需在 palybook 中使用 =include= 指令即可。

简单来讲，Roles 就是通过分别将变量，文件，任务，模板及处理器放置于单独的目录中，并可以便捷地 =include= 它们的一种机制。



** 创建

#+BEGIN_SRC sh
  ansible-galaxy init <role>
#+END_SRC

*** roles 各目录的作用

- files ::

  存放由 copy 或 script 等模块调用的文件

- tempaltes ::

  Jinja2 模板文件

- tasks ::

  定义了角色的任务列表。

  可以使用 include 包含其他的位于此目录中的 task 文件。


- handlers ::

  用于定义角色用到的各 handler 。

  在 handler 中可以使用 include 包含的其他位于此目录中 的 handler 文件。

- vars ::

  用于定义角色用到的变量

- meta ::

  定义角色的特殊设定及依赖关系等

- default ::

  设定默认变量


** pre_tasks 和 post_tasks

在执行 roles 时，需要在其前或其后执行某些任务，可以使用 pre_tasks 及 post_tasks 来声明。


** 依赖

如果当前 role 在执行前需要依赖另一个 role ，可以在 meta 目录中的 main.yml 文件中定义依赖关系。

#+BEGIN_SRC yaml
  dependencies:
    - { role: common, some_parameter: 3 }
    - { role: postgres, dbname: blarg, other_parameter: 12 }

#+END_SRC


** 项目结构

#+BEGIN_EXAMPLE
  site.yml
  ancible.cfg
  hosts
  group_vars/
     all
     group-1
     group-2
  host_var/
     all
     host-1
     host-2
  roles/
     common/
       files/
       templates/
       tasks/
       handlers/
       vars/
       defaults/
       meta/
     web/
       files/
       templates/
       tasks/
       handlers/
       vars/
       defaults/
       meta/
#+END_EXAMPLE

*** 入口文件 (site.xml)

#+BEGIN_EXAMPLE
  ---
  - hosts: webservers
    user: root
    roles:
       - common
       - web
#+END_EXAMPLE

*** 执行

#+BEGIN_SRC sh
  ansible-playbook site.yml -vvv
#+END_SRC
