** 将二进制字符串转变为非二进制字符串或者反向转换

#+BEGIN_SRC sql
  SET @s1 = "my string";
  SET @s2 = CONVERT(@s1 USING binary);
  SET @s3 = CONVERT(@s2 USING utf8);
  SELECT CHARSET(@s1), CHARSET(@s2), CHARSET(@s3);
  ## 使用binary可以产生二进制字符串，使用字符集名可以产生非二进制字符串
#+END_SRC

#+BEGIN_SRC sql
  SET @s1 = "my string";
  SET @s2 = BINARY @s2;
  SELECT CHARSET(@s1), CHARSET(@s2);
#+END_SRC


** 定义函数

#+BEGIN_SRC sql
  CREATE FUNCTION initial_cap (s VARCHAR(255))
  RETURNS VARCHAR(255) DETERMINISTIC
  RETURNS CONCAT(UPPER(LEFT(s, 1), MID(s, 2)));

  SELECT thing, initial_cap(thing) FROM tbl;
#+END_SRC


** ENUM和SET这两种值类型在数据库中被当做字符串来保存，因此可以用于CONCAT()函数


** FULLTEXT检索

SELECT * FROM tbl_name WHERE MATCH(column) AGAINST('my string');

FULLTEXT查询中的查询字符串可以包含多个单词，但是查询过程对每个单词进行OR查询：

SELECT * FROM tbl_name WHERE MATCH(vtext) AGAINST('Abraham Sarah');

如果想使用FULLTEXT同时对多列进行查询，需要在建立索引时指定所有需要被查询的列，同时在MATCH()参数列表中指定所有列:

#+BEGIN_SRC sql
ALTER TABLE tbl_name ADD FULLTEXT (col1, col2, col3);
SELECT * FROM tbl_name WHERE MATCH(col1, col2, col3) AGAINST('search string');
#+END_SRC

*** Boolean模式查询

#+BEGIN_SRC sql
  SELECT COUNT(*) FROM tbl
  WHERE MATCH(vtext) AGAINST('+David +Goliath' IN BOOLEAN MODE); ## 同时包含 David 和 Goliath 的行
#+END_SRC

#+BEGIN_SRC sql
  SELECT COUNT(*) FROM tbl
  WHERE MATCH(vtext) AGAINST('+David -Goliath' IN BOOLEAN MODE); ## 包含 David 但是不包含 Goliath 的行
#+END_SRC

#+BEGIN_SRC sql
  SELECT COUNT(*) FROM tbl
  WHERE MATCH(vtext) AGAINST('whirl*' IN BOOLEAN MODE);
  ## 不仅可以包含 whirl，也可以包含 whirls, whirleth 和 whirlwind 等单词
#+END_SRC

#+BEGIN_SRC sql
  SELECT COUNT(*) FROM tbl
  WHERE MATCH(vtext) AGAINST('"still small voice"' IN BOOLEAN MODE); ## 词组搜索
#+END_SRC

**


** 将字符串转换为数值

加0:

SELECT * FROM tbl ORDER BY score_str+0;


** 字符串拼接

#+BEGIN_SRC sql
  SELECT 'Hello' || 'MySQL'; ## Error
  SET sql_mode = 'PIPES_AS_CONCAT';
  SELECT 'Hello' || 'MySQL'; ## Correct
#+END_SRC


** 强制转换为字符串

#+BEGIN_SRC sql
  CREATE TABLE weekday
  (
      day ENUM('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday')
  );

  ## 希望按照词汇方式排序 ENUM 数值：
  SELECT day, day+0 FROM weekday ORDER BY CAST(day AS CHAR);

#+END_SRC


** 字符串左右对齐可以使用 LPAD/RPAD 函数


** SELECT CONCAT_WS(', ', Name, Continent, Region) FROM country;

「CONCAT」與「CONCAT_WS」兩個函式的參數可以接受任何型態的資料，它們都會把全部的資料轉為字串後連接起來；「CONCAT」函式的參數中如果有「NULL」值，結果會是「NULL」；「CONCAT_WS」函式的參數中如果有「NULL」值，「NULL」值會被忽略


** GROUP_CONCAT

GROUP_CONCAT ( [DISTINCT] col [ORDER BY xxx] [SEPARATOR s])

#+BEGIN_SRC sql
  SELECT GROUP_CONCAT(dname ORDER BY dname SEPARATOR '|') FROM tbl;
#+END_SRC


** CASE

#+BEGIN_SRC sql
SELECT name, salary,
    CASE
    WHEN salary >= 3000 THEN 'A'
    WHEN salary >= 1000 AND salary <= 2000 THEN 'B'
    WHEN salary < 1000 THEN 'C'
    END SalaryGrade
FROM tbl;
#+END_SRC

#+BEGIN_SRC sql
  SELECT Name, Continent,
      CASE Continent
          WHEN 'Asia' THEN 'AS'
          WHEN 'Europe' THEN 'EU'
          WHEN 'Africa' THEN 'AF'
          WHEN 'Oceania' THEN 'OA'
          WHEN 'Antarctica' THEN 'AN'
          WHEN 'North America' THEN 'NA'
          WHEN 'South America' THEN 'SA'
      END ContinentCode
  FROM country;
#+END_SRC


** LIMIT 搭配 UPDATE 使用时只能跟一个数字

#+BEGIN_SRC sql
UPDATE tbl
SET salary = salary + 1000
ORDER BY salary
LIMIT 3 ## 不能写成 LIMIT 0,3 这样子
#+END_SRC

** 随机查询

#+BEGIN_SRC sql
    SELECT name FROM country
    ORDER BY RAND()
    LIMIT 1
#+END_SRC

** CURRENT_TIMESTAMP

在一個表格中，MySQL限制「CURRENT_TIMESTAMP」只能在一個欄位出現。如果在同一筆紀錄中，要使用一個欄位記錄新增資料的日期與時間，而使用另一個欄位記錄修改資料的日期與時間。為了應付這樣的需求，必須使用MySQL提供給你的特殊設定方式來解決：

#+BEGIN_SRC sql
  CREATE TABLE IF NOT EXISTS table_name
      (
          created TIMESTAMP DEFAULT 0,
          updated TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
          );
#+END_SRC

當你指定「created」欄位的值為「NULL」的時候，MySQL會自動為你填入目前的日期與時間：

#+BEGIN_SRC sql
INSERT INTO table_name (created) VALUES (NULL);
#+END_SRC
