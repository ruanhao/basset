#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall



** Deep copy

=a[:]= is not deep copy
#+BEGIN_SRC python
a = [1, 2, [3, 4]]
b = a[:]
b[2][0] = 6 # a is affected
import copy
b = copy.deepcopy(a) # it is a deep copy
#+END_SRC

** DefaultDict

#+BEGIN_SRC python
from collections import defaultdict
d = defaultdict(lambda: 0, {})
#+END_SRC

** Init list

#+BEGIN_SRC python
l = [None] * 1000
#+END_SRC

** Enumerate list

#+BEGIN_SRC python
a = [1, 2, 3, 4, 5]
for i,v in enumerate(a):
    logging.debug("i: %d, v: %d", i, v)
#+END_SRC

** itertools.izip

#+BEGIN_SRC python
  import itertools

  a = [1, 2, 3, 4, 5]
  b = [11, 22, 33, 44, 55]
  ## itertools.izip is better than just zip
  for i,j in itertools.izip(a, b):
      logging.debug("i: %d, j: %d", i, j)
#+END_SRC

** Python2 nonlocal simulation

#+BEGIN_SRC python
def outer():
    def inner():
        inner.y += 1
        return inner.y
    inner.y = 0
    return inner

f = outer()
g = outer()
print(f(), f(), g(), f(), g()) # prints (1, 2, 1, 3, 2)
#+END_SRC

** Exec

+ 如果在表达式之后使用in选项指定一个dic，它将作为global和local变量作用域

#+BEGIN_SRC python
>>> a=10
>>> b=20
>>> g={'a':6,'b':8}
>>> exec "global a;print a,b" in g
6 8
>>>
#+END_SRC

+ 如果in后详指定两个表达式，它们将分别用作global和local变量作用域

  #+BEGIN_SRC python
  >>> a=10
  >>> b=20
  >>> c=20
  >>> g={'a':6,'b':8}
  >>> l={'b':9,'c':10}
  >>> exec "global a;print a,b,c" in g,l
  6 9 10
  >>>
  #+END_SRC

+ 如果第一个表达式是tuple

  #+BEGIN_SRC python
  exec(expr, globals)          # 等效  exec expr in globals
  exec(expr, globals, locals)  # 等效  exec expr in globals,locals
  #+END_SRC

** Eval

+ 如果要严格限制eval执行，可以设置globals为__builtins__,这样 这个表达式只可以访问__builtin__ module

+ exec,eval带来了极大的灵活性，同时也带来了隐含的危险性，使用它们的时候应该总是记得详细指定其执行的作用域

** Attribute

=obj.foo(param)= is somewhat like =type1(obj).foo(obj, param)=, here type1(obj) returns the class that defines foo

** Parameters

定义默认参数必须指向不可变对象
