#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall



** functools.wraps

不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps可以实现这个功能。一个完整的decorator的写法如下：

#+BEGIN_SRC python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
#+END_SRC

** functools.partial

#+BEGIN_SRC python
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
#+END_SRC

但也可以在函数调用时传入其他值：

#+BEGIN_SRC python
>>> int2('1000000', base=10)
1000000
#+END_SRC

** functools.reduce

reduce 的效果是：

#+BEGIN_SRC python
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
#+END_SRC

#+BEGIN_SRC python
from functools import reduce
def add(x, y):
    return x + y
reduce(add, [1, 3, 5, 7, 9])
#+END_SRC

#+BEGIN_SRC python
from functools import reduce
def fn(x, y):
    return x * 10 + y
reduce(fn, [1, 3, 5, 7, 9]) ## 13579
#+END_SRC
