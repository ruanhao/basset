#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall



** Get ref count

#+BEGIN_SRC python
  a = 37
  import sys
  sys.getrefcount(a)
#+END_SRC

** Get info about latest exception

=sys.exc_info()=

** Show all keywords

#+BEGIN_SRC python
import keyword
print keyword.kwlist
#+END_SRC

** Show basic class sequence

MyClass.__mro__

** __getattr__

#+BEGIN_EXAMPLE
当我们查询一个属性时，如果通过__dict__方法无法找到该属性，那么Python会调用对象的__getattr__方法，来即时生成该属性
还有一个__getattribute__特殊方法，用于查询任意属性。__getattr__只能用来查询不在__dict__系统中的属性
#+END_EXAMPLE

** __slots__

#+BEGIN_EXAMPLE
在实际使用中，__slots__从未被当做一种安全的特性来使用
它实际上是对内存和执行速度的一种性能优化
使用__slots__的类的实例不再使用字典来存储实例数据，相反，会使用基于数组的更加紧凑的数据结构
#+END_EXAMPLE

#+BEGIN_EXAMPLE
__slots__与继承的配合使用需要一定的技巧，因为__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。
如果类继承自使用__slots__的基类，那么它也需要定义__slots__来存储自己的属性（即使它不会添加任何属性也是如此），这样才能充分利用__slots__提供的优势。
如果忘记这一点，派生类的运行速度将更慢，占用的内存也比未在任何类上使用__slots__时多。
另外，如果在子类中也定义了__slots__，那么，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。
#+END_EXAMPLE

** Create class

#+BEGIN_SRC python
  class_name = "Foo"
  class_parents = (object,)
  class_body = """
  def __init__(self, x):
      self.x = x
  def blah(self):
      print "hello world"
  """
  class_dict = {}
  exec(class_body, globals(), class_dict)
  ## class_dict: {'blah': <function blah at 0x7f0e15520578>, '__init__': <function __init__ at 0x7f0e15520500>}
  Foo = type(class_name, class_parents, class_dict)
#+END_SRC

** Descriptor in metaclass

#+BEGIN_SRC python
  class Name(object):
      def __init__(self, name):
          self.__name = name
      def __get__(self, ins, cls):
          return self.__name
      def __set__(self, ins, value):
          pass
      def __delete__(self):
          pass

  class Meta(type):
      name = Name("meta messi") ## try comment it

  class Myclass(object):
      __metaclass__ = Meta
      name = Name("class messi")  ## try comment it

  m = Myclass()
  m.__dict__['name'] = Name("instance messi")
  print Myclass.name
  print m.name
#+END_SRC

** 给实例绑定一个方法

#+BEGIN_SRC python
def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s = Student()
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25)
#+END_SRC

注意：给一个实例绑定的方法，对另一个实例是不起作用的

为了给所有实例都绑定方法，可以给class绑定方法：

#+BEGIN_SRC python
def set_score(self, score):
    self.score = score
Student.set_score = set_score
#+END_SRC

** Inspect

*** dir()

获得一个对象的所有属性和方法。这其实包含自身的属性和在类中定义的描述符。

*** hasattr 正确应用场景

#+BEGIN_SRC python
def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
#+END_SRC
