#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall



** Get ref count

#+BEGIN_SRC python
  a = 37
  import sys
  sys.getrefcount(a)
#+END_SRC

** Get info about latest exception

=sys.exc_info()=

** Show all keywords

#+BEGIN_SRC python
import keyword
print keyword.kwlist
#+END_SRC

** Show basic class sequence

MyClass.__mro__

** __getattr__

#+BEGIN_EXAMPLE
当我们查询一个属性时，如果通过__dict__方法无法找到该属性，那么Python会调用对象的__getattr__方法，来即时生成该属性
还有一个__getattribute__特殊方法，用于查询任意属性。__getattr__只能用来查询不在__dict__系统中的属性
#+END_EXAMPLE

** __slots__

#+BEGIN_EXAMPLE
在实际使用中，__slots__从未被当做一种安全的特性来使用
它实际上是对内存和执行速度的一种性能优化
使用__slots__的类的实例不再使用字典来存储实例数据，相反，会使用基于数组的更加紧凑的数据结构
#+END_EXAMPLE

#+BEGIN_EXAMPLE
__slots__与继承的配合使用需要一定的技巧
如何类继承自使用__slots__的基类，那么它也需要定义__slots__来存储自己的属性（即使它不会添加任何属性也是如此），这样才能充分利用__slots__提供的优势。
如果忘记这一点，派生类的运行速度将更慢，占用的内存也比未在任何类上使用__slots__时多。
#+END_EXAMPLE

** Create class

#+BEGIN_SRC python
  class_name = "Foo"
  class_parents = (object,)
  class_body = """
  def __init__(self, x):
      self.x = x
  def blah(self):
      print "hello world"
  """
  class_dict = {}
  exec(class_body, globals(), class_dict)
  ## class_dict: {'blah': <function blah at 0x7f0e15520578>, '__init__': <function __init__ at 0x7f0e15520500>}
  Foo = type(class_name, class_parents, class_dict)
#+END_SRC

** Descriptor in metaclass

#+BEGIN_SRC python
  class Name(object):
      def __init__(self, name):
          self.__name = name
      def __get__(self, ins, cls):
          return self.__name
      def __set__(self, ins, value):
          pass
      def __delete__(self):
          pass

  class Meta(type):
      name = Name("meta messi") ## try comment it

  class Myclass(object):
      __metaclass__ = Meta
      name = Name("class messi")  ## try comment it

  m = Myclass()
  m.__dict__['name'] = Name("instance messi")
  print Myclass.name
  print m.name
#+END_SRC
