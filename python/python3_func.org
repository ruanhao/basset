#+TITLE:     Function
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 一，基本知识

** 1.1，使用默认参数的注意事项

定义默认参数时，默认参数必须指向不可变对象

#+BEGIN_SRC python
  def add_end(L=[]):
      L.append('END')
      return L

  add_end()                       # ['END']
  add_end()                       # ['END', 'END']
  add_end()                       # ['END', 'END', 'END']
#+END_SRC

原因：

函数在定义的时候，默认参数 L 的值就被计算出来了，即 [] ，因为默认参数 L 也是一个变量，它指向对象 [] ，\\
每次调用该函数，如果改变了 L 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 [] 了。

修改上面的例子，可以用 None 这个不可变对象来实现：

#+BEGIN_SRC python
  def add_end(L=None):
      if L is None:
          L = []
      L.append('END')
      return L
#+END_SRC


** 1.2，命名关键字参数

可以用于限制关键字参数的名字\\
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

#+BEGIN_SRC python
  # 只接收 city 和 job 作为关键字参数
  def person(name, age, *, city, job):             # 命名关键字参数需要一个特殊分隔符 *
      print(name, age, city, job)                  # * 后面的参数被视为命名关键字参数

  def person2(name, age, *, city='Beijing', job):  # 可以有默认值
      print(name, age, city, job)

  # 调用方式：
  person('Jack', 24, city='Beijing', job='Engineer')
#+END_SRC

#+BEGIN_SRC python
  # 如果函数定义中已经有了一个可变参数
  # 后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了
  def person(name, age, *args, city, job):
      print(name, age, args, city, job)
#+END_SRC


** 1.3，参数组合顺序

在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。\\
组合参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

** 1.4，使用闭包的陷阱

#+BEGIN_SRC python
  def count():
      fs = []
      for i in range(1, 4):
          def f():
               return i*i
          fs.append(f)
      return fs

  f1, f2, f3 = count()
  f1()                            # 9
  f2()                            # 9
  f3()                            # 9
#+END_SRC

原因在于返回的函数引用了变量 i，但它并非立刻执行。\\
等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，因此最终结果为 9。

返回闭包时需注意： *返回函数中不要引用任何可能会变化的变量*

如果一定要引用会变化的变量，可以再创建一个函数：

#+BEGIN_SRC python
  def count():
      def f(j):
          def g():
              return j*j
          return g
      fs = []
      for i in range(1, 4):
          fs.append(f(i))
      return fs
#+END_SRC
