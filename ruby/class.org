#+Title: Class
#+OPTIONS: ^:nil

** Class methods

#+BEGIN_SRC ruby
## How to define class methods

class Demo
  def Demo.method1
    # ...
  end

  def self.method2
    # ...
  end

  class <<self
    def method3
      # ...
    end
  end
end
#+END_SRC

** Singleton

#+BEGIN_SRC ruby
## Singleton (not thread safe)

class MyLogger
  private_class_method :new
  @@logger = nil
  def MyLogger.create
    @@logger = new unless @@logger
    @@logger
  end
end
#+END_SRC

** Metaclass

- Object can be both meta for <my_instance> and <MyClass>

#+BEGIN_SRC

  <my_instance>
  +--------------+
  |iv_tbl:       |
  +--------------+
  |klass:        +-----+
  +--------------+     |
                       |
               +-------+
               |
  <MyClass>    v
  +--------------+                +--------------+              +--------------+
  |super:        +--------------->|super:        |------------->|super:        |
  +--------------+                +--------------+              +--------------+
  |klass:        +----+           |klass:        |              |klass:        |
  +--------------+    |           +--------------+              +--------------+
                      |            THESE ARE ALL METACLASSES OF <my_instance>
               +-------       ---------------------------------------------------->
               |
               v
  +--------------+               +--------------+               +--------------+
  |super:        +-------------->|super:        +-------------->|super:        |
  +--------------+               +--------------+               +--------------+
  |klass:        |               |klass:        |               |klass:        |
  +--------------+               +--------------+               +--------------+

                     THESE ARE ALL METACLASSES OF <MyClass>
  -------------------------------------------------------------------------------->

#+END_SRC

- Access the metaclass of an object through a neat trick

#+BEGIN_SRC ruby
  class Object
    def metaclass
      class << self  ## Note:
        self         ## the return value of a class definition
      end            ## is ACTUALLY the return value of the last expression
    end
  end
#+END_SRC

** Class name

- If a non-name class is assigned to a constant, this constant is treated as the name of the class

#+BEGIN_SRC ruby
  var = Class.new
  var.name ## nil

  Wibble = var
  var.name ## "Wibble"
#+END_SRC

- Classes and modules themselves are types in the Ruby class hierarchy, just like strings and arrays

  #+BEGIN_SRC ruby
    fence = Module.new do
      def speak
        "I'm trapped!"
      end
    end

    class Sheep
      def speak
        "Baaaaahhhhh."
      end
    end

    dolly = Sheep.new
    dolly.extend(fence)
    puts dolly.speak
  #+END_SRC

  #+BEGIN_SRC ruby
    def awkward_sheep
      sheep = Class.new do
        def speak
          "Bah."
        end
      end
    end

    module Fence
      Sheep = Class.new do
        def speak
          "Bah."
        end
      end
    end

    def call_sheep
      Fence::Sheep.new.speak
    end
  #+END_SRC

** Class variables

There aren't very many cases that you would need to use class variables.

In fact, its improper usage is generally frowned in the Ruby community.

- Class variables and inheritance

#+BEGIN_SRC ruby
class ApplicationConfiguration
  @@configuration = {}

  def self.set(property, value)
    @@configuration[property] = value
  end

  def self.get(property)
    @@configuration[property]
  end
end

class ERPApplicationConfiguration < ApplicationConfiguration
end

class WebApplicationConfiguration < ApplicationConfiguration
end

ERPApplicationConfiguration.set("name", "ERP Application")
WebApplicationConfiguration.set("name", "Web Application")

p ERPApplicationConfiguration.get("name") # "Web Application"
p WebApplicationConfiguration.get("name") # "Web Application"

p ApplicationConfiguration.get("name")    # "Web Application"
#+END_SRC

- Class instance variables

Class instance variables are a better alternative than class variables simply because the data is not shared across the inheritance chain.

It is almost always a bad idea to use a class variable to store state. There are only a very few valid use cases where class variables are the right choice.

Prefer class instance variables over class variables when you do really need store data at a class level.

#+BEGIN_SRC ruby
class ApplicationConfiguration
  @configuration = {}

  def self.set(property, value)
    @configuration[property] = value
  end

  def self.get(property)
    @configuration[property]
  end
end

class ERPApplicationConfiguration < ApplicationConfiguration
  @configuration = {}
end

class WebApplicationConfiguration < ApplicationConfiguration
  @configuration = {}
end

ERPApplicationConfiguration.set("name", "ERP Application")
WebApplicationConfiguration.set("name", "Web Application")

p ERPApplicationConfiguration.get("name")  ## "ERP Application"
p WebApplicationConfiguration.get("name")  ## "Web Application"

p ApplicationConfiguration.get("name")     ## nil
#+END_SRC
