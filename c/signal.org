#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+OPTIONS: H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP: showall



** signal

**** prototype

#+BEGIN_SRC c
  void (*signal(int signo, void (*func)(int)))(int);
#+END_SRC


**** constants

#+BEGIN_SRC c
  #define SIG_ERR (void (*)())-1
  #define SIG_DFL (void (*)())0
  #define SIG_IGN (void (*)())1
#+END_SRC


** sigprocmask

**** prototype

#+BEGIN_SRC c
  #include <signal.h>
  int sigprocmask(int how, const sigset_t *set,
                  sigset_t *oset);
#+END_SRC

**** snippets

  + pr_mask

  #+BEGIN_SRC c
    void pr_mask() {
        sigset_t sigset;
        sigemptyset(&sigset);
        if (sigprocmask(0, NULL, &sigset) < 0)
            exit(1);
    }
  #+END_SRC


** sigaction

**** prototype

#+BEGIN_SRC c
  int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

  struct sigaction {
      void (*sa_handler)(int);   /* addr of signal handler,                              */
                                 /* or SIG_IGN, or SIG_DFL                               */
      sigset_t sa_mask;          /* additional signals to block                          */
                                 /* operating system includes the signal being delivered
                                    in the signal mask when the handler is invoked       */
      int sa_flags;                                      /* signal options               */
      void (*sa_sigaction)(int, siginfo_t *, void *);    /* alternate handler            */
  };

  struct siginfo {
      int   si_signo;  /* signal number                          */
      int   si_errno;  /* if nonzero, errno value from <errno.h> */
      int   si_code;   /* additional info (dependson signal)     */
      pid_t si_pid;    /* sending process ID                     */
      uid_t si_uid;    /* sending process real user ID           */
      void *si_addr;   /* address that caused the fault          */
      int   si_status; /* exit value or signal number            */
      long  si_band;   /* band number for SIGPOLL                */
      /* possibly other fields also */
  };
#+END_SRC


**** snippets

+ reliable =signal=

#+BEGIN_SRC c
  /* Reliable version of signal(), using POSIX sigaction(). */
  void (*signal(int signo, void (*func)(int)))(int) {
      struct sigaction act, oact;
      act.sa_handler = func;
      sigemptyset(&act.sa_mask);
      act.sa_flags = 0;
      if (signo == SIGALRM) {
  #ifdef SA_INTERRUPT
          act.sa_flags |= SA_INTERRUPT;
  #endif
      } else {
  #ifdef SA_RESTART
          act.sa_flags |= SA_RESTART;
  #endif
      }
      if (sigaction(signo, &act, &oact) < 0)
          return(SIG_ERR);
      return(oact.sa_handler);
  }
#+END_SRC


+ interupted =signal=

#+BEGIN_SRC c
  void (*signal_intr(int signo, void (*func)(int)))(int) {
      struct sigaction act, oact;
      act.sa_handler = func;
      sigemptyset(&act.sa_mask);
      act.sa_flags = 0;
  #ifdef SA_INTERRUPT
      act.sa_flags |= SA_INTERRUPT;
  #endif
      if (sigaction(signo, &act, &oact) < 0)
          return(SIG_ERR);
      return(oact.sa_handler);
  }
#+END_SRC

** sigsuspend

**** prototype

#+BEGIN_SRC c
#include <signal.h>
int sigsuspend(const sigset_t *sigmask)
#+END_SRC

**** snippets

+ protect a critical region of code from a specific signal

  #+BEGIN_SRC c
    extern void sig_int(int);

    int main(void) {
        sigset_t newmask, oldmask, waitmask;

        if (signal(SIGINT, sig_int) == SIG_ERR)
            err_sys("signal(SIGINT) error");

        sigemptyset(&waitmask);
        sigaddset(&waitmask, SIGUSR1);
        sigemptyset(&newmask);
        sigaddset(&newmask, SIGINT);

        /*
         * Block SIGINT and save current signal mask.
         */
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
            err_sys("SIG_BLOCK error");

        /*
         * Critical region of code.
         */

        /*
         * Pause, allowing all signals except SIGUSR1.
         */
        if (sigsuspend(&waitmask) != -1)
            err_sys("sigsuspend error");


        /*
         * Reset signal mask which unblocks SIGINT.
         */
        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
            err_sys("SIG_SETMASK error");

        exit(0);
    }

  #+END_SRC

+ wait for a signal handler to set a global variable

  #+BEGIN_SRC c
    volatile sig_atomic_t quitflag; /* set nonzero by signal handler */

    static void sig_int(int signo)  /* one signal handler for SIGINT and SIGQUIT */
    {
        if (signo == SIGQUIT)
            quitflag = 1;           /* set flag for main loop */
    }

    int main(void) {
        sigset_tnewmask, oldmask, zeromask;

        if (signal(SIGQUIT, sig_int) == SIG_ERR)
            err_sys("signal(SIGQUIT) error");

        sigemptyset(&zeromask);
        sigemptyset(&newmask);
        sigaddset(&newmask, SIGQUIT);

        /*
         * Block SIGQUIT and save current signal mask.
         */
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
            err_sys("SIG_BLOCK error");

        while (quitflag == 0)  /* wake up the main routine only when the quit signal is caught */
            sigsuspend(&zeromask);

        /*
         * SIGQUIT has been caught and is now blocked; do whatever.
         */
        quitflag = 0;

        /*
         * Reset signal mask which unblocks SIGQUIT.
         */
        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
            err_sys("SIG_SETMASK error");

        exit(0);
    }

  #+END_SRC

** siglongjmp

**** snippets

+ protection mechanism

  #+BEGIN_SRC c
    static sigjmp_buf            jmpbuf;
    static volatile sig_atomic_t canjump;

    static void sig_usr1(int signo) {
        if (canjump == 0)
            return;              /* unexpected signal, ignore */

        /* TO DO WHAT YOU WANT TO DO HERE */

        canjump = 0;
        siglongjmp(jmpbuf, 1);   /* jump back to main, don't return */
    }

    int main(void) {
        if (signal(SIGUSR1, sig_usr1) == SIG_ERR)
            exit(1);
        if (sigsetjmp(jmpbuf, 1)) {
            printf("The end");
            exit(0);
        }
        canjump = 1;             /* it means now sigsetjmp() is ready */
        for ( ; ; )
            pause();
    }
  #+END_SRC

  This program demonstrates another technique that should be used whenever =siglongjmp= is called from a signal handler. We set the variable =canjump= to a nonzero value only after we’ve called =sigsetjmp=. This variable is examined in the signal handler, and =siglongjmp= is called only if the flag =canjump= is nonzero. *This technique provides protection against the signal handler being called at some earlier or later time, when the jump buffer hasn’t been initialized by* =sigsetjmp=.

  Here, we use the data type =sig_atomic_t=, which is defined by the ISO C standard to be the type of variable that can be written without being interrupted. We always include the ISO type qualifier =volatile= for these data types as well, since the variable is *being accessed by two different threads of control:* the main function and the asynchronously executing signal handler.


**** subtle problem with siglongjmp

The =longjmp= from the =sleep2= function aborted the other signal handler, =sig_int=, even though it wasn’t finished.

#+BEGIN_SRC c
  int main(void) {
      unsigned int unslept;
      if (signal(SIGINT, sig_int) == SIG_ERR)
          err_sys("signal(SIGINT) error");
      unslept = sleep2(5);
      printf("sleep2 returned: %u\n", unslept);
      exit(0);
  }

  static void sig_int(int signo) {
      int i, j;
      volatile int k;
  /*
   ,* Tune these loops to run for more than 5 seconds
   ,* on whatever system this test program is run.
   ,*/
      printf("\nsig_int starting\n");
      for (i = 0; i < 300000; i++)
          for (j = 0; j < 4000; j++)
              k += i * j;
      printf("sig_int finished\n");
  }
#+END_SRC
** Utils

+ sys_siglist[]

  =extern char *sys_siglist[]=

  #+BEGIN_SRC c
    int i;
    for (i = 1; i <= 32; i++) {
        H_DEBUG_MSG("SIGNAL(%d): %s", i, sys_siglist[i]);
    }
  #+END_SRC

+ strsignal

  =char *strsignal(int signo);=


** Gotcha

+ =SIGKILL= and =SIGSTOP= can not be ignored ::

+ function =exec= will change the disposition of any signals being caught to their default action ::

+ function =sigprocmask= is defined only for single-threaded processes ::

  A separate function is provided to manipulate a thread’s signal mask in a multithreaded process.

+ save and restore =errno= in signal handler ::

+ rule of =sigsetjmp= ::

  While catching signals that cause =sigsetjmp= to be executed, an application needs to block the signals while updating the data structures.

+ POSIX.1要求 =system= (调用者) 忽略SIGINT和SIGQUIT, 阻塞SIGCHLD ::

+ 直接调用 =fork=, =exec= and =wait=, 其终止状态与调用 =system= 是不同的 ::
