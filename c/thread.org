#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall


** pthread_create

**** prototype

#+BEGIN_SRC c
  #include <pthread.h>

  int pthread_create(pthread_t *tidp, const pthread_attr_t *attr,
      void *(*start_rtn)(void *), void *arg);
#+END_SRC

**** snippets

+ MkThrd

  #+BEGIN_SRC c
    pthread_t MkThrd(void *(*fn)(void *), void *arg) {
        pthread_t tid;
        pthread_attr_t attr;

        if (pthread_attr_init(&attr) != 0)
            err_sys("pthread_attr_init() error");
        if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0)
            err_sys("pthread_attr_setdetachstate() error");
        if (pthread_create(&tid, &attr, fn, arg) != 0)
            err_sys("pthread_create() error");
        pthread_attr_destroy(&attr);
        return tid;
    }
  #+END_SRC



** pthread_once

This routine can be used to ensure that a key we allocate by =pthread_key_create=  doesn’t change because of a race during initialization.

**** protocol

#+BEGIN_SRC c
#include <pthread.h>
pthread_once_t initflag = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *initflag, void (*initfn)(void));
#+END_SRC


** sigwait

可以使用sigwait在一个单独的线程中处理信号, 这是一种同步处理的方式

**** snippets

+ handle signal in one thread

  #+BEGIN_SRC c
    void *thr_fn(void *arg) {
        int err, signo;
        for (;;) {
            err = sigwait(&mask, &signo);
            if (err != 0)
                err_exit(err, "sigwait failed");
            switch (signo) {
            case SIGINT:
                /* TODO */
                break;
            case SIGQUIT:
                /* TODO */
                break;
            default:
                /* TODO */
                exit(1);
            }
        }
    }
  #+END_SRC

** Condition Variables

条件变量的意义在于: 仅当条件满足时, 才去争夺互斥锁, 并提供原子化操作

**** snippets

+ use condition variable to synchronize threads

  #+BEGIN_SRC c
    DATA data;
    pthread_cond_t  data_ready = PTHREAD_COND_INITIALIZER;
    pthread_mutex_t data_lock  = PTHREAD_MUTEX_INITIALIZER;

    void process_data() {
      pthread_mutex_lock(&data_lock);
      while (!is_data_ready(data)) {
        pthread_cond_wait(&data_ready, &data_lock);
      }

      /*
       * now process with data
       */

      pthread_mutex_unlock(&data_lock);
    }

    void make_data() {
      pthread_mutex_lock(&data_lock);
      initialize(&data);
      pthread_mutex_unlock(&data_lock);
      pthread_cond_signal(&data_ready);
    }

  #+END_SRC


** Spin Lock

A spin lock is like a mutex, except that instead of blocking a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired. A spin lock could be used in situations where locks are held for short periods of times and threads don’t want to incur the cost of being descheduled.

Besides providing a mutual exclusion mechanism, they block interrupts so an interrupt handler can’t deadlock the system by trying to acquire a spin lock that is already locked.

We need to be careful not to call any functions that might sleep while holding the spin lock. If we do, then we’ll waste CPU resources by extending the time other threads will spin if they try to acquire it.

Spin locks are useful when used in a nonpreemptive kernel where interrupt handlers can’t sleep, so the only synchronization primitives they can use are spin locks.

Because advances in modern processors makes context switch be at faster and faster rates, spin lock is useful only in limited circumstances.

**** protocol

#+BEGIN_SRC c
  #include <pthread.h>
  int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
  int pthread_spin_destroy(pthread_spinlock_t *lock);
  int pthread_spin_lock(pthread_spinlock_t *lock);
  int pthread_spin_trylock(pthread_spinlock_t *lock);
  int pthread_spin_unlock(pthread_spinlock_t *lock);
#+END_SRC


** Barrier

Barriers allow an arbitrary number of threads to wait until all of the threads have completed processing, but the threads don’t have to exit. They can continue working after all threads have reached the barrier.

**** protocol

#+BEGIN_SRC c
  #include <pthread.h>
  int pthread_barrier_wait(pthread_barrier_t *barrier);
  /* Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure */

  /* To one arbitrary thread, it will appear as if the pthread_barrier_wait function returned a value of PTHREAD_BARRIER_SERIAL_THREAD.
     The remaining threads see a return value of 0.
     This allows one thread to continue as the master to act on the results of the work done by all of the other threads. */
#+END_SRC

**** snippets

+ barrier is used to synchronize threads cooperating on a single task

#+BEGIN_SRC c
  #define NTHR 8             /* number of threads */
  #define NUMNUM 8000000L    /* number of numbers to sort */
  #define TNUM (NUMNUM/NTHR) /* number to sort per thread */

  long nums[NUMNUM];
  long snums[NUMNUM];
  pthread_barrier_t b;

  #ifdef SOLARIS
  #define heapsort qsort
  #else
  extern int heapsort(void *, size_t, size_t, int (*)(const void *, const void *));
  #endif

  /*
   * Compare two long integers (helper function for heapsort)
   */
  extern int complong(const void *arg1, const void *arg2);

  /*
   * Worker thread to sort a portion of the set of numbers.
   */
  void *thr_fn(void *arg)
  {
      long idx = (long)arg;
      heapsort(&nums[idx], TNUM, sizeof(long), complong);
      pthread_barrier_wait(&b);
  /*
   * Go off and perform more work ...
   */
      return((void *)0);
  }

  /*
   * Merge the results of the individual sorted ranges.
   */
  extern void merge();

  int main() {
      unsigned long i;
      int err;
      pthread_t tid;
  /*
   * Create the initial set of numbers to sort.
   */
      srandom(1);
      for (i = 0; i < NUMNUM; i++)
          nums[i] = random();
  /*
   * Create 8 threads to sort the numbers.
   */
      pthread_barrier_init(&b, NULL, NTHR+1);
      for (i = 0; i < NTHR; i++) {
          err = pthread_create(&tid, NULL, thr_fn, (void *)(i * TNUM));
          if (err != 0)
              err_exit(err, "can’t create thread");
      }
      pthread_barrier_wait(&b);
      merge();
  }
#+END_SRC


** Signal

Signals are delivered to a single thread in the process. If the signal is related to a hardware fault, the signal is usually sent to the thread whose action caused the event. Other signals, on the other hand, are delivered to an arbitrary thread.

** Gotcha

+ The newly created thread inherits the calling thread’s floating-point environment and signal mask ::

  However, the set of pending signals for the thread is cleared.

+ There is a copy of *errno* per thread ::

+ Dead lock ::

  Deadlock only happens when one thread attempts to lock the mutexes *in the opposite order from another thread.*

+ Reader–writer locks are well suited for situations in which data structures are read more often than they are modified ::

+ Condition variable itself is protected by a mutex ::

  A thread must first lock the mutex to change the condition state.

+ Alarm timers are a process resource ::

  It is not possible for multiple threads in a process to use alarm timers without interfering with one another
