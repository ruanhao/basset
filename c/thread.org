#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall


** pthread_create

**** prototype

#+BEGIN_SRC c
  #include <pthread.h>

  int pthread_create(pthread_t *tidp, const pthread_attr_t *attr,
      void *(*start_rtn)(void *), void *arg);
#+END_SRC

**** snippets

+ MkThrd

  #+BEGIN_SRC c
    pthread_t MkThrd(void *(*fn)(void *), void *arg) {
        pthread_t tid;
        pthread_attr_t attr;

        if (pthread_attr_init(&attr) != 0)
            err_sys("pthread_attr_init() error");
        if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0)
            err_sys("pthread_attr_setdetachstate() error");
        if (pthread_create(&tid, &attr, fn, arg) != 0)
            err_sys("pthread_create() error");
        pthread_attr_destroy(&attr);
        return tid;
    }
  #+END_SRC



** Condition Variables

条件变量的意义在于: 仅当条件满足时, 才去争夺互斥锁, 并提供原子化操作

**** snippets

+ use condition variable to synchronize threads

  #+BEGIN_SRC c
    DATA data;
    pthread_cond_t  data_ready = PTHREAD_COND_INITIALIZER;
    pthread_mutex_t data_lock  = PTHREAD_MUTEX_INITIALIZER;

    void process_data() {
      pthread_mutex_lock(&data_lock);
      while (!is_data_ready(data)) {
        pthread_cond_wait(&data_ready, &data_lock);
      }

      /*
       * now process with data
       */

      pthread_mutex_unlock(&data_lock);
    }

    void make_data() {
      pthread_mutex_lock(&data_lock);
      initialize(&data);
      pthread_mutex_unlock(&data_lock);
      pthread_cond_signal(&data_ready);
    }

  #+END_SRC

** Spin Lock

A spin lock is like a mutex, except that instead of blocking a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired. A spin lock could be used in situations where locks are held for short periods of times and threads don’t want to incur the cost of being descheduled.

Besides providing a mutual exclusion mechanism, they block interrupts so an interrupt handler can’t deadlock the system by trying to acquire a spin lock that is already locked.

We need to be careful not to call any functions that might sleep while holding the spin lock. If we do, then we’ll waste CPU resources by extending the time other threads will spin if they try to acquire it.

Spin locks are useful when used in a nonpreemptive kernel where interrupt handlers can’t sleep, so the only synchronization primitives they can use are spin locks.

Because advances in modern processors makes context switch be at faster and faster rates, spin lock is useful only in limited circumstances.

**** protocol

#+BEGIN_SRC c
  #include <pthread.h>
  int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
  int pthread_spin_destroy(pthread_spinlock_t *lock);
  int pthread_spin_lock(pthread_spinlock_t *lock);
  int pthread_spin_trylock(pthread_spinlock_t *lock);
  int pthread_spin_unlock(pthread_spinlock_t *lock);
#+END_SRC

** Barrier

**** protocol

#+BEGIN_SRC c
  #include <pthread.h>
  int pthread_barrier_wait(pthread_barrier_t *barrier);
  /* Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure */

  /* To one arbitrary thread, it will appear as if the pthread_barrier_wait function returned a value of PTHREAD_BARRIER_SERIAL_THREAD.
     The remaining threads see a return value of 0.
     This allows one thread to continue as the master to act on the results of the work done by all of the other threads. */
#+END_SRC

** Gotcha

+ The newly created thread inherits the calling thread’s floating-point environment and signal mask ::

  However, the set of pending signals for the thread is cleared.

+ There is a copy of *errno* per thread ::

+ Dead lock ::

  Deadlock only happens when one thread attempts to lock the mutexes *in the opposite order from another thread.*

+ Reader–writer locks are well suited for situations in which data structures are read more often than they are modified ::

+ Condition variable itself is protected by a mutex ::

  A thread must first lock the mutex to change the condition state.
