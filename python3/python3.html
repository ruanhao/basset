<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-05-10 Fri 16:18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Python3</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Hao Ruan">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="../org-html-themes/org/style2.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Python3</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1274a54">1. 数据结构</a>
<ul>
<li><a href="#org4ce22a7">1.1. 序列类型</a>
<ul>
<li><a href="#orgb85c346">1.1.1. 元组</a></li>
<li><a href="#orgbdf37fd">1.1.2. 具名元组</a></li>
<li><a href="#orgad34dd8">1.1.3. 列表</a></li>
<li><a href="#org17f3472">1.1.4. 数组</a></li>
<li><a href="#orgcbba544">1.1.5. 内存视图</a></li>
<li><a href="#org7575f53">1.1.6. 双向队列</a></li>
</ul>
</li>
<li><a href="#org8802d8d">1.2. 字典</a>
<ul>
<li><a href="#orgfd8c30d">1.2.1. __missing__方法</a></li>
<li><a href="#org8e960fb">1.2.2. 散列表</a>
<ul>
<li><a href="#orgcd1bb17">1.2.2.1. 加盐</a></li>
<li><a href="#org9c98648">1.2.2.2. 散列表算法</a></li>
<li><a href="#orgfdbbbef">1.2.2.3. 可散列对象必须满足的条件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga591478">1.3. 集合</a>
<ul>
<li><a href="#org2114250">1.3.1. 合集，交集，差集</a></li>
</ul>
</li>
<li><a href="#org89df4d0">1.4. Unicode</a>
<ul>
<li><a href="#org96a5f0c">1.4.1. 字符编码的工作方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org69ecf28">2. 函数</a>
<ul>
<li><a href="#org4d24861">2.1. 函数参数</a>
<ul>
<li><a href="#org0fe6e12">2.1.1. 仅限关键字参数</a></li>
<li><a href="#orgf8d2a77">2.1.2. 默认参数的陷阱</a></li>
</ul>
</li>
<li><a href="#org8dd79b7">2.2. 函数属性</a></li>
<li><a href="#org9063b76">2.3. 局部变量作用域规则</a></li>
<li><a href="#org505fcc1">2.4. 闭包</a>
<ul>
<li><a href="#org0667998">2.4.1. 自由变量定义</a></li>
<li><a href="#org898dc72">2.4.2. 闭包元信息（__code__, __closure__）</a></li>
<li><a href="#org7cc4b93">2.4.3. nonlocal</a></li>
<li><a href="#orgc837b5f">2.4.4. 闭包的陷阱</a></li>
</ul>
</li>
<li><a href="#org76045ae">2.5. 参数化装饰器</a></li>
</ul>
</li>
<li><a href="#org032fc0a">3. 面向对象编程</a>
<ul>
<li><a href="#orgc84d5d6">3.1. 对象的比较(== 与 is)</a></li>
<li><a href="#orgfb49d49">3.2. 对象的深复制与浅复制</a></li>
<li><a href="#org2c7a1b6">3.3. 垃圾回收</a>
<ul>
<li><a href="#org8a8b4fe">3.3.1. 监控对象回收(weakref.finalize)</a></li>
</ul>
</li>
<li><a href="#orgfef3fe1">3.4. 弱引用</a>
<ul>
<li><a href="#orga453d60">3.4.1. 创建弱引用</a></li>
<li><a href="#orgc6c6312">3.4.2. weakref.WeakValueDictionary</a></li>
<li><a href="#org00bed80">3.4.3. weakref.WeakKeyDictionary</a></li>
<li><a href="#org72263c8">3.4.4. weakref.WeakSet</a></li>
<li><a href="#org9b71364">3.4.5. 弱引用的局限</a></li>
<li><a href="#org668af79">3.4.6. 对象支持弱引用(__weakref__属性)</a></li>
</ul>
</li>
<li><a href="#org37b5431">3.5. 抽象类</a>
<ul>
<li><a href="#orgc55e26e">3.5.1. 内置抽象基类</a></li>
<li><a href="#orgff83259">3.5.2. 自定义抽象基类</a></li>
<li><a href="#org5909b49">3.5.3. 虚拟子类</a>
<ul>
<li><a href="#org7239509">3.5.3.1. __subclasses__</a></li>
<li><a href="#org87a7e04">3.5.3.2. _abc_registry</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbdc198b">3.6. 继承</a></li>
<li><a href="#org2d456c5">3.7. classmethod / staticmethod 装饰器</a></li>
<li><a href="#orga6059a9">3.8. __slots__属性</a>
<ul>
<li><a href="#orgbcd99d8">3.8.1. 节省的内存也可能被再次吃掉</a></li>
</ul>
</li>
<li><a href="#org2da6513">3.9. __getattr__方法</a></li>
</ul>
</li>
<li><a href="#org772bfa9">4. 流程控制</a>
<ul>
<li><a href="#orgc86db83">4.1. 内置的 iter 函数</a></li>
<li><a href="#org9bd123e">4.2. 生成器</a></li>
<li><a href="#orgaf9e9a5">4.3. for/else, while/else, try/else</a></li>
<li><a href="#orgf60ffc4">4.4. 上下文管理协议(with)</a></li>
<li><a href="#orgcd4d141">4.5. 协程</a>
<ul>
<li><a href="#org26bf348">4.5.1. 协程的状态</a></li>
<li><a href="#org014e03e">4.5.2. 执行过程举例</a></li>
<li><a href="#org010d4a9">4.5.3. 预激(prime)</a></li>
<li><a href="#orgfeb04bc">4.5.4. 协程的终止和异常处理</a>
<ul>
<li><a href="#org9f21181">4.5.4.1. generator.throw()</a></li>
<li><a href="#orgbb9adde">4.5.4.2. generator.close()</a></li>
</ul>
</li>
<li><a href="#org971fd43">4.5.5. yield from</a>
<ul>
<li><a href="#org7d55aee">4.5.5.1. yield from 工作原理</a></li>
<li><a href="#orgaa5634d">4.5.5.2. yield from 对异常和终止的处理</a></li>
<li><a href="#orgd7bf2bc">4.5.5.3. yield from 表达式的值</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org35f1b91">5. 并发编程</a>
<ul>
<li><a href="#org28bdaaa">5.1. 全局解释锁 (GIL)</a>
<ul>
<li><a href="#orga6ffae1">5.1.1. I/O 密集型操作</a></li>
<li><a href="#orgf32ff4e">5.1.2. CPU 密集型操作</a></li>
</ul>
</li>
<li><a href="#org5c4fb3d">5.2. 基于 concurrent.futures 模块的并发编程</a>
<ul>
<li><a href="#org34fc7e0">5.2.1. Executor.map(func, *iterables, timeout=None, chunksize=1)</a></li>
<li><a href="#org7e480db">5.2.2. Executor.sumit(fn, *args, **kwargs)</a></li>
<li><a href="#org3c6c1b1">5.2.3. concurrent.futures.as_completed(fs, timeout=None)</a></li>
</ul>
</li>
<li><a href="#org5a16070">5.3. 基于 asyncio 包的并发编程</a>
<ul>
<li><a href="#org589465b">5.3.1. 基本思想 (面向事件编程)</a></li>
<li><a href="#orgbdb2b36">5.3.2. @asyncio.coroutine 装饰器（或 async 关键字）</a></li>
<li><a href="#orgd83e745">5.3.3. asyncio.Future</a></li>
<li><a href="#orgff310f2">5.3.4. asyncio.Task</a>
<ul>
<li><a href="#org5bab0f7">5.3.4.1. 创建 Task 对象</a></li>
</ul>
</li>
<li><a href="#orgae1b3b0">5.3.5. APIs</a>
<ul>
<li><a href="#org0920464">5.3.5.1. BaseEventLoop.run_in_executor(executor, func, *args)</a></li>
<li><a href="#orgec9a2c6">5.3.5.2. asyncio.as_complete(fs, *, loop=None, timeout=None)</a></li>
<li><a href="#org2566f9f">5.3.5.3. asyncio.Semaphore(value=1, *, loop=None)</a></li>
<li><a href="#org27090d8">5.3.5.4. asyncio.wait(futures, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgad7ff1f">6. 元编程</a>
<ul>
<li><a href="#org88a75f6">6.1. 属性查找顺序</a>
<ul>
<li><a href="#org67a744c">6.1.1. 从类中查找属性</a></li>
<li><a href="#org812cf4f">6.1.2. 从实例中查找属性</a></li>
</ul>
</li>
<li><a href="#org4f5c9e2">6.2. 特殊方法__new__</a></li>
<li><a href="#org6115bc3">6.3. property(fget=None, fset=None, fdel=None, doc=None)</a></li>
<li><a href="#org9d27c51">6.4. 动态属性编程 API</a>
<ul>
<li><a href="#org4b87ab2">6.4.1. 特殊属性</a>
<ul>
<li><a href="#orgfb3e609">6.4.1.1. __class__属性</a></li>
<li><a href="#org75a337c">6.4.1.2. __dict__属性</a></li>
<li><a href="#org973ac8e">6.4.1.3. __slots__属性</a></li>
</ul>
</li>
<li><a href="#org5e0c94a">6.4.2. 内置函数</a>
<ul>
<li><a href="#org1ba832b">6.4.2.1. dir([obj])</a></li>
<li><a href="#orgd791302">6.4.2.2. getattr(obj, name[, default])</a></li>
<li><a href="#org1992080">6.4.2.3. hasattr(obj, name)</a></li>
<li><a href="#org413a7e0">6.4.2.4. setattr(obj, name, value)</a></li>
<li><a href="#org2ca23cd">6.4.2.5. vars([obj])</a></li>
</ul>
</li>
<li><a href="#orga99cebe">6.4.3. 特殊方法</a>
<ul>
<li><a href="#org1cd71d3">6.4.3.1. __delattr__(self, name)</a></li>
<li><a href="#org2d35784">6.4.3.2. __dir__(self)</a></li>
<li><a href="#org82b7e2f">6.4.3.3. __getattr__(self, name)</a></li>
<li><a href="#org0661958">6.4.3.4. __getattribute__(self, name)</a></li>
<li><a href="#org4cc3e2f">6.4.3.5. __setattr__(self, name, value)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3becdee">6.5. 描述符(Descriptor)</a>
<ul>
<li><a href="#org3d2b031">6.5.1. 只实现__get__的描述符</a></li>
<li><a href="#org85cd0f0">6.5.2. 只实现__set__的描述符</a>
<ul>
<li><a href="#org8eb16f9">6.5.2.1. 实现__get__和__set__的描述符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbb8b011">6.6. 元类</a>
<ul>
<li><a href="#org444a99c">6.6.1. 使用 type 动态创建类</a></li>
<li><a href="#org7df0020">6.6.2. 使用 <b>metaclass</b> 指定元类</a></li>
<li><a href="#org5d152aa">6.6.3. __prepare__方法</a></li>
<li><a href="#org1a3115b">6.6.4. 与元编程相关的类属性/方法</a>
<ul>
<li><a href="#org98fe18e">6.6.4.1. cls.__bases__</a></li>
<li><a href="#org2682b71">6.6.4.2. cls.__qualname__</a></li>
<li><a href="#org38b7562">6.6.4.3. cls.__subclass__()</a></li>
<li><a href="#org5bf93df">6.6.4.4. cls.mro()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2cfafba">7. 代码仓库</a>
<ul>
<li><a href="#orgb49aa25">7.1. 数据结构</a>
<ul>
<li><a href="#org7c66058">7.1.1. 序列操作</a>
<ul>
<li><a href="#orga07ae79">7.1.1.1. 使用 * 处理元组拆包</a></li>
<li><a href="#orgf78d8d3">7.1.1.2. 对序列重排位(itemgetter)</a></li>
<li><a href="#org04e4a42">7.1.1.3. 给切片赋值</a></li>
<li><a href="#org425f4e1">7.1.1.4. 使用 bisect 管理已排序序列</a>
<ul>
<li><a href="#orged616df">7.1.1.4.1. 使用 bisect 搜索</a></li>
<li><a href="#orgb2fb321">7.1.1.4.2. 使用 bisect 建立查询表格</a></li>
<li><a href="#org2ae9e22">7.1.1.4.3. 使用 bisect.insort 插入新元素</a></li>
</ul>
</li>
<li><a href="#org3ba5a15">7.1.1.5. 列表中删除数据的陷阱</a>
<ul>
<li><a href="#org7cf43e7">7.1.1.5.1. 原理</a></li>
<li><a href="#org628f36c">7.1.1.5.2. 解决方法</a></li>
</ul>
</li>
<li><a href="#org1bb342b">7.1.1.6. 列表中出现频率最高</a></li>
<li><a href="#org4b94d07">7.1.1.7. 列表中最大或最小的几项</a></li>
<li><a href="#org6fffa7c">7.1.1.8. 对列表中的数据分组</a></li>
<li><a href="#org918a783">7.1.1.9. 消除序列中的重复数据，同时保持数据顺序</a></li>
<li><a href="#org833459e">7.1.1.10. 序列解包 (unpack)</a></li>
<li><a href="#orgba383cd">7.1.1.11. flatten 列表</a></li>
<li><a href="#org503d68f">7.1.1.12. 优先队列</a></li>
</ul>
</li>
<li><a href="#org05026f9">7.1.2. 字典操作</a>
<ul>
<li><a href="#org4386139">7.1.2.1. defaultdict</a></li>
<li><a href="#orgd7d9be2">7.1.2.2. OrderedDict</a></li>
<li><a href="#orgab49b4b">7.1.2.3. ChainMap</a></li>
<li><a href="#orgfb7a892">7.1.2.4. Counter</a></li>
<li><a href="#orgfe4ad42">7.1.2.5. UserDict </a></li>
<li><a href="#org77b2f2e">7.1.2.6. 不可变映射类型(MappingProxyType)</a></li>
<li><a href="#orgde916c2">7.1.2.7. 对字典作集合运算</a></li>
<li><a href="#orgded1856">7.1.2.8. 组合多个字典当作一个字典使用</a></li>
<li><a href="#org2c42265">7.1.2.9. 字典栈</a></li>
</ul>
</li>
<li><a href="#orgea35115">7.1.3. 文本操作</a>
<ul>
<li><a href="#orgc3ac50d">7.1.3.1. 获取 Unicode 字符名称(unicodedata)</a></li>
<li><a href="#org4fba75c">7.1.3.2. 字符编码侦测(Chardet)</a></li>
<li><a href="#org87f9116">7.1.3.3. 格式化</a>
<ul>
<li><a href="#org876c020">7.1.3.3.1. 填充与对齐</a></li>
<li><a href="#org6e63eef">7.1.3.3.2. 字符串截断</a></li>
<li><a href="#orgbc7bbaa">7.1.3.3.3. 占位符</a></li>
<li><a href="#orge0ce33b">7.1.3.3.4. 排版</a></li>
</ul>
</li>
<li><a href="#org1812ac8">7.1.3.4. 字符串匹配</a>
<ul>
<li><a href="#org762684f">7.1.3.4.1. 使用 shell 风格的通配符匹配字符串</a></li>
<li><a href="#org5364b9f">7.1.3.4.2. 贪婪和非贪婪匹配</a></li>
</ul>
</li>
<li><a href="#org093c8fb">7.1.3.5. 输入密码</a></li>
</ul>
</li>
<li><a href="#org8a9a64c">7.1.4. 字节操作</a>
<ul>
<li><a href="#org096ce26">7.1.4.1. 将字节序列转换成不同类型字段组成的元组(struct)</a></li>
</ul>
</li>
<li><a href="#orged1e052">7.1.5. 时间操作</a>
<ul>
<li><a href="#org0e182db">7.1.5.1. time 模块</a>
<ul>
<li><a href="#orge6cecba">7.1.5.1.1. 获取 Unix Timestamp</a></li>
<li><a href="#org9a470ac">7.1.5.1.2. 获取具体时间值</a></li>
</ul>
</li>
<li><a href="#org679f398">7.1.5.2. datatime 模块</a>
<ul>
<li><a href="#orge07fb7f">7.1.5.2.1. 创建时间</a></li>
<li><a href="#orgbf5d1d8">7.1.5.2.2. 获取 UTC 时间</a></li>
<li><a href="#org6ccd080">7.1.5.2.3. 获取当前时区时间</a></li>
<li><a href="#org00d85fb">7.1.5.2.4. 日期运算</a></li>
<li><a href="#org0b2c172">7.1.5.2.5. 日期转字符串</a></li>
<li><a href="#org9972bc9">7.1.5.2.6. 字符串转日期</a></li>
</ul>
</li>
<li><a href="#org1de0973">7.1.5.3. 获取月份缩写</a></li>
</ul>
</li>
<li><a href="#org2099429">7.1.6. 数字操作</a>
<ul>
<li><a href="#org8002a15">7.1.6.1. 数字格式化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9f4ed47">7.2. 函数</a>
<ul>
<li><a href="#org1063e7d">7.2.1. 获取函数签名信息(inspect.signature)</a>
<ul>
<li><a href="#org853540d">7.2.1.1. 绑定参数到函数签名中(inspect.Signature.bind)</a></li>
</ul>
</li>
<li><a href="#org6400aa8">7.2.2. 函数式编程风格(operator)</a>
<ul>
<li><a href="#orgb09760c">7.2.2.1. 数学运算</a></li>
<li><a href="#orgbe3d590">7.2.2.2. 从序列中取出元素(itemgetter)</a></li>
<li><a href="#orgab3ae95">7.2.2.3. 读取对象属性(attrgetter)</a></li>
<li><a href="#orgd37bebf">7.2.2.4. 调用对象方法(methodcall)</a></li>
</ul>
</li>
<li><a href="#org1b2d692">7.2.3. 使用装饰器</a>
<ul>
<li><a href="#org926e3a9">7.2.3.1. 记录函数运行时间</a></li>
<li><a href="#org483245f">7.2.3.2. 缓存函数返回值(functools.lru_cache)</a></li>
<li><a href="#org844f086">7.2.3.3. 单分派泛函(functools.singledispatch)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5c0aa19">7.3. IO 编程</a>
<ul>
<li><a href="#org91a6f5d">7.3.1. 文件 IO</a>
<ul>
<li><a href="#org76e3d8d">7.3.1.1. 将文件描述符包装成文件对象</a></li>
<li><a href="#org8b3c426">7.3.1.2. 改变已打开文件的编码方式</a></li>
</ul>
</li>
<li><a href="#org34d512b">7.3.2. 内存 IO</a>
<ul>
<li><a href="#org0dba786">7.3.2.1. 内存字符串</a></li>
<li><a href="#org4197d4f">7.3.2.2. 内存比特流</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6f8b1e8">7.4. 面向对象编程</a>
<ul>
<li><a href="#org0eb61cf">7.4.1. 为实例属性提供默认值</a></li>
<li><a href="#orgca48d17">7.4.2. 创建缓存对象</a></li>
<li><a href="#org4633cb7">7.4.3. 使用抽象类</a></li>
<li><a href="#org72ce371">7.4.4. 处理 Json 数据</a>
<ul>
<li><a href="#orgf8e1e53">7.4.4.1. 使用 OrderedDict 处理 Json 数据</a></li>
<li><a href="#org07e5bff">7.4.4.2. 使用 Json 数据填充对象</a></li>
<li><a href="#org88e1f9a">7.4.4.3. 将对象序列化成 Json 数据</a></li>
<li><a href="#org8ff16b3">7.4.4.4. 将 Json 数据反序列化成对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1b8436b">7.5. 流程控制</a>
<ul>
<li><a href="#orgf5ec898">7.5.1. 归约函数</a>
<ul>
<li><a href="#org3169de6">7.5.1.1. all(it)</a></li>
<li><a href="#org7207c6e">7.5.1.2. any(it)</a></li>
<li><a href="#org3cac38b">7.5.1.3. max(it, [key], [default])</a></li>
<li><a href="#orgdf8aaed">7.5.1.4. min(it, [key], [default])</a></li>
<li><a href="#orgef171f2">7.5.1.5. functools.reduce(func, it, [initial])</a></li>
<li><a href="#orgc916733">7.5.1.6. sum(it, start=0)</a></li>
</ul>
</li>
<li><a href="#org8a703f9">7.5.2. 标准库中的生成器函数</a>
<ul>
<li><a href="#org1e53855">7.5.2.1. 用于过滤的生成器函数</a>
<ul>
<li><a href="#org58141d3">7.5.2.1.1. itertools.compress(it, selector_it)</a></li>
<li><a href="#org87a40e3">7.5.2.1.2. itertools.dropwhile(predicate, it)</a></li>
<li><a href="#org86a4c65">7.5.2.1.3. builtin.filter(predicate, it)</a></li>
<li><a href="#orgd2b2afb">7.5.2.1.4. itertools.filterfalse(predicate, it)</a></li>
<li><a href="#org9f1f81a">7.5.2.1.5. itertools.islice(it, [start], stop, step=1)</a></li>
<li><a href="#org00a0af2">7.5.2.1.6. itertools.takewhile(predicate, it)</a></li>
<li><a href="#org33d6c4b">7.5.2.1.7. builtin.iter(callable, sentinel)</a></li>
</ul>
</li>
<li><a href="#orgbc33e2c">7.5.2.2. 用于映射的生成器函数</a>
<ul>
<li><a href="#orgf643e64">7.5.2.2.1. itertools.accumulate(it, [func])</a></li>
<li><a href="#org04846f0">7.5.2.2.2. builtin.enumerate(it, start=0)</a></li>
<li><a href="#org7926be5">7.5.2.2.3. builtin.map(func, it1, [it2, &#x2026;, itN])</a></li>
<li><a href="#orge56e3ee">7.5.2.2.4. itertools.starmap(func, it)</a></li>
</ul>
</li>
<li><a href="#orgaa1ae5f">7.5.2.3. 用于合并可迭代对象的生成器函数</a>
<ul>
<li><a href="#org6fc3b41">7.5.2.3.1. itertools.chain(it1, &#x2026;, itN)</a></li>
<li><a href="#orgb9caa06">7.5.2.3.2. itertools.chain.from_iterable(it)</a></li>
<li><a href="#org57d04c0">7.5.2.3.3. itertaools.product(it1, &#x2026;, itN, repeat=1)</a></li>
<li><a href="#org7851d01">7.5.2.3.4. builtin.zip(it1, .., itN)</a></li>
<li><a href="#orgc16c335">7.5.2.3.5. itertools.zip_longest(it1, &#x2026;, itN, fillvalue=None)</a></li>
</ul>
</li>
<li><a href="#orgc62f5f2">7.5.2.4. 用于扩展输出元素的生成器函数</a>
<ul>
<li><a href="#org423aa0b">7.5.2.4.1. itertools.combinations(it, out_len)</a></li>
<li><a href="#org3d20654">7.5.2.4.2. itertools.combinations_with_replacement(it, out_len)</a></li>
<li><a href="#org3cd5156">7.5.2.4.3. itertools.permutation(it, out_len=None)</a></li>
<li><a href="#orgb4bf77d">7.5.2.4.4. itertools.count(start=0, step=1)</a></li>
<li><a href="#org21c0319">7.5.2.4.5. itertools.cycle(it)</a></li>
<li><a href="#org086c415">7.5.2.4.6. itertools.repeat(item, [times])</a></li>
</ul>
</li>
<li><a href="#org6af9e68">7.5.2.5. 用于重新排列元素的生成器函数</a>
<ul>
<li><a href="#orgfbe4b43">7.5.2.5.1. itertools.groupby(it, key=None)</a></li>
<li><a href="#org73665d0">7.5.2.5.2. builtin.reversed(seq)</a></li>
<li><a href="#org4dfa3dc">7.5.2.5.3. itertools.tee(it, n=2)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org855d13e">7.5.3. 上下文管理 </a>
<ul>
<li><a href="#org807b771">7.5.3.1. 自动关闭对象(closing)</a></li>
<li><a href="#org42cbdd7">7.5.3.2. 忽略异常(suppress)</a></li>
<li><a href="#org9cb937d">7.5.3.3. 重定向(redirect_stdout)</a></li>
<li><a href="#orgd194af3">7.5.3.4. 使用生成器作为上下文管理器(@contextmanager)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf02367f">7.6. 并发编程</a>
<ul>
<li><a href="#org5502fe0">7.6.1. 创建子进程</a></li>
<li><a href="#org400d913">7.6.2. 子进程的输入输出</a></li>
<li><a href="#org8509298">7.6.3. 进程间通信</a></li>
<li><a href="#org36062a3">7.6.4. 创建线程</a></li>
<li><a href="#org79f385c">7.6.5. 线程加锁</a></li>
<li><a href="#org96612ca">7.6.6. thread local</a></li>
<li><a href="#orgeb1b65e">7.6.7. 线程池</a></li>
</ul>
</li>
<li><a href="#org4dfe418">7.7. 元编程</a>
<ul>
<li><a href="#orgfe8afd5">7.7.1. 控制类的属性定义的顺序</a></li>
<li><a href="#org3552ece">7.7.2. 控制类的创建</a>
<ul>
<li><a href="#org115fb22">7.7.2.1. 实例缓存</a></li>
<li><a href="#org178c163">7.7.2.2. 单例</a></li>
<li><a href="#org3c1b318">7.7.2.3. 禁用直接实例化</a></li>
</ul>
</li>
<li><a href="#org6e48d73">7.7.3. 不通过__init__方法创建实例</a></li>
<li><a href="#orga215475">7.7.4. 动态定义类</a></li>
<li><a href="#org7d0d654">7.7.5. 猴子补丁</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5ede079">8. 参考文档</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1274a54" class="outline-2">
<h2 id="org1274a54"><span class="section-number-2">1</span> 数据结构</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4ce22a7" class="outline-3">
<h3 id="org4ce22a7"><span class="section-number-3">1.1</span> 序列类型</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Python 标准库使用 C 实现了丰富的序列类型，如：
</p>

<ul class="org-ul">
<li><p>
容器序列 (存放不同类型的数据 <span class="underline">引用</span>)
</p>

<p>
list, tuple, collections.deque
</p></li>

<li><p>
扁平序列 (存放一种类型的数据 <span class="underline">值</span>)
</p>

<p>
str, bytes, bytearray, memoryview, array.array
</p></li>
</ul>


<div class="org-src-container">
<pre class="src src-plantuml">class Container {
    __contains__();
}

class Iterable {
    __iter__();
}

class Sized {
    __len__();
}

class Sequence {
    __getitem__();
    __contains__();
    __iter__();
    __reversed__();
    index();
    count();
}

class MutableSequence {
    __setitem__();
    __delitem__();
    insert();
    append();
    reverse();
    extend();
    pop();
    remove();
    __iadd__();
}

Container &lt;|-- Sequence
Iterable &lt;|-- Sequence
Sized &lt;|-- Sequence

Sequence &lt;|-right- MutableSequence
</pre>
</div>

<div class="figure">
<p><img src="img/seq_vs_mutable.png" alt="seq_vs_mutable.png">
</p>
<p><span class="figure-number">Figure 1: </span>可变序列 MutableSequence 和不可变序列 Sequence 的差异：（两个都是 <code>collection.abc</code> 中的类）</p>
</div>
</div>


<div id="outline-container-orgb85c346" class="outline-4">
<h4 id="orgb85c346"><span class="section-number-4">1.1.1</span> 元组</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
元组通常被用作 <span class="underline">不可变的列表</span> 。
但元组的意义是 <span class="underline">对数据的记录</span> ：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。
正是这个位置信息给数据赋予了意义。
</p>
</div>
</div>


<div id="outline-container-orgbdf37fd" class="outline-4">
<h4 id="orgbdf37fd"><span class="section-number-4">1.1.2</span> 具名元组</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">
<pre class="src src-ipython">from collections import namedtuple
City = namedtuple('City', 'name country population coordinates')
tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
log("tokyo", tokyo)
log("tokyo.population", tokyo.population)
log("tokyo.coordinates", tokyo.coordinates)
log("tokyo[1]", tokyo[1])
</pre>
</div>

<pre class="example">
=========== tokyo ============
City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))
====== tokyo.population ======
36.933
===== tokyo.coordinates ======
(35.689722, 139.691667)
========== tokyo[1] ==========
JP

</pre>


<p>
除了从普通元组继承来的属性之外，具名元祖还有一些自己专用的属性：
</p>

<div class="org-src-container">
<pre class="src src-ipython">log("City._fields", City._fields)

LatLong = namedtuple('LatLong', 'lat long')
delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889))
delhi = City._make(delhi_data)
log("delhi._asdict()", delhi._asdict())
print()
for key, value in delhi._asdict().items():
    print(key + ':', value)

</pre>
</div>

<pre class="example">
======== City._fields ========
('name', 'country', 'population', 'coordinates')
====== delhi._asdict() =======
OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])

name: Delhi NCR
country: IN
population: 21.935
coordinates: LatLong(lat=28.613889, long=77.208889)

</pre>
</div>
</div>


<div id="outline-container-orgad34dd8" class="outline-4">
<h4 id="orgad34dd8"><span class="section-number-4">1.1.3</span> 列表</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
切片操作里不包含区间范围的最后一个元素是 Python 的风格，这个习惯带来的好处如下：
</p>

<ul class="org-ul">
<li>当只有最后一个位置信息时，可以快速看出有几个元素： <code>range(3)</code> 和 <code>my_list[:3]</code> 都返回 3 个元素</li>
<li>当起止位置信息都可见时，可以快速计算出区间长度，即 <code>stop - start</code></li>
<li>可以利用任意一个下标把序列分割成不重叠的两部分，只需写成： <code>my_list[:3]</code> 和 <code>my_list[3:]</code></li>
</ul>
</div>
</div>


<div id="outline-container-org17f3472" class="outline-4">
<h4 id="org17f3472"><span class="section-number-4">1.1.4</span> 数组</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
如果需要一个只包含数字的列表，使用 <code>array.array</code> 比 <code>list</code> 更高效。
</p>

<p>
创建数组需要一个类型码，用来表示底层的 C 语言应存放怎样的数据类型。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from array import array
from random import random
floats = array('d', (random() for i in range(1000)))  # 'd' 表示双精度浮点
log("floats[-1]", floats[-1])
</pre>
</div>

<pre class="example">
========= floats[-1] =========
0.970088201571867

</pre>
</div>
</div>


<div id="outline-container-orgcbba544" class="outline-4">
<h4 id="orgcbba544"><span class="section-number-4">1.1.5</span> 内存视图</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
<code>memoryview</code> 是一个内置类，能让用户在 <span class="underline">不复制内容的情况下</span> ，在数据结构之间 <span class="underline">共享内存</span> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython"># 通过改变数组中的一个字节来更新数组里某个元素的值
import array
numbers = array.array('h', [-2, -1, 0, 1, 2])  # 'h' 表示 16 位二进制整数
memv = memoryview(numbers)

# memoryview.cast 会把同一块内存里的内容打包成一个全新的 memoryview
memv_oct = memv.cast('B')   # 'B' 表示无符号字符
memv_oct[5] = 4

log("numbers", numbers)
</pre>
</div>

<pre class="example">
========== numbers ===========
array('h', [-2, -1, 1024, 1, 2])

</pre>
</div>
</div>


<div id="outline-container-org7575f53" class="outline-4">
<h4 id="org7575f53"><span class="section-number-4">1.1.6</span> 双向队列</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
<code>collection.deque</code> 是一个 <b>线程安全</b> ，可以快速从两端添加或删除元素的数据类型。
</p>


<p>
如果想要一种数据结构来存放 <span class="underline">最近用到的几个元素</span> ，deque 是一个很好的选择。
</p>


<div class="org-src-container">
<pre class="src src-ipython">from collections import deque
dq = deque(range(10), maxlen=10)
log("dq", dq)

dq.rotate(3)
log("dq.rotate(3)", dq)

dq.rotate(-4)
log("dq.rotate(-4)", dq)

dq.appendleft(-1)
log("dq.appendleft(-1)", dq)

dq.extend([11, 22, 33])
log("dq.extend([11, 22, 33])", dq)

</pre>
</div>

<pre class="example">
============= dq =============
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
======== dq.rotate(3) ========
deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
======= dq.rotate(-4) ========
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)
===== dq.appendleft(-1) ======
deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
== dq.extend([11, 22, 33]) ===
deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)
</pre>
</div>
</div>
</div>




<div id="outline-container-org8802d8d" class="outline-3">
<h3 id="org8802d8d"><span class="section-number-3">1.2</span> 字典</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-plantuml">class Container {
    __contains__();
}

class Iterable {
    __iter__();
}

class Sized {
    __len__();
}

class Mapping {
    __getitem__();
    __contains__();
    __eq__();
    __ne__();
    get();
    items();
    keys();
    values();
}

class MutableSequence {
    __setitem__();
    __delitem__();
    clear();
    pop();
    popitem();
    setdefault();
    update();
}

Container &lt;|-- Mapping
Iterable &lt;|-- Mapping
Sized &lt;|-- Mapping

Mapping &lt;|-right- MutableMapping
</pre>
</div>

<div class="figure">
<p><img src="img/map_vs_mutable.png" alt="map_vs_mutable.png">
</p>
<p><span class="figure-number">Figure 2: </span><code>collections.abc</code> 中的 MutableMapping 和它的超类</p>
</div>


<p>
非抽象映射类型一般不会直接继承 collections.abc 中的抽象基类，
而是直接对 dict 或是 collections.UserDict 进行扩展。
这些抽象基类的主要作用是 <span class="underline">形式化文档</span> ，可以和 isinstance 一起被用来判定某个数据是不是 <b>广义上的映射类型</b> ：
</p>

<div class="org-src-container">
<pre class="src src-ipython">from collections import abc
d = {}
print(isinstance(d, abc.Mapping))
</pre>
</div>

<pre class="example">
True

</pre>
</div>


<div id="outline-container-orgfd8c30d" class="outline-4">
<h4 id="orgfd8c30d"><span class="section-number-4">1.2.1</span> __missing__方法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
映射类型在处理找不到的键的时候，都会涉及__missing__方法。
虽然基类 dict 没有定义这个方法，但是如果一个类继承了 dict ，然后提供了__missing__方法，
那么当__getitem__遇到找不到键的时候，Python 会自动调用它，而不是抛出 KeyError 异常。
</p>

<p>
<b>__missing__ 方法只会被__getitem__调用（即使用表达式 d[k] ）</b>
</p>
</div>
</div>


<div id="outline-container-org8e960fb" class="outline-4">
<h4 id="org8e960fb"><span class="section-number-4">1.2.2</span> 散列表</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
散列表是一个 <span class="underline">稀疏数组</span> (总是有空白元素的数组称为稀疏数组)。散列表中的单元叫做 <b>bucket</b> 。
每个 bucket 分为两部分，一个是键的引用，一个是值的引用。
</p>

<p>
Python 会设法保证大概还有三分之一的 bucket 是空的，所以在快要到达这个阈值的时候，
<span class="underline">原有的散列表会被复制到一个更大的空间里面</span> 。
</p>
</div>


<div id="outline-container-orgcd1bb17" class="outline-5">
<h5 id="orgcd1bb17"><span class="section-number-5">1.2.2.1</span> 加盐</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<p>
str, bytes 和 datetime 对象的散列值计算过程中多了 <span class="underline">随机加盐</span> 这一步。
</p>

<p>
所加盐值是进程中一个常量，每次启动解释器都会生成一个不同的盐值。
随机盐值的加入是为了防止 DOS 攻击而采取的一种安全措施。
</p>
</div>
</div>


<div id="outline-container-org9c98648" class="outline-5">
<h5 id="org9c98648"><span class="section-number-5">1.2.2.2</span> 散列表算法</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<div class="org-src-container">
<pre class="src src-plantuml">:计算键的散列值;
:使用散列值最低的几位数字来定位散列表用的一个表元(bucket);
while (表元为空) is (否)
    if (键相等) then (是)
        : 返回表元里的值;
        stop
    else (否)
        : 在散列值中另外再取几位来定位散列表中的另一个表元;
        note right: 散列冲突
    endif
endwhile (是)
    :KeyError;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfdbbbef" class="outline-5">
<h5 id="orgfdbbbef"><span class="section-number-5">1.2.2.3</span> 可散列对象必须满足的条件</h5>
<div class="outline-text-5" id="text-1-2-2-3">
<ol class="org-ol">
<li>支持 <code>hash()</code> 函数，并且通过__hash__方法所得到的散列值是不变的</li>
<li>支持通过__eq__方法来检测相等性</li>
<li>若 <code>a==b</code> 为真，则 <code>hash(a)==hash(b)</code> 也为真</li>
</ol>


<p>
如果一个含有自定义__eq__方法的类处于可变的状态，就不要在这个类中实现__hash__方法，
因为它的实例是不可散列的。
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-orga591478" class="outline-3">
<h3 id="orga591478"><span class="section-number-3">1.3</span> 集合</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<pre class="src src-plantuml">class Container {
    __contains__();
}

class Iterable {
    __iter__();
}

class Sized {
    __len__();
}

class Set {
    isdisjoint();
    __le__();
    __lt__();
    __gt__();
    __ge__();
    __eq__();
    __ne__();
    __and__();
    __or__();
    __sub__();
    __xor__();
}

class MutableSet {
    and();
    discard();
    remove();
    pop();
    clear();
    __ior__();
    __iand__();
    __ixor__();
    __isub__();
}

Container &lt;|-- Set
Iterable &lt;|-- Set
Sized &lt;|-- Set

Set &lt;|-right- MutableSet
</pre>
</div>

<div class="figure">
<p><img src="img/set_vs_mutable.png" alt="set_vs_mutable.png">
</p>
<p><span class="figure-number">Figure 3: </span><code>collections.abc</code> 中的 MutableSet 和它的超类</p>
</div>
</div>

<div id="outline-container-org2114250" class="outline-4">
<h4 id="org2114250"><span class="section-number-4">1.3.1</span> 合集，交集，差集</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>合集： <code>a | b</code></li>
<li>交集： <code>a &amp; b</code></li>
<li>差集： <code>a - b</code></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-org89df4d0" class="outline-3">
<h3 id="org89df4d0"><span class="section-number-3">1.4</span> Unicode</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org96a5f0c" class="outline-4">
<h4 id="org96a5f0c"><span class="section-number-4">1.4.1</span> 字符编码的工作方式</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。
</p>

<p>
<b>Python 的字符串在内存中以 Unicode 表示</b> ，一个字符对应若干个字节。
如果要在网络上传输，或者保存到磁盘上， <b>就需要把字符串变为以字节为单位的 bytes</b> 。
</p>


<img src="https://images2017.cnblogs.com/blog/1209144/201802/1209144-20180202194520750-1805054812.png"/>
</div>
</div>
</div>
</div>



<div id="outline-container-org69ecf28" class="outline-2">
<h2 id="org69ecf28"><span class="section-number-2">2</span> 函数</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org4d24861" class="outline-3">
<h3 id="org4d24861"><span class="section-number-3">2.1</span> 函数参数</h3>
<div class="outline-text-3" id="text-2-1">
<p>
函数参数定义的顺序必须是：必选参数、默认参数、可变参数、仅限关键字参数和关键字参数。
</p>
</div>

<div id="outline-container-org0fe6e12" class="outline-4">
<h4 id="org0fe6e12"><span class="section-number-4">2.1.1</span> 仅限关键字参数</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
仅限关键字参数可以用于限制关键字参数的名字。调用时必须传入参数名，否则将报错。
</p>

<p>
定义函数时若想指定 <b>仅限关键字参数</b> ，要把它们放到前面有 <b>*</b> 的参数后面。
</p>

<p>
如果不想支持数量不定的定位参数，但是想支持仅限关键字参数，在函数签名中放一个 <b>*</b> 即可：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def f(a, *, b):
    return a, b

print(f(1, b=3))
</pre>
</div>

<pre class="example">
(1, 3)

</pre>


<p>
如果函数定义中已经有了一个可变参数，后面跟着的仅限关键字参数就不再需要分隔符 <b>*</b> ：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def f(a, *b, c):
    return (a, b, c)

print(f(1, 2, 3, c=4))
</pre>
</div>

<pre class="example">
(1, (2, 3), 4)

</pre>
</div>
</div>



<div id="outline-container-orgf8d2a77" class="outline-4">
<h4 id="orgf8d2a77"><span class="section-number-4">2.1.2</span> 默认参数的陷阱</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
<b>定义默认参数时，默认参数必须指向不可变对象。</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython">def add_end(L=[]):
    L.append('END')
    return L

print(add_end())
print(add_end())
print(add_end())
</pre>
</div>

<pre class="example">
['END']
['END', 'END']
['END', 'END', 'END']

</pre>


<p>
出现这种现象的原因在于，
函数在定义的时候，默认参数 L 的值就被计算出来了，即 [] ，且该 <span class="underline">引用</span> 保存在函数属性__defaults__中。
每次调用该函数，如果改变了 L 的内容，__defaults__中的内容 <span class="underline">也将随之改变</span> 。
</p>

<p>
可以用 None 这个不可变对象来避免这种陷阱：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def add_end(L=None):
    if L is None:
        L = []
        L.append('END')
        return L
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8dd79b7" class="outline-3">
<h3 id="org8dd79b7"><span class="section-number-3">2.2</span> 函数属性</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<pre class="src src-ipython">class C: pass
obj = C()
def func(): pass
log("函数有而常规对象没有的属性", set(dir(func)) - set(dir(obj)))
</pre>
</div>

<pre class="example">
================================ 函数有而常规对象没有的属性 =================================
{'__call__', '__code__', '__get__', '__name__', '__qualname__', '__defaults__', '__annotations__', '__kwdefaults__', '__globals__', '__closure__'}

</pre>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">类型</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">__annotations__</td>
<td class="org-left">dict</td>
<td class="org-left">参数和返回值注解</td>
</tr>

<tr>
<td class="org-left">__call__</td>
<td class="org-left">method-wrapper</td>
<td class="org-left">可调用对象协议</td>
</tr>

<tr>
<td class="org-left">__closure__</td>
<td class="org-left">tuple</td>
<td class="org-left">闭包，即自由变量的绑定</td>
</tr>

<tr>
<td class="org-left">__code__</td>
<td class="org-left">code</td>
<td class="org-left">编译成字节码的函数元数据和定义体</td>
</tr>

<tr>
<td class="org-left">__defaults__</td>
<td class="org-left">tuple</td>
<td class="org-left">参数默认值</td>
</tr>

<tr>
<td class="org-left">__get__</td>
<td class="org-left">method-wrapper</td>
<td class="org-left">只读描述符协议</td>
</tr>

<tr>
<td class="org-left">__globals__</td>
<td class="org-left">dict</td>
<td class="org-left">函数所在模块中的全局变量</td>
</tr>

<tr>
<td class="org-left">__kwdefaults__</td>
<td class="org-left">dict</td>
<td class="org-left">仅限关键字形式参数默认值</td>
</tr>

<tr>
<td class="org-left">__name__</td>
<td class="org-left">str</td>
<td class="org-left">函数名</td>
</tr>

<tr>
<td class="org-left">__qualname__</td>
<td class="org-left">str</td>
<td class="org-left">函数限定名</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-org9063b76" class="outline-3">
<h3 id="org9063b76"><span class="section-number-3">2.3</span> 局部变量作用域规则</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<pre class="src src-ipython">b = 6
def f(a):
    print(a)
    print(b)
    b = 9

try:
   f(3)
except Exception as e:
    print("Exception:", e)


</pre>
</div>

<pre class="example">
3
Exception: local variable 'b' referenced before assignment

</pre>

<p>
编译函数定义体时，由于在函数中对 b 进行了赋值，因此 Python 判定 b 为局部变量。
当函数被调用时，Python 尝试获取局部变量 b 时，发现 b 没有绑定值，于是报错。
</p>

<p>
这是 Python 的 <span class="underline">设计选择</span> ：不要求声明变量，但是假定 <b>在函数定义体中赋值的变量是局部变量</b> 。
</p>
</div>
</div>



<div id="outline-container-org505fcc1" class="outline-3">
<h3 id="org505fcc1"><span class="section-number-3">2.4</span> 闭包</h3>
<div class="outline-text-3" id="text-2-4">
<p>
闭包指的是延伸了作用域的 <span class="underline">函数</span> ，其中包含函数定义体中引用了，
但是不在定义体中定义的 <b>非全局变量</b> （自由变量）。
</p>

<div class="org-src-container">
<pre class="src src-ipython">def make_averager():
    series = []

    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total/len(series)

    return averager

avg = make_averager()
print(avg(10))
print(avg(11))
print(avg(12))
</pre>
</div>

<pre class="example">
10.0
10.5
11.0

</pre>
</div>

<div id="outline-container-org0667998" class="outline-4">
<h4 id="org0667998"><span class="section-number-4">2.4.1</span> 自由变量定义</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
自由变量指的是未在 local 作用域中绑定的变量。
</p>


<div class="figure">
<p><img src="img/python3_free_variable.png" alt="python3_free_variable.png">
</p>
</div>
</div>
</div>


<div id="outline-container-org898dc72" class="outline-4">
<h4 id="org898dc72"><span class="section-number-4">2.4.2</span> 闭包元信息（__code__, __closure__）</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
局部变量和自由变量的名称保存在__code__属性中：
</p>

<div class="org-src-container">
<pre class="src src-ipython">log("avg.__code__.co_varnames", avg.__code__.co_varnames)
log("avg.__code__.co_freevars", avg.__code__.co_freevars)
</pre>
</div>

<pre class="example">
=========================== avg.__code__.co_varnames ===========================
('new_value', 'total')
=========================== avg.__code__.co_freevars ===========================
('series',)

</pre>


<p>
自由变量的绑定值保存在__closure__属性中：
</p>

<div class="org-src-container">
<pre class="src src-ipython">log("avg.__closure__", avg.__closure__)
</pre>
</div>

<pre class="example">
=============================== avg.__closure__ ================================
(&lt;cell at 0x111aff978: list object at 0x111954dc8&gt;,)

</pre>

<p>
<code>__closure__</code> 中的各个元素对应于 <code>__code__.co_freevars</code> 中的一个名称。
这些元素是 cell 对象，该对象的 cell_contents 属性保存着真正的值：
</p>

<div class="org-src-container">
<pre class="src src-ipython">log("avg.__closure__[0].cell_contents", avg.__closure__[0].cell_contents)
</pre>
</div>

<pre class="example">
======================= avg.__closure__[0].cell_contents =======================
[10, 11, 12]

</pre>
</div>
</div>



<div id="outline-container-org7cc4b93" class="outline-4">
<h4 id="org7cc4b93"><span class="section-number-4">2.4.3</span> nonlocal</h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">
<pre class="src src-ipython">def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        count += 1
        total += new_value
        return total / count

    return averager

avg = make_averager()
try:
    print(avg(10))
except Exception as e:
    print(e)

</pre>
</div>

<pre class="example">
local variable 'count' referenced before assignment

</pre>

<p>
造成上述错误的原因在于，如果 <span class="underline">尝试重新绑定</span> ，例如 <code>count = count + 1</code> ，
其实会 <span class="underline">隐式创建局部变量</span> count ，从而导致错误。
同时，这样一来， count 就不可能是自由变量了，不会保存在闭包中。
</p>


<p>
Python 3 引入了 nonlocal 声明，它的作用是 <span class="underline">把变量标记为自由变量</span> ：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count

    return averager

avg = make_averager()
try:
    print(avg(10))
except Exception as e:
    print(e)
</pre>
</div>

<pre class="example">
10.0

</pre>
</div>
</div>


<div id="outline-container-orgc837b5f" class="outline-4">
<h4 id="orgc837b5f"><span class="section-number-4">2.4.4</span> 闭包的陷阱</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
<b>闭包中不要引用任何可能会变化的变量</b> ：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

print(f1(), f2(), f3())

</pre>
</div>

<pre class="example">
9 9 9

</pre>

<p>
如果一定要引用会变化的变量，可以再创建一个函数：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i))
    return fs

f1, f2, f3 = count()
print(f1(), f2(), f3())
</pre>
</div>

<pre class="example">
1 4 9

</pre>
</div>
</div>
</div>


<div id="outline-container-org76045ae" class="outline-3">
<h3 id="org76045ae"><span class="section-number-3">2.5</span> 参数化装饰器</h3>
<div class="outline-text-3" id="text-2-5">
<p>
参数化装饰器本质上是一个 <span class="underline">装饰器工厂函数</span> ：把参数化传给它，返回一个装饰器，
然后再把这个装饰器应用到要装饰的函数上：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def decorator(*args, **kwargs):
    def decorate(func):
        pass
    return decorate
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org032fc0a" class="outline-2">
<h2 id="org032fc0a"><span class="section-number-2">3</span> 面向对象编程</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc84d5d6" class="outline-3">
<h3 id="orgc84d5d6"><span class="section-number-3">3.1</span> 对象的比较(== 与 is)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>==</code> 比较两个对象的值 (对象中保存的数据)，而 <code>is</code> 比较对象的标识。
</p>

<p>
<code>a==b</code> 等同于 <code>a.__eq__(b)</code> 。
</p>

<p>
继承自 object 的__eq__方法比较两个对象的 ID ，结果与 is 一样。
</p>

<p>
但多数内置类型使用更有意义的方式覆盖了__eq__方法，会考虑对象属性的值。
</p>
</div>
</div>


<div id="outline-container-orgfb49d49" class="outline-3">
<h3 id="orgfb49d49"><span class="section-number-3">3.2</span> 对象的深复制与浅复制</h3>
<div class="outline-text-3" id="text-3-2">
<p>
构造方法或 <code>[:]</code> 做的是浅复制，即复制了 <span class="underline">最外层</span> 容器，
副本中的元素是源容器中元素的引用。
</p>

<p>
copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制：
</p>

<div class="org-src-container">
<pre class="src src-ipython">import copy

class A:
    def __init__(self):
        self.container = []


a = A()
a.container.append(1)
a_copy = copy.copy(a)
a_deepcopy = copy.deepcopy(a)
a.container.append(2)
log("a_copy.container", a_copy.container)
log("a_deepcopy.container", a_deepcopy.container)

</pre>
</div>

<pre class="example">
=============================== a_copy.container ===============================
[1, 2]
============================= a_deepcopy.container =============================
[1]

</pre>
</div>
</div>





<div id="outline-container-org2c7a1b6" class="outline-3">
<h3 id="org2c7a1b6"><span class="section-number-3">3.3</span> 垃圾回收</h3>
<div class="outline-text-3" id="text-3-3">
<p>
如果两个对象相互引用，当它们的引用 <span class="underline">只存在两者之间时</span> ，垃圾回收程序会判断它们都无法获取，
进而把它们 <span class="underline">都销毁</span> 。
</p>
</div>


<div id="outline-container-org8a8b4fe" class="outline-4">
<h4 id="org8a8b4fe"><span class="section-number-4">3.3.1</span> 监控对象回收(weakref.finalize)</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-ipython">import weakref
s = {1, 2, 3}
ender = weakref.finalize(s, lambda: print("Gone with the wind ..."))
print(ender.alive)
del s
</pre>
</div>

<pre class="example">
True
Gone with the wind ...

</pre>
</div>
</div>
</div>




<div id="outline-container-orgfef3fe1" class="outline-3">
<h3 id="orgfef3fe1"><span class="section-number-3">3.4</span> 弱引用</h3>
<div class="outline-text-3" id="text-3-4">
<p>
弱引用经常用在缓存中，即需要引用对象，但又不让对象存在的时间超过所需时间。
</p>
</div>

<div id="outline-container-orga453d60" class="outline-4">
<h4 id="orga453d60"><span class="section-number-4">3.4.1</span> 创建弱引用</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
弱引用是可调用对象，如果对象存在，调用弱引用可以获取对象，否则返回 None :
</p>

<div class="org-src-container">
<pre class="src src-ipython">import weakref
a = {0, 1}
wref = weakref.ref(a)
print(wref())
</pre>
</div>

<pre class="example">
{0, 1}

</pre>
</div>
</div>


<div id="outline-container-orgc6c6312" class="outline-4">
<h4 id="orgc6c6312"><span class="section-number-4">3.4.2</span> weakref.WeakValueDictionary</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
WeakValueDictionary 类实现的是一种可变映射， <span class="underline">里面的值是对象的弱引用</span> 。
被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。
因此，WeakValueDictionary 经常用于缓存。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import weakref

class Cheese:

    def __init__(self, kind):
        self.kind = kind

stock = weakref.WeakValueDictionary()
catalog = [Cheese('Read Leicester'), Cheese('Tilsit'), Cheese('Brie'), Cheese('Parmesan')]
for cheese in catalog:
    stock[cheese.kind] = cheese

print(sorted(stock.keys()))

del catalog
del cheese
print(sorted(stock.keys()))
</pre>
</div>

<pre class="example">
['Brie', 'Parmesan', 'Read Leicester', 'Tilsit']
[]

</pre>
</div>
</div>


<div id="outline-container-org00bed80" class="outline-4">
<h4 id="org00bed80"><span class="section-number-4">3.4.3</span> weakref.WeakKeyDictionary</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
与 WeakValueDictionary 对应的是 WeakKeyDictionary ，后者的键是弱引用。
</p>
</div>
</div>


<div id="outline-container-org72263c8" class="outline-4">
<h4 id="org72263c8"><span class="section-number-4">3.4.4</span> weakref.WeakSet</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
保存元素弱引用的集合类。元素没有强引用时，集合会把它删除。
</p>

<p>
如果 <span class="underline">一个类需要知道所有实例</span> ，一种好的方案是创建一个 WeakSet 类型的类属性，用以保存实例的引用。
</p>
</div>
</div>


<div id="outline-container-org9b71364" class="outline-4">
<h4 id="org9b71364"><span class="section-number-4">3.4.5</span> 弱引用的局限</h4>
<div class="outline-text-4" id="text-3-4-5">
<p>
不是每个 Python 对象都可以作为弱引用的目标 (或称所指对象) 。
</p>

<p>
list 和 dict 实例不能作为所指对象， <span class="underline">但是它们的子类可以</span> 。
</p>

<p>
int 和 tuple 实例不能作为弱引用的目标，甚至它们的 <span class="underline">子类也不行</span> 。
</p>

<p>
这些局限是内部优化导致的结果。
</p>
</div>
</div>


<div id="outline-container-org668af79" class="outline-4">
<h4 id="org668af79"><span class="section-number-4">3.4.6</span> 对象支持弱引用(__weakref__属性)</h4>
<div class="outline-text-4" id="text-3-4-6">
<p>
为了让对象支持弱引用，必须要有 <code>__weakref__</code> 这个属性，用户定义的类中默认就有这个属性。
</p>

<p>
如果类中定义了 <code>__slots__</code> 属性，而且想把实例作为弱引用的目标，
那么必须把 <code>__weakref__</code> 添加到 <code>__slots__</code> 中。
</p>
</div>
</div>
</div>




<div id="outline-container-org37b5431" class="outline-3">
<h3 id="org37b5431"><span class="section-number-3">3.5</span> 抽象类</h3>
<div class="outline-text-3" id="text-3-5">
</div>
<div id="outline-container-orgc55e26e" class="outline-4">
<h4 id="orgc55e26e"><span class="section-number-4">3.5.1</span> 内置抽象基类</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
大多数内置抽象基类在 <code>collection.abc</code>, <code>numbers</code> 和 <code>io</code> 模块中定义。
</p>

<p>
<code>collection.abc</code> 中的抽象基类最常用，其次是 <code>numbers</code> 。
</p>


<div class="figure">
<p><img src="img/abc_uml.png" alt="abc_uml.png">
</p>
<p><span class="figure-number">Figure 5: </span><code>collections.abc</code> 模块中各个抽象基类的 UML 类图</p>
</div>
</div>
</div>



<div id="outline-container-orgff83259" class="outline-4">
<h4 id="orgff83259"><span class="section-number-4">3.5.2</span> 自定义抽象基类</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
抽象基类中的抽象方法可以有实现代码。
</p>

<p>
即使实现了， <b>子类也必须覆盖抽象方法</b> ，但是在子类中可以使用 <code>super()</code> 函数调用抽象方法。
</p>

<p>
与其他装饰器一起使用时， <code>@abstractmethod</code> 应放在 <span class="underline">最里层</span> ，
即 <code>@abstractmethod</code> 与 <code>def</code> 之间不能有其他装饰器。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from abc import ABC, abstractmethod

class Pet(ABC):
    @classmethod
    def from_name(cls, name):
        for s_cls in cls.__subclasses__():  # 注意 __subclasses__ 的用法
            if name == s_cls.__name__.lower():
                return s_cls()

    @abstractmethod
    def hello(self):
        pass

class Dog(Pet):

    def hello(self):
        print("WonWonWon")

Pet.from_name("dog").hello()
</pre>
</div>

<pre class="example">
WonWonWon

</pre>
</div>
</div>


<div id="outline-container-org5909b49" class="outline-4">
<h4 id="org5909b49"><span class="section-number-4">3.5.3</span> 虚拟子类</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
虚拟子类的作用在于：即使不通过继承，也可以把一个类注册为抽象基类的子类。
</p>

<p>
当注册了抽象子类，必须保证所注册的类忠实地实现了抽象基类定义的接口（虽然 Python 并不在注册时做检查），
否则在运行时可能会抛异常。
</p>


<p>
注册虚拟子类的方式是在抽象基类上调用 <code>register</code> 方法，
<code>register</code> 方法通常作为普通函数调用，也可以作为装饰器使用。
</p>

<p>
这么做之后，注册的类会变成抽象基类的虚拟子类，而且 <code>issubclass</code> 和 <code>isinstance</code> 都能识别，
<b>但是注册的类不会从抽象基类中继承任何方法或属性</b> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">@Pet.register
class Cat:
    pass

class Bird(list):
    pass

Pet.register(Bird)

log("issubclass(Cat, Pet)", issubclass(Cat, Pet))
log("isinstance(Bird(), Pet)", isinstance(Bird(), Pet))
log("Bird.__mro__", Bird.__mro__)
</pre>
</div>

<pre class="example">
==== issubclass(Cat, Pet) ====
True
== isinstance(Bird(), Pet) ===
True
======== Bird.__mro__ ========
(&lt;class '__main__.Bird'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)

</pre>

<p>
虚拟子类的 <code>__mro__</code> 属性中没有虚拟基类，说明了虚拟子类并没有从虚拟基类中继承任何方法。
</p>
</div>


<div id="outline-container-org7239509" class="outline-5">
<h5 id="org7239509"><span class="section-number-5">3.5.3.1</span> __subclasses__</h5>
<div class="outline-text-5" id="text-3-5-3-1">
<p>
该方法返回类的直接子类列表， <span class="underline">不含虚拟子类</span> 。
</p>
</div>
</div>


<div id="outline-container-org87a7e04" class="outline-5">
<h5 id="org87a7e04"><span class="section-number-5">3.5.3.2</span> _abc_registry</h5>
<div class="outline-text-5" id="text-3-5-3-2">
<p>
只有抽象基类才有这个 <span class="underline">属性</span> ，其值是 WeakSet 对象，即抽象基类注册的虚拟子类的弱引用。
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-orgbdc198b" class="outline-3">
<h3 id="orgbdc198b"><span class="section-number-3">3.6</span> 继承</h3>
<div class="outline-text-3" id="text-3-6">
<p>
直接子类化内置类型 (如 <code>dict</code>, <code>list</code> 或 <code>str</code>) 容易出错，
因为内置类型的方法通常会忽略用户覆盖的方法。(<a href="#org94cb7d1">例子</a>)
</p>

<p>
<b>不要子类化内置类型</b> ，用户自己定义的类应该继承 <code>collection</code> 模块中的类，
如 <code>UserDict</code>, <code>UserList</code> 和 <code>UserString</code> ，这些类 <b>做了特殊设计</b> ，易于扩展。
</p>
</div>
</div>



<div id="outline-container-org2d456c5" class="outline-3">
<h3 id="org2d456c5"><span class="section-number-3">3.7</span> classmethod / staticmethod 装饰器</h3>
<div class="outline-text-3" id="text-3-7">
<p>
<code>classmethod=</code> 最常见的用途是 <span class="underline">定义备选构造方法</span> 。
</p>

<p>
<code>staticmethod</code> 就是 <span class="underline">普通的函数</span> ，只是碰巧在类的定义体中。
该装饰器 <span class="underline">并不是很重要</span> ，因为可以在同一模块中该类的前后定义函数即可达到同样的效果。
</p>
</div>
</div>


<div id="outline-container-orga6059a9" class="outline-3">
<h3 id="orga6059a9"><span class="section-number-3">3.8</span> __slots__属性</h3>
<div class="outline-text-3" id="text-3-8">
<p>
默认情况下，Python 在各个实例中名为 <code>__dict__</code> 的字典里存储实例属性。
</p>

<p>
为了使用底层的散列表提升访问速度，字典会消耗大量内存。
如果要处理数百万个属性不多的实例，通过 <code>__slots__</code> 类属性，能节省大量内存。
<b>其本质是让解释器在元组中存储实例属性，而不是使用字典。</b>
</p>

<p>
继承自超类的 <code>__slots__</code> 属性 <b>没有效果</b> ，Python 只会使用 <b>各个类中自己定义</b> 的 <code>__slots__</code> 属性。
</p>

<p>
不要使用 <code>__slots__</code> 禁止类的用户新增实例属性，使用 <code>__slots__</code> 是 <b>为了优化，不是为了约束。</b>
</p>
</div>


<div id="outline-container-orgbcd99d8" class="outline-4">
<h4 id="orgbcd99d8"><span class="section-number-4">3.8.1</span> 节省的内存也可能被再次吃掉</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
如果把 <code>__dict__</code> 这个名称添加到 <code>__slots__</code> 中，
实例会在元祖中保存各个实例的属性，同时还支持动态创建属性，但这样就失去了节省内存的功效。
</p>
</div>
</div>
</div>





<div id="outline-container-org2da6513" class="outline-3">
<h3 id="org2da6513"><span class="section-number-3">3.9</span> __getattr__方法</h3>
<div class="outline-text-3" id="text-3-9">
<p>
对于 <code>my_obj.x</code> 表达式，Python 会检查该实例有没有名为 <code>x</code> 的属性，如果没有，到类 <code>my_obj.__class__</code> 中查找；
如果仍然没找到，则顺着继承树继续查找。
</p>

<p>
如果依旧找不到，则调用 <code>my_obj</code> 所属类中定义的 <code>__getattr__</code> 方法，传入 <code>self</code> 和属性名称的字符串形式 <code>'x'</code> 。
</p>

<p>
多数时候，如果实现了 <code>__getattr__</code> 方法，那么也要定义 <code>__setattr__</code> 方法，以防对象的行为不一致。
</p>
</div>
</div>
</div>










<div id="outline-container-org772bfa9" class="outline-2">
<h2 id="org772bfa9"><span class="section-number-2">4</span> 流程控制</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgc86db83" class="outline-3">
<h3 id="orgc86db83"><span class="section-number-3">4.1</span> 内置的 iter 函数</h3>
<div class="outline-text-3" id="text-4-1">
<p>
当需要迭代对象 <code>x</code> 时，会自动调用 <code>iter(x)</code> 。内置的 <code>iter</code> 函数有以下作用：
</p>

<ol class="org-ol">
<li>检查对象是否实现了 <code>__iter__</code> 方法，如果实现了就调用它，获取一个迭代器。</li>
<li>如果没有实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法，Python 会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li>
<li>如果尝试失败，则抛出 <code>TypeError</code> 异常。</li>
</ol>
</div>
</div>


<div id="outline-container-org9bd123e" class="outline-3">
<h3 id="org9bd123e"><span class="section-number-3">4.2</span> 生成器</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<b>生成器保存的是算法</b> ，每次调用 <code>next(g)</code> ，就计算出 <code>g</code> 的下一个元素的值。
</p>

<p>
直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 异常。
</p>

<p>
当 Python 函数定义体中有 yield 关键字，该函数就是生成器函数。
</p>

<p>
调用生成器函数时，会返回一个生成器对象。也就是说生成器函数是生成器工厂。
</p>

<p>
<b>生成器表达式本质上是生成器函数的语法糖。</b>
</p>
</div>
</div>



<div id="outline-container-orgaf9e9a5" class="outline-3">
<h3 id="orgaf9e9a5"><span class="section-number-3">4.3</span> for/else, while/else, try/else</h3>
<div class="outline-text-3" id="text-4-3">
<p>
在所有情况下，如果因为异常或者 return，break 或 continue 语句导致控制权跳到了块之外，else 子句也会被跳过。
</p>

<ul class="org-ul">
<li><p>
for/else
</p>

<p>
仅当 for 循环运行完毕时 (即 for 循环没有被 break 语句中止) 才运行 else 块。
</p></li>

<li><p>
while/else
</p>

<p>
仅当 while 循环因为条件为假值而退出时 (即 while 循环没有被 break 语句中止) 才运行 else 块。
</p></li>

<li><p>
try/else
</p>

<p>
仅当 try 块中没有异常抛出时才运行 else 块， <b>else 子句抛出的异常不会由前面的 except 子句处理。</b>
</p></li>
</ul>
</div>
</div>



<div id="outline-container-orgf60ffc4" class="outline-3">
<h3 id="orgf60ffc4"><span class="section-number-3">4.4</span> 上下文管理协议(with)</h3>
<div class="outline-text-3" id="text-4-4">
<p>
<span class="underline">with 语句的目的是简化 try/finally 模式</span> 。
</p>

<p>
上下文管理器协议包含__enter__和__exit__两个方法:
</p>

<ul class="org-ul">
<li>with 语句开始运行时，会在上下文管理器对象上调用__enter__方法。</li>
<li>with 语句运行结束后，会在上下文管理器对象上调用__exit__方法，以此扮演 finally 子句的角色。</li>
</ul>

<p>
__exit__方法如果返回 True 之外的值 (包括 None) ，则 with 块中的任何异常都会向上冒泡。
(返回 True ，即告诉解释器，异常已经处理了)
</p>


<p>
<a href="#orgcc21107">不要自己造轮子</a>
</p>
</div>
</div>


<div id="outline-container-orgcd4d141" class="outline-3">
<h3 id="orgcd4d141"><span class="section-number-3">4.5</span> 协程</h3>
<div class="outline-text-3" id="text-4-5">
<p>
协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。
</p>

<p>
协程中的关键字 yield 可以视作控制流程的方式。
</p>
</div>

<div id="outline-container-org26bf348" class="outline-4">
<h4 id="org26bf348"><span class="section-number-4">4.5.1</span> 协程的状态</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
可以使用 <code>inspect.getgeneratorstate()</code> 获取协程四个状态中的一个：
</p>

<ol class="org-ol">
<li>GEN_CREATED：等待开始执行</li>
<li>GEN_RUNNING：正在执行（只有在多线程应用中才能看到这个状态）</li>
<li>GEN_SUSPENDED：在 yield 表达式处暂停</li>
<li>GEN_CLOSED：执行结束</li>
</ol>
</div>
</div>


<div id="outline-container-org014e03e" class="outline-4">
<h4 id="org014e03e"><span class="section-number-4">4.5.2</span> 执行过程举例</h4>
<div class="outline-text-4" id="text-4-5-2">

<div class="figure">
<p><img src="img/py3_coroutine.png" alt="py3_coroutine.png">
</p>
</div>

<ol class="org-ol">
<li>调用 <code>next(my_coro2)</code> ，打印第一个消息，然后执行 yield a ，产出数字 14</li>
<li>调用 <code>my_coro2.send(28)</code> ，把 28 赋值给 b ，打印第二个消息，然后执行 <code>yield a + b</code> ，产出 42</li>
<li>调用 <code>my_coro2.send(99)</code> ，把 99 赋值给 c ，打印第三个消息，协程终止</li>
</ol>

<p>
注意，各个阶段都在 yield 表达式中结束，而且下一个阶段都从那一行代码开始，然后再把 yield 表达式的值赋给变量。
</p>
</div>
</div>


<div id="outline-container-org010d4a9" class="outline-4">
<h4 id="org010d4a9"><span class="section-number-4">4.5.3</span> 预激(prime)</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
如果不预激，则协程没什么用，即调用 <code>send()</code> 之前，一定要先调用 <code>next()</code> 。
</p>

<p>
使用 yield from 调用协程时，会 <span class="underline">自动预激</span> 。
</p>

<p>
标准库里的 asyncio.coroutine 装饰器不会预激协程，兼容 yield from 语法。
</p>
</div>
</div>


<div id="outline-container-orgfeb04bc" class="outline-4">
<h4 id="orgfeb04bc"><span class="section-number-4">4.5.4</span> 协程的终止和异常处理</h4>
<div class="outline-text-4" id="text-4-5-4">
<p>
协程中未处理的异常会向上冒泡，传给调用协程的对象，未处理的异常会导致协程终止。
</p>
</div>


<div id="outline-container-org9f21181" class="outline-5">
<h5 id="org9f21181"><span class="section-number-5">4.5.4.1</span> generator.throw()</h5>
<div class="outline-text-5" id="text-4-5-4-1">
<p>
<code>generator.throw(exc_type[, exc_value[, traceback]])</code>
</p>

<p>
该方法会导致生成器在暂停的 yield 表达式处抛出指定的异常。
</p>

<p>
如果生成器内部处理了该异常，代码会向前执行到下一个 yield 表达式处， <span class="underline">而产出的值会成为该方法的返回值</span> 。
</p>

<p>
如果生成器内部没有处理这个异常，异常会向上冒泡，传到调用方的上下文中。
</p>
</div>
</div>


<div id="outline-container-orgbb9adde" class="outline-5">
<h5 id="orgbb9adde"><span class="section-number-5">4.5.4.2</span> generator.close()</h5>
<div class="outline-text-5" id="text-4-5-4-2">
<p>
该方法使得生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。
</p>

<p>
如果生成器内部没有处理这个异常，调用方不会报错。
</p>

<p>
捕获到 GeneratorExit 异常后，生成器 <span class="underline">不能再产出值</span> ，否则解释器会抛出 RuntimeError 异常。
</p>

<p>
如果不管协程如何结束都需要做清理工作，需要把协程定义体中相关的代码放入 <code>try/finally</code> 块中。
</p>

<p>
GC 时会调用 <code>close()</code> (<a href="https://stackoverflow.com/questions/56062909/try-finally-in-python-3-generator/56063376?noredirect=1#comment98768195_56063376">try-finally in Python 3 generator</a>) 。
</p>
</div>
</div>
</div>


<div id="outline-container-org971fd43" class="outline-4">
<h4 id="org971fd43"><span class="section-number-4">4.5.5</span> yield from</h4>
<div class="outline-text-4" id="text-4-5-5">
<p>
<code>yield from</code> 主要功能是创建 <span class="underline">双向通道</span> ，将内层生成器直接与外层生成器的 <b>调用方</b> 联系起来。
这样两者可以直接发送和产出值，还可以直接传入异常对象。
</p>

<p>
即当一个生成器函数需要产出另一个生成器生成的值，可以使用这个语法：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def chain(*iterables):
    for i in iterables:
        yield from i

print(list(chain('ABC', range(3))))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 0, 1, 2]

</pre>


<p>
<span class="underline">yield from 结构通常会和 asyncio 模块结合起来实现异步编程。</span>
</p>
</div>



<div id="outline-container-org7d55aee" class="outline-5">
<h5 id="org7d55aee"><span class="section-number-5">4.5.5.1</span> yield from 工作原理</h5>
<div class="outline-text-5" id="text-4-5-5-1">

<div class="figure">
<p><img src="img/py3_yield.png" alt="py3_yield.png">
</p>
</div>

<p>
委派生成器相当于 <span class="underline">管道</span> ，可以把任意数量的委派生成器连接在一起，
这个管道最终要以一个只使用 yield 表达式的简单生成器结束 (也能以任何可迭代对象结束) 。
任何 yield from 链都必须 <span class="underline">由客户驱动</span> ，即在最外层委派生成器上调用 <code>next()</code>, <code>send()</code> 方法。
（也可以隐式调用，如使用 for 循环）
</p>


<p>
<code>yield from x</code> 表达式对 x 对象所做的第一件事就是调用 <code>iter(x)</code> ，从中获取迭代器。
因此，只要实现了 <code>__next__</code> 方法， yield from 就能处理得了。
不过，引入 yield from 结构的主要目的是为了支持实现了__next__, send, close 和 throw 方法的生成器。
</p>
</div>
</div>


<div id="outline-container-orgaa5634d" class="outline-5">
<h5 id="orgaa5634d"><span class="section-number-5">4.5.5.2</span> yield from 对异常和终止的处理</h5>
<div class="outline-text-5" id="text-4-5-5-2">
<ul class="org-ul">
<li>传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 <code>throw()</code> 方法。
如果调用 <code>throw()</code> 方法抛出 StopIteration 异常，委派生成器恢复运行。
StopIteration 之外的异常会向上冒泡，传给委派生成器。（即 <span class="underline">委派生成器若提前结束迭代，则子生成器也会自动结束迭代</span> ）</li>
<li>如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用 <code>close()</code> 方法，
则会在子生成器上调用 <code>close()</code> 方法 (如果它有的话) 。
如果子生成器调用 <code>close()</code> 方法导致异常抛出，则异常会向上冒泡，传给委派生成器，
如果没有异常抛出，则委派生成器会抛出 GeneratorExit 异常。（即 <span class="underline">关闭委派生成器也将自动关闭子生成器</span> ）</li>
</ul>
</div>
</div>


<div id="outline-container-orgd7bf2bc" class="outline-5">
<h5 id="orgd7bf2bc"><span class="section-number-5">4.5.5.3</span> yield from 表达式的值</h5>
<div class="outline-text-5" id="text-4-5-5-3">
<p>
<code>yield from subgen</code> 结构会在内部自动捕获 StopIteration 异常。
subgen 通过 return 关键字返回的值会赋给 StopIteration 异常的 value 属性，该值最终成为 yield from 表达式的值。
</p>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-org35f1b91" class="outline-2">
<h2 id="org35f1b91"><span class="section-number-2">5</span> 并发编程</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org28bdaaa" class="outline-3">
<h3 id="org28bdaaa"><span class="section-number-3">5.1</span> 全局解释锁 (GIL)</h3>
<div class="outline-text-3" id="text-5-1">
<p>
CPython 解释器本身不是线程安全的，因此有全局解释器锁 (GIL) ，
一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程不能同时使用多个 CPU 。
</p>
</div>

<div id="outline-container-orga6ffae1" class="outline-4">
<h4 id="orga6ffae1"><span class="section-number-4">5.1.1</span> I/O 密集型操作</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL 。
这意味着在 Python 语言这个层次上可以使用多线程，I/O 密集型的程序能从中受益。
( <code>time.sleep()</code> 函数也会释放 GIL)
</p>
</div>
</div>


<div id="outline-container-orgf32ff4e" class="outline-4">
<h4 id="orgf32ff4e"><span class="section-number-4">5.1.2</span> CPU 密集型操作</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
使用 ProcessPoolExecutor 类把工作分配给多个进程处理可以实现真正的并行运算。
</p>

<p>
因此，如果需要做 CPU 密集型处理，可以使用它绕开 GIL ，从而利用所有可用的 CPU 。
(多个 Python 进程有各自独立的 GIL 锁，互不影响)
</p>
</div>
</div>
</div>


<div id="outline-container-org5c4fb3d" class="outline-3">
<h3 id="org5c4fb3d"><span class="section-number-3">5.2</span> 基于 concurrent.futures 模块的并发编程</h3>
<div class="outline-text-3" id="text-5-2">
<p>
concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPoolExecutor 类，
这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。
</p>

<p>
通常情况下 future 对象不应由用户创建，而是由并发框架 (concurrent.futures 或 asyncio) 来实例化。
</p>
</div>

<div id="outline-container-org34fc7e0" class="outline-4">
<h4 id="org34fc7e0"><span class="section-number-4">5.2.1</span> Executor.map(func, *iterables, timeout=None, chunksize=1)</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
chunksize 只对 ProcessPoolExecutor 有用，用于切分 iterables ，提高运行效率。
因为 future 结果的返回涉及到 IPC ，如果每个进程每次消耗 iterables 中的一个数据，整个过程涉及多个 IPC ，这样效率不高；
但如果对 iterables 进行切分，N 个 数据同时交给一个进程进行处理，运算结果通过一个 IPC 一并返回，这样就可以提升效率。
</p>

<p>
返回值是一个迭代器，迭代器的__next__方法调用各个 future 对象的 result 方法，得到各个 future 的结果。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from concurrent.futures import ThreadPoolExecutor
import time

def sleep_and_double(value):
    time.sleep(value)
    return value * 2

with ThreadPoolExecutor(max_workers=4) as executor:
    time0 =time.time()
    values = executor.map(sleep_and_double, [3, 2, 1])
    time_delta = time.time() - time0
    print("time consumed0: ", time_delta)
    print(values)
    time0 =time.time()
    print([v for v in values])
    time_delta = time.time() - time0
    print("time consumed1: ", time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  0.009264230728149414
&lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x110912e60&gt;
[6, 4, 2]
time consumed1:  2.9983181953430176

</pre>
</div>
</div>


<div id="outline-container-org7e480db" class="outline-4">
<h4 id="org7e480db"><span class="section-number-4">5.2.2</span> Executor.sumit(fn, *args, **kwargs)</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-ipython">with ThreadPoolExecutor(max_workers=1) as executor:
    time0 = time.time()
    future = executor.submit(sleep_and_double, 3)
    time_delta = time.time() - time0
    print("time consumed0: ", time_delta)
    time0 = time.time()
    print(future.result())
    time_delta = time.time() - time0
    print("time consumed1: ", time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  0.00031113624572753906
6
time consumed1:  3.004795789718628

</pre>
</div>
</div>


<div id="outline-container-org3c6c1b1" class="outline-4">
<h4 id="org3c6c1b1"><span class="section-number-4">5.2.3</span> concurrent.futures.as_completed(fs, timeout=None)</h4>
<div class="outline-text-4" id="text-5-2-3">
<p>
如果调用 <code>finished = as_completed(fs, timeout)</code> 后，经过 timeout 时间后仍然无法获取 <code>next(finishes).result()</code> 的值，
则抛出 concurrent.futures.TimeoutError 异常。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from concurrent import futures
fs = []

with ThreadPoolExecutor(max_workers=5) as executor:
    for i in [5, 4, 3, 2, 1]:
        f = executor.submit(sleep_and_double, i)
        fs.append(f)
    time0 = time.time()
    finishes = futures.as_completed(fs)
    time_delta = time.time() - time0
    print("time consumed0: ", time_delta)
    time0 = time.time()
    print([f.result() for f in finishes])
    time_delta = time.time() - time0
    print("time consumed1: ", time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  2.86102294921875e-06
[2, 4, 6, 8, 10]
time consumed1:  4.999896287918091

</pre>

<p>
fs 可以是一个字典，把各个 future 对象映射到其他有用的数据上，
这样尽管 future 生成的结果顺序可能乱了，依然便于使用结果做后续的处理：
</p>

<div class="org-src-container">
<pre class="src src-ipython">from concurrent import futures
from concurrent.futures import ThreadPoolExecutor
import time
fs = {}

def sleep_and_double(value):
    time.sleep(value)
    return value * 2

with ThreadPoolExecutor(max_workers=5) as executor:
    for i in [5, 4, 3, 2, 1]:
        f = executor.submit(sleep_and_double, i)
        fs[f] = i
    time0 = time.time()
    finishes = futures.as_completed(fs)
    time_delta = time.time() - time0
    print("time consumed0: ", time_delta)
    time0 = time.time()
    for f in finishes:
        print("#{} =&gt; {}".format(fs[f], f.result()))
    time_delta = time.time() - time0
    print("time consumed1: ", time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  7.867813110351562e-06
#1 =&gt; 2
#2 =&gt; 4
#3 =&gt; 6
#4 =&gt; 8
#5 =&gt; 10
time consumed1:  5.001190900802612

</pre>
</div>
</div>
</div>



<div id="outline-container-org5a16070" class="outline-3">
<h3 id="org5a16070"><span class="section-number-3">5.3</span> 基于 asyncio 包的并发编程</h3>
<div class="outline-text-3" id="text-5-3">
<ol class="org-ol">
<li>asyncio 包使用的协程是有严格定义的，因此 <span class="underline">适合 asyncio API 的协程在定义体中必须使用 yield from ，而不能用 yield 。</span></li>
<li>适合 asyncio 的协程必须由调用方驱动，由调用方通过 <code>yield from coro_or_future</code> 驱动；或者把协程传给 asyncio 包中的某个函数（如 <code>asyncio.async()</code> ），从而 <span class="underline">驱动协程</span> 。</li>
<li>@asyncio.coroutine 装饰器应该始终应用在协程上。</li>
</ol>
</div>


<div id="outline-container-org589465b" class="outline-4">
<h4 id="org589465b"><span class="section-number-4">5.3.1</span> 基本思想 (面向事件编程)</h4>
<div class="outline-text-4" id="text-5-3-1">
<ol class="org-ol">
<li>在一个单线程中使用主循环依次激活队列里的协程</li>
<li>各个协程向前执行几步，然后把控制权让给主循环</li>
<li>主循环再激活队列里的下一个协程</li>
</ol>

<p>
编写基于 asyncio 的程序需注意下述细节：
</p>

<ul class="org-ul">
<li>编写的协程链始终通过把最外层委派生成器传给 asyncio 包中的某个函数驱动，例如 <code>loop.run_until_complete()</code> 。即我们的代码不通过调用 <code>next()</code> 函数或 <code>send()</code> 方法驱动协程。驱动由 asyncio 包实现的事件循环去做。</li>

<li>编写的协程链最终通过 <code>yield from</code> 把职责委托给 asyncio 包中的某个协程函数，如 <code>yeild from asyncio.sleep()</code> ，或者其他库中实现高层协议的协程，如 <code>response = yield from aiohttp.request('GET', url)</code> 。也就是说， <span class="underline">最内层的子生成器是库中真正执行 I/O 操作的函数，而不是我们自己编写的函数。</span></li>
</ul>

<p>
概括起来就是：使用 asyncio 包时，我们编写的代码中包含委派生成器，
而生成器最终把职责 <b>委托</b> 给 asyncio 包或第三方库中的协程。
这种处理方式相当于 <span class="underline">架起了管道</span> ，让 asyncio 事件循环驱动执行低层异步 I/O 操作的库函数。
</p>
</div>
</div>




<div id="outline-container-orgbdb2b36" class="outline-4">
<h4 id="orgbdb2b36"><span class="section-number-4">5.3.2</span> @asyncio.coroutine 装饰器（或 async 关键字）</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
交给 asyncio 处理的协程要使用 <code>@asyncio.coroutine</code> 装饰，这虽不是强制要求，但是建议这么做。
</p>

<p>
因为这样能在一众普通函数中把协程凸显出来，也有助于调试：
如果还没从协程中产出值，协程就被垃圾回收了，可以发出警告。
</p>

<p>
也可以使用 <b>async</b> 关键字。
</p>
</div>
</div>


<div id="outline-container-orgd83e745" class="outline-4">
<h4 id="orgd83e745"><span class="section-number-4">5.3.3</span> asyncio.Future</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
asyncio.Future 类的目的是与 yield from 一起使用，通常 <span class="underline">不需要</span> 使用以下方法：
</p>

<ul class="org-ul">
<li><p>
asyncio.Future.add_done_callback()
</p>

<p>
因为可以直接把在 Future 运行结束后执行的操作放在 yield from 表达式后面。
</p></li>

<li><p>
asyncio.Future.result()
</p>

<p>
因为 yield from 从 Future 对象中产出的值就是结果。
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgff310f2" class="outline-4">
<h4 id="orgff310f2"><span class="section-number-4">5.3.4</span> asyncio.Task</h4>
<div class="outline-text-4" id="text-5-3-4">
<p>
asyncio.Task 是 asyncio.Future 的子类，与 threading.Thread 地位对等，可以理解为协程中的可调度单元。
</p>
</div>


<div id="outline-container-org5bab0f7" class="outline-5">
<h5 id="org5bab0f7"><span class="section-number-5">5.3.4.1</span> 创建 Task 对象</h5>
<div class="outline-text-5" id="text-5-3-4-1">
<ul class="org-ul">
<li><p>
asyncio.async(coro_or_future, *, loop=None)
</p>

<p>
如果第一个参数是 Future 或 Task 对象，则原封不动地返回； 如果是协程，则会调用 <code>loop.create_task()</code> 方法创建 Task 对象。
</p>

<p>
loop 关键词参数是可选的，用于传入事件循环，如果没有传入，则将调用 <code>asyncio.get_event_loop()</code> 获取。
</p></li>

<li><code>BaseEventLoop.create_task(coro)</code></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgae1b3b0" class="outline-4">
<h4 id="orgae1b3b0"><span class="section-number-4">5.3.5</span> APIs</h4>
<div class="outline-text-4" id="text-5-3-5">
</div>
<div id="outline-container-org0920464" class="outline-5">
<h5 id="org0920464"><span class="section-number-5">5.3.5.1</span> BaseEventLoop.run_in_executor(executor, func, *args)</h5>
<div class="outline-text-5" id="text-5-3-5-1">
<p>
asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，
可以调用 run_in_executor 方法，把可调用对象发给它执行。
</p>

<p>
第一个参数是 Executor 实例，如果为 None ，则使用默认的 ThreadPoolExecutor 实例。
</p>
</div>
</div>


<div id="outline-container-orgec9a2c6" class="outline-5">
<h5 id="orgec9a2c6"><span class="section-number-5">5.3.5.2</span> asyncio.as_complete(fs, *, loop=None, timeout=None)</h5>
<div class="outline-text-5" id="text-5-3-5-2">
<div class="org-src-container">
<pre class="src src-ipython">import asyncio
import time

async def foo(seconds):
    await asyncio.sleep(seconds)
    return seconds

async def coro():
    fs = [foo(10), foo(5), foo(1)]
    for f in asyncio.as_completed(fs):
        time0 = time.time()
        result = await f
        print(result, "delta", time.time() - time0)

asyncio.get_event_loop().run_until_complete(coro())
</pre>
</div>
</div>
</div>


<div id="outline-container-org2566f9f" class="outline-5">
<h5 id="org2566f9f"><span class="section-number-5">5.3.5.3</span> asyncio.Semaphore(value=1, *, loop=None)</h5>
<div class="outline-text-5" id="text-5-3-5-3">
<p>
Semaphore 类用于限制并发请求数量。
</p>

<p>
Semaphore 对象维护一个内部计数器:
</p>

<ul class="org-ul">
<li>如果在对象上调用 <code>acquire()</code> 方法，计数器递减；</li>
<li>如果调用 <code>release()</code> 方法，计数器递增。</li>
</ul>

<p>
可以把 Semaphore 对象 <span class="underline">当作上下文管理器使用</span> 。
</p>


<div class="org-src-container">
<pre class="src src-ipython">time0 = time.time()

async def foo(semaphore):
    with (await semaphore):
        await asyncio.sleep(2)
        print("time delta:", time.time() - time0)

async def coro():
    semaphore = asyncio.Semaphore(3)
    fs = [foo(semaphore) for _ in range(5)]
    for f in asyncio.as_completed(fs):
        await f

asyncio.get_event_loop().run_until_complete(coro())
</pre>
</div>
</div>
</div>


<div id="outline-container-org27090d8" class="outline-5">
<h5 id="org27090d8"><span class="section-number-5">5.3.5.4</span> asyncio.wait(futures, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</h5>
<div class="outline-text-5" id="text-5-3-5-4">
<p>
参数是一个由 Future 或协程构成的可迭代对象，wait 会分别把各个协程包装进一个 Task 对象。
wait 是协程函数，因此它 <b>不会阻塞</b> ，默认行为是等传给它的所有协程运行完毕后结束。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import random
async def foo():
    sec = random.randint(1, 3)
    await asyncio.sleep(sec)
    return sec

to_do = [foo() for _ in range(10)]
wait_coro = asyncio.wait(to_do)
result = asyncio.get_event_loop().run_until_complete(wait_coro)
log("result", result)
</pre>
</div>
</div>
</div>
</div>
</div>
</div>







<div id="outline-container-orgad7ff1f" class="outline-2">
<h2 id="orgad7ff1f"><span class="section-number-2">6</span> 元编程</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org88a75f6" class="outline-3">
<h3 id="org88a75f6"><span class="section-number-3">6.1</span> 属性查找顺序</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org67a744c" class="outline-4">
<h4 id="org67a744c"><span class="section-number-4">6.1.1</span> 从类中查找属性</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
使用 C.name 引用类对象 C 的一个属性时，查询操作如下：
</p>

<ol class="org-ol">
<li>当 name 是 <code>C.__dict__</code> 中的一个键时， C.name 将从 <code>C.__dict__['name']</code> 中提取值 v。如果 v 是一个描述器，则 C.name 的值就是 <code>type(v).__get__(v, None, C)</code> ，否则，C.name 的值为 v</li>
<li>否则，C.name 将委托查找 C 的基类</li>
<li>否则引发 AttributeError</li>
</ol>
</div>
</div>


<div id="outline-container-org812cf4f" class="outline-4">
<h4 id="org812cf4f"><span class="section-number-4">6.1.2</span> 从实例中查找属性</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
<code>obj.attr</code> 这样的表达式 <b>不会从 obj 开始寻找 attr</b> ，而是从 <code>obj.__class__</code> 开始，
<b>仅当类中没有名为 attr 的描述符时，才会在 obj 实例中寻找。</b>
</p>

<p>
使用 x.name 引用类 C 的实例 x 的一个属性时，查询操作如下：
</p>

<ol class="org-ol">
<li>当 name 作为一个覆盖描述器 v 的名称在类 C （或 C 的某个祖先类）中被找到，x.name 的值就是 <code>type(v).__get__(v, x, C)</code></li>
<li>否则，当 name 是 <code>x.__dict__</code> 中的一个键时，返回 <code>x.__dict__['name']</code></li>
<li>否则，x.name 将委托查找 x 的类，即查找 C.name</li>
<li>如果 C 定义或继承了特殊方法 <code>__getattr__</code> ，则调用 <code>C.__getattr__(x, 'name')</code> ，而不是引发 AttributeError，然后根据 <code>__getattr__</code> 返回一个合适的值或者引发 AttributeError</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org4f5c9e2" class="outline-3">
<h3 id="org4f5c9e2"><span class="section-number-3">6.2</span> 特殊方法__new__</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>通常把__init__方法称为构造方法，其实，用于构建实例的是特殊方法__new__</li>
<li>__new__是类方法，由于 <span class="underline">使用了特殊方式处理</span> ，因此不必使用 @classmethod 装饰器</li>
<li>该方法必须返回一个实例，返回的实例会作为 <span class="underline">第一个参数</span> (self) 传给__init__方法</li>
<li>__init__方法其实称为初始化方法更为合适（真正的构造方法是__new__）</li>
<li>几乎不需要自定义__new__方法，从 object 类继承的实现已经足够了</li>
</ul>


<pre class="example">
__new__方法也可以返回其他类的实例，此时，解释器不会调用__init__方法
</pre>


<p>
Python 构建对象的过程可以用下述伪代码概括：
</p>

<div class="org-src-container">
<pre class="src src-ipython">def object_maker(the_class, some_arg):
    new_object = the_class.__new__(some_arg)
    if isinstance(new_object, the_class):
        the_class.__init__(new_object, some_arg)
    return new_object

# 下述两个语句作用等效
# x = Foo('bar')
# x = object_maker(Foo, 'bar')
</pre>
</div>
</div>
</div>


<div id="outline-container-org6115bc3" class="outline-3">
<h3 id="org6115bc3"><span class="section-number-3">6.3</span> property(fget=None, fset=None, fdel=None, doc=None)</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>property 经常用作装饰器，但它其实是一个类</li>
<li>如果没有把函数传给某个可选参数，返回的 property 对象就不允许执行相应的操作</li>
<li><b>property 对象都是类属性，但是管理的其实是实例属性的存取</b></li>
</ul>
</div>
</div>


<div id="outline-container-org9d27c51" class="outline-3">
<h3 id="org9d27c51"><span class="section-number-3">6.4</span> 动态属性编程 API</h3>
<div class="outline-text-3" id="text-6-4">
</div>
<div id="outline-container-org4b87ab2" class="outline-4">
<h4 id="org4b87ab2"><span class="section-number-4">6.4.1</span> 特殊属性</h4>
<div class="outline-text-4" id="text-6-4-1">
</div>
<div id="outline-container-orgfb3e609" class="outline-5">
<h5 id="orgfb3e609"><span class="section-number-5">6.4.1.1</span> __class__属性</h5>
</div>

<div id="outline-container-org75a337c" class="outline-5">
<h5 id="org75a337c"><span class="section-number-5">6.4.1.2</span> __dict__属性</h5>
</div>


<div id="outline-container-org973ac8e" class="outline-5">
<h5 id="org973ac8e"><span class="section-number-5">6.4.1.3</span> __slots__属性</h5>
<div class="outline-text-5" id="text-6-4-1-3">
<p>
处理完类的定义体后再修改__slots__没有任何作用。
</p>
</div>
</div>
</div>


<div id="outline-container-org5e0c94a" class="outline-4">
<h4 id="org5e0c94a"><span class="section-number-4">6.4.2</span> 内置函数</h4>
<div class="outline-text-4" id="text-6-4-2">
</div>
<div id="outline-container-org1ba832b" class="outline-5">
<h5 id="org1ba832b"><span class="section-number-5">6.4.2.1</span> dir([obj])</h5>
<div class="outline-text-5" id="text-6-4-2-1">
<ul class="org-ul">
<li>不会列出__dict__属性本身，但会列出其中的键</li>
<li>不会列出类的几个特殊属性（如__mro__, __bases__和__name__）</li>
<li>如果没有可选参数，则列出当前作用域中的名称</li>
</ul>
</div>
</div>


<div id="outline-container-orgd791302" class="outline-5">
<h5 id="orgd791302"><span class="section-number-5">6.4.2.2</span> getattr(obj, name[, default])</h5>
</div>


<div id="outline-container-org1992080" class="outline-5">
<h5 id="org1992080"><span class="section-number-5">6.4.2.3</span> hasattr(obj, name)</h5>
<div class="outline-text-5" id="text-6-4-2-3">
<p>
该函数的实现方法其实是调用 <code>getattr(obj, name)</code> ，并检查是否抛出 AttributeError 异常。
</p>
</div>
</div>


<div id="outline-container-org413a7e0" class="outline-5">
<h5 id="org413a7e0"><span class="section-number-5">6.4.2.4</span> setattr(obj, name, value)</h5>
</div>


<div id="outline-container-org2ca23cd" class="outline-5">
<h5 id="org2ca23cd"><span class="section-number-5">6.4.2.5</span> vars([obj])</h5>
<div class="outline-text-5" id="text-6-4-2-5">
<ul class="org-ul">
<li>返回对象的__dict__属性</li>
<li>如果实例所属的类定义了__slots__属性，则 vars 函数不能处理这个实例（ dir 函数能处理）</li>
<li>如果没有参数，vars 函数的作用和 locals 函数一样，返回本地作用域的字典</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orga99cebe" class="outline-4">
<h4 id="orga99cebe"><span class="section-number-4">6.4.3</span> 特殊方法</h4>
<div class="outline-text-4" id="text-6-4-3">
<ul class="org-ul">
<li>使用点号或内置的 getattr, hasattr 和 setattr 函数存取对象属性会触发下述列表中对应的特殊方法</li>
<li>直接通过实例的__dict__读写属性不会触发这些特殊方法，通常 <span class="underline">使用这种方式跳过特殊方法</span></li>
<li>相比定义这些特殊方法，使用 property 或 descriptor <span class="underline">相对不容易出错</span></li>
</ul>

<p>
<a href="#orgc1760e3">特殊方法使用的警告</a>:
</p>

<pre class="example">
为确保调用特殊方法成功，特殊方法必须定义在类体上，而不能在对象的实例字典中定义。
此外，特殊方法不会被同名实例属性遮盖。
</pre>
</div>

<div id="outline-container-org1cd71d3" class="outline-5">
<h5 id="org1cd71d3"><span class="section-number-5">6.4.3.1</span> __delattr__(self, name)</h5>
</div>


<div id="outline-container-org2d35784" class="outline-5">
<h5 id="org2d35784"><span class="section-number-5">6.4.3.2</span> __dir__(self)</h5>
<div class="outline-text-5" id="text-6-4-3-2">
<p>
把对象传给 dir 函数时被调用，列出属性。
</p>
</div>
</div>


<div id="outline-container-org82b7e2f" class="outline-5">
<h5 id="org82b7e2f"><span class="section-number-5">6.4.3.3</span> __getattr__(self, name)</h5>
<div class="outline-text-5" id="text-6-4-3-3">
<p>
获取指定属性失败（搜索过实例，实例类和超类之后）之后被调用。
</p>
</div>
</div>


<div id="outline-container-org0661958" class="outline-5">
<h5 id="org0661958"><span class="section-number-5">6.4.3.4</span> __getattribute__(self, name)</h5>
<div class="outline-text-5" id="text-6-4-3-4">
<ul class="org-ul">
<li>尝试获取属性时总会调用这个方法。（_寻找的属性是特殊属性或特殊方法除外_）</li>
<li>点号与 getattr 和 hasattr 内置函数会触发这个方法</li>
<li>调用__getattribute__方法且抛出 AttributeError 异常时，才会调用__getattr__方法</li>
<li>__getattribute__方法的实现要使用 <code>super().__getattribute__(obj, name)</code> 以 <span class="underline">避免无限递归</span></li>
</ul>
</div>
</div>


<div id="outline-container-org4cc3e2f" class="outline-5">
<h5 id="org4cc3e2f"><span class="section-number-5">6.4.3.5</span> __setattr__(self, name, value)</h5>
</div>
</div>
</div>




<div id="outline-container-org3becdee" class="outline-3">
<h3 id="org3becdee"><span class="section-number-3">6.5</span> 描述符(Descriptor)</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>描述符是实现了特定协议的类，协议包括__get__, __set__和__delete__方法</li>
<li>描述符的用法是：创建一个实例，作为另一个类的 <span class="underline">类属性</span></li>
<li>通过类读取描述符实例（作为类属性），返回描述符实例本身（__get__方法返回描述符实例本身）</li>
<li>通过类修改描述符实例（作为类属性），直接修改类属性（__set方法 <span class="underline">不会被调用</span> ）</li>
</ul>
</div>


<div id="outline-container-org3d2b031" class="outline-4">
<h4 id="org3d2b031"><span class="section-number-4">6.5.1</span> 只实现__get__的描述符</h4>
<div class="outline-text-4" id="text-6-5-1">
<ul class="org-ul">
<li>若对象__dict__中无同名属性，通过对象实例读取同名描述符实例，返回描述符实例本身</li>
<li>若对象__dict__中存在同名属性，通过对象实例读取同名描述符实例，返回对象同名属性 （但特殊方法是特例，解释器 <span class="underline">只在实例的类对象中</span> ，而不是实例对象的__dict__中查找特殊方法）</li>
<li><span class="underline">方法就是以这种类型的描述符实现的</span></li>
</ul>
</div>
</div>

<div id="outline-container-org85cd0f0" class="outline-4">
<h4 id="org85cd0f0"><span class="section-number-4">6.5.2</span> 只实现__set__的描述符</h4>
<div class="outline-text-4" id="text-6-5-2">
<ul class="org-ul">
<li>设置对象同名实例属性时，__set__方法插手接管</li>
<li>若对象__dict__中无同名属性，通过对象实例读取同名描述符实例，返回描述符实例本身</li>
<li>若对象__dict__中存在同名属性，通过对象实例读取同名描述符实例，返回对象同名属性</li>
</ul>
</div>

<div id="outline-container-org8eb16f9" class="outline-5">
<h5 id="org8eb16f9"><span class="section-number-5">6.5.2.1</span> 实现__get__和__set__的描述符</h5>
<div class="outline-text-5" id="text-6-5-2-1">
<ul class="org-ul">
<li><span class="underline">内置的 property 类就是这种类型</span> ，其__set__方法默认抛出 AttributeError 异常</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-orgbb8b011" class="outline-3">
<h3 id="orgbb8b011"><span class="section-number-3">6.6</span> 元类</h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>所有类都是 type 的实例，元类是 type 的子类，可以作为制造类的工厂</li>
<li>元类可以通过实现__init__方法定制实例</li>
<li>元类的__init__方法可以做到类装饰器能做的任何事情</li>
<li>如果想进一步定制类，可以在元类中实现__new__方法。通常情况下实现__init__方法就够了</li>
</ul>
</div>

<div id="outline-container-org444a99c" class="outline-4">
<h4 id="org444a99c"><span class="section-number-4">6.6.1</span> 使用 type 动态创建类</h4>
<div class="outline-text-4" id="text-6-6-1">
<div class="org-src-container">
<pre class="src src-ipython">def fn(self, name='world'):
    print('Hello, %s.' % name)

Hello = type('Hello', (object,), dict(hello=fn))

h = Hello()
print((type(Hello), type(h)))
</pre>
</div>

<pre class="example">
(&lt;class 'type'&gt;, &lt;class '__main__.Hello'&gt;)

</pre>
</div>
</div>


<div id="outline-container-org7df0020" class="outline-4">
<h4 id="org7df0020"><span class="section-number-4">6.6.2</span> 使用 <b>metaclass</b> 指定元类</h4>
<div class="outline-text-4" id="text-6-6-2">
<p>
<span class="underline">类的默认元类是父类的元类</span> ，可以通过关键字 <b>metaclass</b> 指定元类：
</p>

<div class="org-src-container">
<pre class="src src-ipython">class MetaFoo(type):

    def __new__(metacls, name, bases, attrs):
        print("metacls: {}, name: {}, bases: {}, attrs: {}".format(metacls, name, bases, attrs))
        return type.__new__(metacls, name, bases, attrs)

    def __init__(cls, name, bases, attrs): # name, bases, attrs: 与构建类时传给 type 的参数一样
        print("cls: {}, name: {}, bases: {}, attrs: {}".format(cls, name, bases, attrs))

class Foo(str, metaclass=MetaFoo):
    pass

print(dir(Foo))
</pre>
</div>

<pre class="example">
metacls: &lt;class '__main__.MetaFoo'&gt;, name: Foo, bases: (&lt;class 'str'&gt;,), attrs: {'__module__': '__main__', '__qualname__': 'Foo'}
cls: &lt;class '__main__.Foo'&gt;, name: Foo, bases: (&lt;class 'str'&gt;,), attrs: {'__module__': '__main__', '__qualname__': 'Foo'}
['__add__', '__class__', '__contains__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

</pre>
</div>
</div>


<div id="outline-container-org5d152aa" class="outline-4">
<h4 id="org5d152aa"><span class="section-number-4">6.6.3</span> __prepare__方法</h4>
<div class="outline-text-4" id="text-6-6-3">
<ul class="org-ul">
<li>type 构造方法及元类的__new__和__init__方法都会收到要计算的类的定义体，形式是名称到属性的映射，默认情况下，那个映射所使用的数据结构是字典</li>
<li>Python3 引入了特殊方法__prepare__，这个特殊方法只在元类中有用，且必须声明为类方法，解释器调用元类的__new__方法前会先调用该方法</li>
<li>__prepare__方法的第一个参数是元类，随后两个参数分别是要构建的类的名称和基类组成的元组，返回值必须是映射类型</li>
<li>__prepare__返回的映射对象会传给__new__方法的最后一个参数，然后再传给__init__方法</li>
</ul>
</div>
</div>


<div id="outline-container-org1a3115b" class="outline-4">
<h4 id="org1a3115b"><span class="section-number-4">6.6.4</span> 与元编程相关的类属性/方法</h4>
<div class="outline-text-4" id="text-6-6-4">
</div>
<div id="outline-container-org98fe18e" class="outline-5">
<h5 id="org98fe18e"><span class="section-number-5">6.6.4.1</span> cls.__bases__</h5>
<div class="outline-text-5" id="text-6-6-4-1">
<p>
类的基类元组。
</p>
</div>
</div>

<div id="outline-container-org2682b71" class="outline-5">
<h5 id="org2682b71"><span class="section-number-5">6.6.4.2</span> cls.__qualname__</h5>
</div>

<div id="outline-container-org38b7562" class="outline-5">
<h5 id="org38b7562"><span class="section-number-5">6.6.4.3</span> cls.__subclass__()</h5>
<div class="outline-text-5" id="text-6-6-4-3">
<p>
返回内存里现存的直接子类列表。
</p>
</div>
</div>

<div id="outline-container-org5bf93df" class="outline-5">
<h5 id="org5bf93df"><span class="section-number-5">6.6.4.4</span> cls.mro()</h5>
<div class="outline-text-5" id="text-6-6-4-4">
<p>
解释器会调用这个方法获取超类元组。
元类可以覆盖这个方法以 <span class="underline">定制要构建的类解析方法的顺序</span> 。
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org2cfafba" class="outline-2">
<h2 id="org2cfafba"><span class="section-number-2">7</span> 代码仓库</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgb49aa25" class="outline-3">
<h3 id="orgb49aa25"><span class="section-number-3">7.1</span> 数据结构</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org7c66058" class="outline-4">
<h4 id="org7c66058"><span class="section-number-4">7.1.1</span> 序列操作</h4>
<div class="outline-text-4" id="text-7-1-1">
</div>
<div id="outline-container-orga07ae79" class="outline-5">
<h5 id="orga07ae79"><span class="section-number-5">7.1.1.1</span> 使用 * 处理元组拆包</h5>
<div class="outline-text-5" id="text-7-1-1-1">
<p>
<code>*</code> 前缀只能用在 <b>一个</b> 变量名前面，但是这个变量可以出现在赋值表达式的任意位置。
</p>


<div class="org-src-container">
<pre class="src src-ipython">a, b, *rest1 = range(5)
log("rest1", rest1)

a, b, *rest2 = range(3)
log("rest2", rest2)

a, b, *rest3 = range(2)
log("rest3", rest3)

a, *body, c, d = range(5)
log("body", body)

*head, b, c, d = range(5)
log("head", head)
</pre>
</div>

<pre class="example">
=========== rest1 ============
[2, 3, 4]
=========== rest2 ============
[2]
=========== rest3 ============
[]
============ body ============
[1, 2]
============ head ============
[0, 1]
</pre>
</div>
</div>



<div id="outline-container-orgf78d8d3" class="outline-5">
<h5 id="orgf78d8d3"><span class="section-number-5">7.1.1.2</span> 对序列重排位(itemgetter)</h5>
<div class="outline-text-5" id="text-7-1-1-2">
<div class="org-src-container">
<pre class="src src-ipython">from operator import itemgetter

data = [
    ('c', 2),
    ('b', 3),
    ['a', 1]
]

log("[itemgetter(1, 0)(t) for t in data]", [itemgetter(1, 0)(t) for t in data])
</pre>
</div>

<pre class="example">
===================== [itemgetter(1, 0)(t) for t in data] ======================
[(2, 'c'), (3, 'b'), (1, 'a')]

</pre>
</div>
</div>


<div id="outline-container-org04e4a42" class="outline-5">
<h5 id="org04e4a42"><span class="section-number-5">7.1.1.3</span> 给切片赋值</h5>
<div class="outline-text-5" id="text-7-1-1-3">
<p>
如果赋值的对象是一个切片， <b>赋值语句的右侧必须是个可迭代对象</b> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">l = list(range(10))
log("l", l)

l[2:5] = [20, 30]
log("after l[2:5] = [20, 30]", l)

del l[5:7]
log("after del l[5:7]", l)

l[3::2] = [11, 22]
log("after l[3::2] = [11, 22]", l)

try:
    l[2:5] = 100
except Exception as e:
    log("e", e)

l[2:5] = [100]
log("after l[2:5] = [100]", l)
</pre>
</div>

<pre class="example">
============= l ==============
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
== after l[2:5] = [20, 30] ===
[0, 1, 20, 30, 5, 6, 7, 8, 9]
====== after del l[5:7] ======
[0, 1, 20, 30, 5, 8, 9]
== after l[3::2] = [11, 22] ==
[0, 1, 20, 11, 5, 22, 9]
============= e ==============
can only assign an iterable
==== after l[2:5] = [100] ====
[0, 1, 100, 22, 9]
</pre>
</div>
</div>


<div id="outline-container-org425f4e1" class="outline-5">
<h5 id="org425f4e1"><span class="section-number-5">7.1.1.4</span> 使用 bisect 管理已排序序列</h5>
<div class="outline-text-5" id="text-7-1-1-4">
</div>
<div id="outline-container-orged616df" class="outline-6">
<h6 id="orged616df"><span class="section-number-6">7.1.1.4.1</span> 使用 bisect 搜索</h6>
<div class="outline-text-6" id="text-7-1-1-4-1">
<div class="org-src-container">
<pre class="src src-ipython">import bisect
import sys
HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]
NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]
ROW_FMT = '{0:2d} @ {1:2d}    {2}{0:&lt;2d}'

def demo(bisect_fn):
    print('DEMO:', bisect_fn.__name__)
    print('haystack -&gt;', ' '.join('%2d' % n for n in HAYSTACK))
    for needle in reversed(NEEDLES):
        position = bisect_fn(HAYSTACK, needle)
        offset = position * ' |'
        print(ROW_FMT.format(needle, position, offset))


demo(bisect.bisect_left)
print('=' * 60)
demo(bisect.bisect)
</pre>
</div>

<pre class="example">
DEMO: bisect_left
haystack -&gt;  1  4  5  6  8 12 15 20 21 23 23 26 29 30
31 @ 14     | | | | | | | | | | | | | |31
30 @ 13     | | | | | | | | | | | | |30
29 @ 12     | | | | | | | | | | | |29
23 @  9     | | | | | | | | |23
22 @  9     | | | | | | | | |22
10 @  5     | | | | |10
 8 @  4     | | | |8
 5 @  2     | |5
 2 @  1     |2
 1 @  0    1
 0 @  0    0
============================================================
DEMO: bisect_right
haystack -&gt;  1  4  5  6  8 12 15 20 21 23 23 26 29 30
31 @ 14     | | | | | | | | | | | | | |31
30 @ 14     | | | | | | | | | | | | | |30
29 @ 13     | | | | | | | | | | | | |29
23 @ 11     | | | | | | | | | | |23
22 @  9     | | | | | | | | |22
10 @  5     | | | | |10
 8 @  5     | | | | |8
 5 @  3     | | |5
 2 @  1     |2
 1 @  1     |1
 0 @  0    0
</pre>
</div>
</div>




<div id="outline-container-orgb2fb321" class="outline-6">
<h6 id="orgb2fb321"><span class="section-number-6">7.1.1.4.2</span> 使用 bisect 建立查询表格</h6>
<div class="outline-text-6" id="text-7-1-1-4-2">
<div class="org-src-container">
<pre class="src src-ipython">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect.bisect(breakpoints, score)
    return grades[i]

log("[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]",
     [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]])
</pre>
</div>

<pre class="example">
========== [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] ===========
['F', 'A', 'C', 'C', 'B', 'A', 'A']

</pre>
</div>
</div>


<div id="outline-container-org2ae9e22" class="outline-6">
<h6 id="org2ae9e22"><span class="section-number-6">7.1.1.4.3</span> 使用 bisect.insort 插入新元素</h6>
<div class="outline-text-6" id="text-7-1-1-4-3">
<div class="org-src-container">
<pre class="src src-ipython">import bisect
import random
SIZE=7
random.seed(1729)
my_list = []
for i in range(SIZE):
    new_item = random.randrange(SIZE*2)
    bisect.insort(my_list, new_item)
    print('%2d -&gt;' % new_item, my_list)
</pre>
</div>

<pre class="example">
10 -&gt; [10]
 0 -&gt; [0, 10]
 6 -&gt; [0, 6, 10]
 8 -&gt; [0, 6, 8, 10]
 7 -&gt; [0, 6, 7, 8, 10]
 2 -&gt; [0, 2, 6, 7, 8, 10]
10 -&gt; [0, 2, 6, 7, 8, 10, 10]

</pre>
</div>
</div>
</div>



<div id="outline-container-org3ba5a15" class="outline-5">
<h5 id="org3ba5a15"><span class="section-number-5">7.1.1.5</span> 列表中删除数据的陷阱</h5>
<div class="outline-text-5" id="text-7-1-1-5">
<div class="org-src-container">
<pre class="src src-ipython">lst = ['a', 'b', 'c', '', '']
for i in lst:
    if i is '':
        lst.remove(i)

print(lst)
</pre>
</div>

<pre class="example">
['a', 'b', 'c', '']

</pre>
</div>

<div id="outline-container-org7cf43e7" class="outline-6">
<h6 id="org7cf43e7"><span class="section-number-6">7.1.1.5.1</span> 原理</h6>
<div class="outline-text-6" id="text-7-1-1-5-1">
<p>
list 属于线性表，它的连续在于用一块连续的内存空间存储元素，在调用 remove 时，只是删除了地址内的元素。
</p>

<p>
回到问题，当删除列表中的元素时， <code>for in</code> 是对下标进行操作，
而 remove 是对值进行操作, 当 for 到达索引为 3 ，即第一个空字符位置时，符合条件即删除。
因为 list 是线性表，所以删除这个空字符时， <b>同时后面的所有元素自动移动位置 1</b> ，
此时的 lst 等于 <code>['a', 'b', 'c', '']</code> ，因为 <code>for in</code> 已经遍历到了索引 3 处，所以循环结束。
</p>
</div>
</div>


<div id="outline-container-org628f36c" class="outline-6">
<h6 id="org628f36c"><span class="section-number-6">7.1.1.5.2</span> 解决方法</h6>
<div class="outline-text-6" id="text-7-1-1-5-2">
<div class="org-src-container">
<pre class="src src-ipython">
lst = ['a','','b','','c','','']

# 做法一
while '' in lst:
    lst.remove('')
print(lst)


# 做法二

lst_new = [i for i in lst if i != '']
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org1bb342b" class="outline-5">
<h5 id="org1bb342b"><span class="section-number-5">7.1.1.6</span> 列表中出现频率最高</h5>
<div class="outline-text-5" id="text-7-1-1-6">
<div class="org-src-container">
<pre class="src src-ipython">words = [
   'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
   'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
   'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
   'my', 'eyes', "you're", 'under'
]

from collections import Counter
word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
</pre>
</div>

<pre class="example">
[('eyes', 8), ('the', 5), ('look', 4)]

</pre>
</div>
</div>


<div id="outline-container-org4b94d07" class="outline-5">
<h5 id="org4b94d07"><span class="section-number-5">7.1.1.7</span> 列表中最大或最小的几项</h5>
<div class="outline-text-5" id="text-7-1-1-7">
<div class="org-src-container">
<pre class="src src-ipython">import heapq

portfolio = [
   {'name': 'IBM', 'shares': 100, 'price': 91.1},
   {'name': 'AAPL', 'shares': 50, 'price': 543.22},
   {'name': 'FB', 'shares': 200, 'price': 21.09},
   {'name': 'HPQ', 'shares': 35, 'price': 31.75},
   {'name': 'YHOO', 'shares': 45, 'price': 16.35},
   {'name': 'ACME', 'shares': 75, 'price': 115.65}
]

cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
r = {'cheap': cheap, 'expensive': expensive}
print(r)
</pre>
</div>
</div>
</div>


<div id="outline-container-org6fffa7c" class="outline-5">
<h5 id="org6fffa7c"><span class="section-number-5">7.1.1.8</span> 对列表中的数据分组</h5>
<div class="outline-text-5" id="text-7-1-1-8">
<div class="org-src-container">
<pre class="src src-ipython">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]

from itertools import groupby

rows.sort(key=lambda r: r['date'])
for date, items in groupby(rows, key=lambda r: r['date']):
    print(date)
    for i in items:
        print('    ', i)
</pre>
</div>

<pre class="example">
07/01/2012
     {'address': '5412 N CLARK', 'date': '07/01/2012'}
     {'address': '4801 N BROADWAY', 'date': '07/01/2012'}
07/02/2012
     {'address': '5800 E 58TH', 'date': '07/02/2012'}
     {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}
     {'address': '1060 W ADDISON', 'date': '07/02/2012'}
07/03/2012
     {'address': '2122 N CLARK', 'date': '07/03/2012'}
07/04/2012
     {'address': '5148 N CLARK', 'date': '07/04/2012'}
     {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}
</pre>

<p>
或者使用 defaultdict 来实现：
</p>

<div class="org-src-container">
<pre class="src src-ipython">from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
print(rows_by_date)
</pre>
</div>

<pre class="example">
defaultdict(&lt;class 'list'&gt;, {'07/01/2012': [{'address': '5412 N CLARK', 'date': '07/01/2012'}, {'address': '4801 N BROADWAY', 'date': '07/01/2012'}], '07/02/2012': [{'address': '5800 E 58TH', 'date': '07/02/2012'}, {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}, {'address': '1060 W ADDISON', 'date': '07/02/2012'}], '07/03/2012': [{'address': '2122 N CLARK', 'date': '07/03/2012'}], '07/04/2012': [{'address': '5148 N CLARK', 'date': '07/04/2012'}, {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}]})

</pre>
</div>
</div>


<div id="outline-container-org918a783" class="outline-5">
<h5 id="org918a783"><span class="section-number-5">7.1.1.9</span> 消除序列中的重复数据，同时保持数据顺序</h5>
<div class="outline-text-5" id="text-7-1-1-9">
<div class="org-src-container">
<pre class="src src-ipython">def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)


a = [
        {'x': 2, 'y': 3},
        {'x': 1, 'y': 4},
        {'x': 2, 'y': 3},
        {'x': 2, 'y': 3},
        {'x': 10, 'y': 15}
    ]
print(list(dedupe(a, key=lambda a: (a['x'],a['y']))))
</pre>
</div>

<pre class="example">
[{'x': 2, 'y': 3}, {'x': 1, 'y': 4}, {'x': 10, 'y': 15}]

</pre>


<div class="org-src-container">
<pre class="src src-ipython">def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)

a = [1, 5, 2, 1, 9, 1, 5, 10]
print(list(dedupe(a)))
</pre>
</div>

<pre class="example">
[1, 5, 2, 9, 10]

</pre>
</div>
</div>


<div id="outline-container-org833459e" class="outline-5">
<h5 id="org833459e"><span class="section-number-5">7.1.1.10</span> 序列解包 (unpack)</h5>
<div class="outline-text-5" id="text-7-1-1-10">
<div class="org-src-container">
<pre class="src src-ipython">records = [
     ('foo', 1, 2),
     ('bar', 'hello'),
     ('foo', 3, 4),
]

def do_foo(x,y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)
</pre>
</div>

<pre class="example">
foo 1 2
bar hello
foo 3 4

</pre>
</div>
</div>


<div id="outline-container-orgba383cd" class="outline-5">
<h5 id="orgba383cd"><span class="section-number-5">7.1.1.11</span> flatten 列表</h5>
<div class="outline-text-5" id="text-7-1-1-11">
<div class="org-src-container">
<pre class="src src-ipython">from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]

# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)

items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
for x in flatten(items):
    print(x)

</pre>
</div>

<pre class="example">
1
2
3
4
5
6
7
8
Dave
Paula
Thomas
Lewis
</pre>
</div>
</div>



<div id="outline-container-org503d68f" class="outline-5">
<h5 id="org503d68f"><span class="section-number-5">7.1.1.12</span> 优先队列</h5>
<div class="outline-text-5" id="text-7-1-1-12">
<div class="org-src-container">
<pre class="src src-ipython">import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

# Example use
class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)

q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)

print("Should be bar:", q.pop())
print("Should be spam:", q.pop())
print("Should be foo:", q.pop())
print("Should be grok:", q.pop())
</pre>
</div>

<pre class="example">
Should be bar: Item('bar')
Should be spam: Item('spam')
Should be foo: Item('foo')
Should be grok: Item('grok')

</pre>
</div>
</div>
</div>





<div id="outline-container-org05026f9" class="outline-4">
<h4 id="org05026f9"><span class="section-number-4">7.1.2</span> 字典操作</h4>
<div class="outline-text-4" id="text-7-1-2">
</div>
<div id="outline-container-org4386139" class="outline-5">
<h5 id="org4386139"><span class="section-number-5">7.1.2.1</span> defaultdict</h5>
<div class="outline-text-5" id="text-7-1-2-1">
<p>
在实例化一个 defaultdict 的时候，需要给构造方法提供一个可调用对象，
这个可调用对象会在 <code>__getitem__</code> 找不到键的时候被调用，返回默认值。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import collections
d = collections.defaultdict(list)
d['a'].append('b')
d['c'].append('d')
log("d", d)
</pre>
</div>

<pre class="example">
============= d ==============
defaultdict(&lt;class 'list'&gt;, {'a': ['b'], 'c': ['d']})

</pre>
</div>
</div>




<div id="outline-container-orgd7d9be2" class="outline-5">
<h5 id="orgd7d9be2"><span class="section-number-5">7.1.2.2</span> OrderedDict</h5>
<div class="outline-text-5" id="text-7-1-2-2">
<p>
这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。
</p>

<p>
OrderedDict 的 popitem 方法默认删除并返回字典里最后一个元素，
但是如果调用 <code>popitem(last=False)</code> ，则删除并返回第一个被添加进去的元素。
</p>
</div>
</div>




<div id="outline-container-orgab49b4b" class="outline-5">
<h5 id="orgab49b4b"><span class="section-number-5">7.1.2.3</span> ChainMap</h5>
<div class="outline-text-5" id="text-7-1-2-3">
<p>
该类型可以容纳多个不同的映射对象，在进行键查找操作时，会逐个查找这些映射对象，直到键被找到为止。
</p>

<p>
这个功能在给有嵌套作用域的语言做解释器的时候很有用，可以用一个映射对象来代表一个作用域上下文。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import builtins
from collections import ChainMap
pylookup = ChainMap(locals(), globals(), vars(builtins))

</pre>
</div>
</div>
</div>



<div id="outline-container-orgfb7a892" class="outline-5">
<h5 id="orgfb7a892"><span class="section-number-5">7.1.2.4</span> Counter</h5>
<div class="outline-text-5" id="text-7-1-2-4">
<p>
这个映射类型会给键准备一个整数计数器，每次更新一个键的时候会增加这个计数器。
</p>

<p>
Counter 实现了 + 和 - 运算符来合并记录。 <code>most_common([n])</code> 方法会返回最常见的 n 个键和它们的计数。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from collections import Counter
ct = Counter('abracadabra')
print(ct)
ct.update('aaaaazzz')
print('after update'.center(30, '='))
print(ct)
print(ct.most_common(2))
</pre>
</div>

<pre class="example">
Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
=========after update=========
Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
[('a', 10), ('z', 3)]

</pre>
</div>
</div>



<div id="outline-container-orgfe4ad42" class="outline-5">
<h5 id="orgfe4ad42"><span class="section-number-5">7.1.2.5</span> UserDict <a id="org94cb7d1"></a></h5>
<div class="outline-text-5" id="text-7-1-2-5">
<p>
这个类其实是把标准 dict 用纯 Python 又实现了一遍，主要的用途是让用户继承写子类的。
</p>

<p>
更倾向于从 UserDict 而不是从 dict 继承的主要原因是后者有时会在某些方法的实现上走一些捷径，
导致不得不在子类中重写这些方法，但是 UserDict 就不会有这个问题。
</p>

<p>
继承自 dict 的 <code>__init__</code> 方法忽略了子类的 <code>__setitem__</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-ipython">class MyDict(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, value*2)

d = MyDict(one=1)
print(d)

d['two'] = 2
print(d)
</pre>
</div>

<pre class="example">
{'one': 1}
{'one': 1, 'two': 4}

</pre>


<p>
继承自 dict 的 update 方法也忽略了子类的 <code>__setitem__</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-ipython">d.update(three=3)
print(d)
</pre>
</div>

<pre class="example">
{'one': 1, 'two': 4, 'three': 3}

</pre>


<p>
另外一个值得注意的地方是， <b>UserDict 并不是 dict 的子类</b> 。
UserDict 有一个 <code>data</code> 属性，是 dict 的实例，这个属性实际上是 UserDict <b>最终存储数据的地方</b> 。
</p>
</div>
</div>


<div id="outline-container-org77b2f2e" class="outline-5">
<h5 id="org77b2f2e"><span class="section-number-5">7.1.2.6</span> 不可变映射类型(MappingProxyType)</h5>
<div class="outline-text-5" id="text-7-1-2-6">
<p>
types.MappingProxyType 会返回一个只读的映射视图。
虽然是只读视图，但是它是动态的，如果对原映射做出改动，
通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from types import MappingProxyType
d = {1: 'A'}
d_proxy = MappingProxyType(d)
print(d_proxy)

log("d_proxy[1]", d_proxy[1])

try:
    d_proxy[2] = 'x'
except Exception as e:
    print(e)

d[2] = 'B'
print(d_proxy)
</pre>
</div>

<pre class="example">
{1: 'A'}
========= d_proxy[1] =========
A
'mappingproxy' object does not support item assignment
{1: 'A', 2: 'B'}

</pre>
</div>
</div>





<div id="outline-container-orgde916c2" class="outline-5">
<h5 id="orgde916c2"><span class="section-number-5">7.1.2.7</span> 对字典作集合运算</h5>
<div class="outline-text-5" id="text-7-1-2-7">
<div class="org-src-container">
<pre class="src src-ipython">a = {
   'x' : 1,
   'y' : 2,
   'z' : 3
}

b = {
   'w' : 10,
   'x' : 11,
   'y' : 2
}

print('Common keys:', a.keys() &amp; b.keys())
print('Keys in a not in b:', a.keys() - b.keys())
print('(key,value) pairs in common:', a.items() &amp; b.items())
</pre>
</div>

<pre class="example">
Common keys: {'y', 'x'}
Keys in a not in b: {'z'}
(key,value) pairs in common: {('y', 2)}

</pre>
</div>
</div>


<div id="outline-container-orgded1856" class="outline-5">
<h5 id="orgded1856"><span class="section-number-5">7.1.2.8</span> 组合多个字典当作一个字典使用</h5>
<div class="outline-text-5" id="text-7-1-2-8">
<div class="org-src-container">
<pre class="src src-ipython">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }

# (a) Simple example of combining
from collections import ChainMap
c = ChainMap(a,b)

print("c:", c)

print(c['x'])      # Outputs 1  (from a)
print(c['y'])      # Outputs 2  (from b)
print(c['z'])      # Outputs 3  (from a)

# Output some common values
print('len(c):', len(c))
print('c.keys():', list(c.keys()))
print('c.values():', list(c.values()))

# Modify some values
c['z'] = 10
c['w'] = 40
del c['x']
print("a:", a)
</pre>
</div>

<pre class="example">
c: ChainMap({'x': 1, 'z': 3}, {'y': 2, 'z': 4})
1
2
3
len(c): 3
c.keys(): ['z', 'y', 'x']
c.values(): [3, 2, 1]
a: {'z': 10, 'w': 40}

</pre>
</div>
</div>


<div id="outline-container-org2c42265" class="outline-5">
<h5 id="org2c42265"><span class="section-number-5">7.1.2.9</span> 字典栈</h5>
<div class="outline-text-5" id="text-7-1-2-9">
<div class="org-src-container">
<pre class="src src-ipython"># Example of stacking mappings (like scopes)
values = ChainMap()
values['x'] = 1

# Add a new mapping
values = values.new_child()
values['x'] = 2

# Add a new mapping
values = values.new_child()
values['x'] = 3

print(values)
print(values['x'])

# Discard last mapping
values = values.parents
print(values)
print(values['x'])

# Discard last mapping
values = values.parents
print(values)
print(values['x'])
</pre>
</div>

<pre class="example">
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
3
ChainMap({'x': 2}, {'x': 1})
2
ChainMap({'x': 1})
1

</pre>
</div>
</div>
</div>



<div id="outline-container-orgea35115" class="outline-4">
<h4 id="orgea35115"><span class="section-number-4">7.1.3</span> 文本操作</h4>
<div class="outline-text-4" id="text-7-1-3">
</div>
<div id="outline-container-orgc3ac50d" class="outline-5">
<h5 id="orgc3ac50d"><span class="section-number-5">7.1.3.1</span> 获取 Unicode 字符名称(<a href="https://docs.python.org/3/library/unicodedata.html">unicodedata</a>)</h5>
<div class="outline-text-5" id="text-7-1-3-1">
<div class="org-src-container">
<pre class="src src-ipython">from unicodedata import name

for i in range(250, 256):
    print(chr(i), ":", name(chr(i), ''))
</pre>
</div>

<pre class="example">
ú : LATIN SMALL LETTER U WITH ACUTE
û : LATIN SMALL LETTER U WITH CIRCUMFLEX
ü : LATIN SMALL LETTER U WITH DIAERESIS
ý : LATIN SMALL LETTER Y WITH ACUTE
þ : LATIN SMALL LETTER THORN
ÿ : LATIN SMALL LETTER Y WITH DIAERESIS

</pre>
</div>
</div>


<div id="outline-container-org4fba75c" class="outline-5">
<h5 id="org4fba75c"><span class="section-number-5">7.1.3.2</span> 字符编码侦测(<a href="https://pypi.python.org/pypi/chardet">Chardet</a>)</h5>
<div class="outline-text-5" id="text-7-1-3-2">
<div class="org-src-container">
<pre class="src src-ipython">! chardetect ~/test.org
</pre>
</div>

<pre class="example">
/Users/ruan/test.org: ascii with confidence 1.0

</pre>
</div>
</div>


<div id="outline-container-org87f9116" class="outline-5">
<h5 id="org87f9116"><span class="section-number-5">7.1.3.3</span> 格式化</h5>
<div class="outline-text-5" id="text-7-1-3-3">
</div>
<div id="outline-container-org876c020" class="outline-6">
<h6 id="org876c020"><span class="section-number-6">7.1.3.3.1</span> 填充与对齐</h6>
<div class="outline-text-6" id="text-7-1-3-3-1">
<div class="org-src-container">
<pre class="src src-ipython">print('{:&gt;10}'.format('test'))
print('{:10}'.format('test'))
print('{:^10}'.format('test'))
print('{:_&lt;10}'.format('test'))
</pre>
</div>

<pre class="example">
      test
test
   test
test______

</pre>
</div>
</div>


<div id="outline-container-org6e63eef" class="outline-6">
<h6 id="org6e63eef"><span class="section-number-6">7.1.3.3.2</span> 字符串截断</h6>
<div class="outline-text-6" id="text-7-1-3-3-2">
<div class="org-src-container">
<pre class="src src-ipython">print('{:.5}'.format('xylophone'))
print('{:10.5}'.format('xylophone'))
</pre>
</div>

<pre class="example">
xylop
xylop

</pre>
</div>
</div>


<div id="outline-container-orgbc7bbaa" class="outline-6">
<h6 id="orgbc7bbaa"><span class="section-number-6">7.1.3.3.3</span> 占位符</h6>
<div class="outline-text-6" id="text-7-1-3-3-3">
<div class="org-src-container">
<pre class="src src-ipython">data = {'first': 'Hodor', 'last': 'Hodor!'}
print('{first} {last}'.format(**data))

print('{first} {last}'.format(first='Hodor', last='Hodor!'))
</pre>
</div>

<pre class="example">
Hodor Hodor!
Hodor Hodor!

</pre>

<div class="org-src-container">
<pre class="src src-ipython">person = {'first': 'Jean-Luc', 'last': 'Picard'}
data = [4, 8, 15, 16, 23, 42]
class Plant(object):
    category = 'tree'
    kinds = [{'name': 'oak'}, {'name': 'maple'}]

print('{p[first]} {p[last]}'.format(p=person))
print('{d[4]} {d[5]}'.format(d=data))
print('{p.category}: {p.kinds[0][name]}'.format(p=Plant()))
</pre>
</div>

<pre class="example">
Jean-Luc Picard
23 42
tree: oak

</pre>
</div>
</div>



<div id="outline-container-orge0ce33b" class="outline-6">
<h6 id="orge0ce33b"><span class="section-number-6">7.1.3.3.4</span> 排版</h6>
<div class="outline-text-6" id="text-7-1-3-3-4">
<div class="org-src-container">
<pre class="src src-ipython">import textwrap

s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under."

print(textwrap.fill(s, 70))
print()

print(textwrap.fill(s, 40))
print()

print(textwrap.fill(s, 40, initial_indent='    '))
print()

print(textwrap.fill(s, 40, subsequent_indent='    '))
print()
</pre>
</div>

<pre class="example">
Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
not around the eyes, don't look around the eyes, look into my eyes,
you're under.

Look into my eyes, look into my eyes,
the eyes, the eyes, the eyes, not around
the eyes, don't look around the eyes,
look into my eyes, you're under.

    Look into my eyes, look into my
eyes, the eyes, the eyes, the eyes, not
around the eyes, don't look around the
eyes, look into my eyes, you're under.

Look into my eyes, look into my eyes,
    the eyes, the eyes, the eyes, not
    around the eyes, don't look around
    the eyes, look into my eyes, you're
    under.

</pre>
</div>
</div>
</div>



<div id="outline-container-org1812ac8" class="outline-5">
<h5 id="org1812ac8"><span class="section-number-5">7.1.3.4</span> 字符串匹配</h5>
<div class="outline-text-5" id="text-7-1-3-4">
</div>
<div id="outline-container-org762684f" class="outline-6">
<h6 id="org762684f"><span class="section-number-6">7.1.3.4.1</span> 使用 shell 风格的通配符匹配字符串</h6>
<div class="outline-text-6" id="text-7-1-3-4-1">
<div class="org-src-container">
<pre class="src src-ipython">from fnmatch import fnmatchcase as match

addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY',
]

a = [addr for addr in addresses if match(addr, '* ST')]
print(a)

b = [addr for addr in addresses if match(addr, '54[0-9][0-9] *CLARK*')]
print(b)
</pre>
</div>

<pre class="example">
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
['5412 N CLARK ST']

</pre>
</div>
</div>


<div id="outline-container-org5364b9f" class="outline-6">
<h6 id="org5364b9f"><span class="section-number-6">7.1.3.4.2</span> 贪婪和非贪婪匹配</h6>
<div class="outline-text-6" id="text-7-1-3-4-2">
<div class="org-src-container">
<pre class="src src-ipython">import re

# Sample text
text = 'Computer says "no." Phone says "yes."'

# (a) Regex that finds quoted strings - longest match
str_pat = re.compile(r'\"(.*)\"')
print(str_pat.findall(text))

# (b) Regex that finds quoted strings - shortest match
str_pat = re.compile(r'\"(.*?)\"')
print(str_pat.findall(text))
</pre>
</div>

<pre class="example">
['no." Phone says "yes.']
['no.', 'yes.']

</pre>
</div>
</div>
</div>



<div id="outline-container-org093c8fb" class="outline-5">
<h5 id="org093c8fb"><span class="section-number-5">7.1.3.5</span> 输入密码</h5>
<div class="outline-text-5" id="text-7-1-3-5">
<div class="org-src-container">
<pre class="src src-ipython">import getpass

user = getpass.getuser()
passwd = getpass.getpass()

print('User:', user)
print('Passwd:', passwd)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8a9a64c" class="outline-4">
<h4 id="org8a9a64c"><span class="section-number-4">7.1.4</span> 字节操作</h4>
<div class="outline-text-4" id="text-7-1-4">
</div>
<div id="outline-container-org096ce26" class="outline-5">
<h5 id="org096ce26"><span class="section-number-5">7.1.4.1</span> 将字节序列转换成不同类型字段组成的元组(<a href="https://docs.python.org/3/library/struct.html">struct</a>)</h5>
<div class="outline-text-5" id="text-7-1-4-1">
<p>
<code>struct</code> 模块能处理 <code>bytes</code>, <code>bytearray</code> 和 <code>memoryview</code> 对象。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import struct
fmt = '&lt;1s3sHHH'
with open('img/p3_hash.png', 'rb') as fp:
    img = memoryview(fp.read())

header = img[:10]
log("bytes(header)", bytes(header))
log("struct.unpack(fmt, header)", struct.unpack(fmt, header))
</pre>
</div>

<pre class="example">
================================ bytes(header) =================================
b'\x89PNG\r\n\x1a\n\x00\x00'
========================== struct.unpack(fmt, header) ==========================
(b'\x89', b'PNG', 2573, 2586, 0)

</pre>
</div>
</div>
</div>



<div id="outline-container-orged1e052" class="outline-4">
<h4 id="orged1e052"><span class="section-number-4">7.1.5</span> 时间操作</h4>
<div class="outline-text-4" id="text-7-1-5">
</div>
<div id="outline-container-org0e182db" class="outline-5">
<h5 id="org0e182db"><span class="section-number-5">7.1.5.1</span> time 模块</h5>
<div class="outline-text-5" id="text-7-1-5-1">
<p>
time 模块始终返回 UTC 时间。
</p>
</div>

<div id="outline-container-orge6cecba" class="outline-6">
<h6 id="orge6cecba"><span class="section-number-6">7.1.5.1.1</span> 获取 Unix Timestamp</h6>
<div class="outline-text-6" id="text-7-1-5-1-1">
<p>
即从 Epoch (1970年1月1日00:00:00 UTC) 开始所经过的秒数。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import time
print(time.time())
</pre>
</div>

<pre class="example">
1542554851.5957272

</pre>
</div>
</div>


<div id="outline-container-org9a470ac" class="outline-6">
<h6 id="org9a470ac"><span class="section-number-6">7.1.5.1.2</span> 获取具体时间值</h6>
<div class="outline-text-6" id="text-7-1-5-1-2">
<div class="org-src-container">
<pre class="src src-ipython">current_time = time.time()
current_struct_time = time.gmtime(current_time)
print(current_struct_time)
</pre>
</div>

<pre class="example">
time.struct_time(tm_year=2018, tm_mon=11, tm_mday=18, tm_hour=15, tm_min=27, tm_sec=37, tm_wday=6, tm_yday=322, tm_isdst=0)

</pre>

<div class="org-src-container">
<pre class="src src-ipython">current_year = current_struct_time.tm_year
current_mon  = current_struct_time.tm_mon
current_mday = current_struct_time.tm_mday
current_hour = current_struct_time.tm_hour
current_min  = current_struct_time.tm_min
r = (current_year, current_mon, current_mday, current_hour, current_min)
print(r)
</pre>
</div>

<pre class="example">
(2018, 11, 18, 15, 27)

</pre>
</div>
</div>
</div>



<div id="outline-container-org679f398" class="outline-5">
<h5 id="org679f398"><span class="section-number-5">7.1.5.2</span> datatime 模块</h5>
<div class="outline-text-5" id="text-7-1-5-2">
<p>
datetime 模块简化了日期操作，如增加天数，设置时区等。
</p>
</div>

<div id="outline-container-orge07fb7f" class="outline-6">
<h6 id="orge07fb7f"><span class="section-number-6">7.1.5.2.1</span> 创建时间</h6>
<div class="outline-text-6" id="text-7-1-5-2-1">
<div class="org-src-container">
<pre class="src src-ipython">import datetime
d = datetime.datetime(year=2017, month=12, day=31, hour=12, minute=59, second=59)
r = (d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond)
print(r)
</pre>
</div>

<pre class="example">
(2017, 12, 31, 12, 59, 59, 0)

</pre>
</div>
</div>


<div id="outline-container-orgbf5d1d8" class="outline-6">
<h6 id="orgbf5d1d8"><span class="section-number-6">7.1.5.2.2</span> 获取 UTC 时间</h6>
<div class="outline-text-6" id="text-7-1-5-2-2">
<div class="org-src-container">
<pre class="src src-ipython">print(datetime.datetime.utcnow())
</pre>
</div>

<pre class="example">
2018-11-18 15:27:48.018708

</pre>
</div>
</div>


<div id="outline-container-org6ccd080" class="outline-6">
<h6 id="org6ccd080"><span class="section-number-6">7.1.5.2.3</span> 获取当前时区时间</h6>
<div class="outline-text-6" id="text-7-1-5-2-3">
<div class="org-src-container">
<pre class="src src-ipython">print(datetime.datetime.now())
</pre>
</div>

<pre class="example">
2018-11-18 23:27:54.145839

</pre>
</div>
</div>

<div id="outline-container-org00d85fb" class="outline-6">
<h6 id="org00d85fb"><span class="section-number-6">7.1.5.2.4</span> 日期运算</h6>
<div class="outline-text-6" id="text-7-1-5-2-4">
<div class="org-src-container">
<pre class="src src-ipython">today = datetime.datetime.now()
diff = datetime.timedelta(weeks=3, days=2)
future = today + diff
past = today - diff
print((future, past))
</pre>
</div>

<pre class="example">
(datetime.datetime(2018, 12, 11, 23, 28, 0, 332108), datetime.datetime(2018, 10, 26, 23, 28, 0, 332108))

</pre>
</div>
</div>


<div id="outline-container-org0b2c172" class="outline-6">
<h6 id="org0b2c172"><span class="section-number-6">7.1.5.2.5</span> 日期转字符串</h6>
<div class="outline-text-6" id="text-7-1-5-2-5">
<div class="org-src-container">
<pre class="src src-ipython">r = '{:%Y-%m-%d %H:%M}'.format(datetime.datetime(2001, 2, 3, 4, 5))
print(r)
</pre>
</div>

<pre class="example">
2001-02-03 04:05

</pre>
</div>
</div>


<div id="outline-container-org9972bc9" class="outline-6">
<h6 id="org9972bc9"><span class="section-number-6">7.1.5.2.6</span> 字符串转日期</h6>
<div class="outline-text-6" id="text-7-1-5-2-6">
<div class="org-src-container">
<pre class="src src-ipython">r = datetime.datetime.strptime("Mar 03, 2010", "%b %d, %Y")
print(r)
</pre>
</div>

<pre class="example">
2010-03-03 00:00:00

</pre>
</div>
</div>
</div>



<div id="outline-container-org1de0973" class="outline-5">
<h5 id="org1de0973"><span class="section-number-5">7.1.5.3</span> 获取月份缩写</h5>
<div class="outline-text-5" id="text-7-1-5-3">
<div class="org-src-container">
<pre class="src src-ipython">from calendar import month_abbr
print(list(month_abbr))
</pre>
</div>

<pre class="example">
['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

</pre>
</div>
</div>
</div>


<div id="outline-container-org2099429" class="outline-4">
<h4 id="org2099429"><span class="section-number-4">7.1.6</span> 数字操作</h4>
<div class="outline-text-4" id="text-7-1-6">
</div>
<div id="outline-container-org8002a15" class="outline-5">
<h5 id="org8002a15"><span class="section-number-5">7.1.6.1</span> 数字格式化</h5>
<div class="outline-text-5" id="text-7-1-6-1">
<div class="org-src-container">
<pre class="src src-ipython">print('{:06.2f}'.format(3.141592653589793))
print('{:04d}'.format(42))
print('{:+d}'.format(42))
print('{: d}'.format(42))
print('{: d}'.format(-42))
print('{:=5d}'.format((- 23)))
print('{:=+5d}'.format((23)))
</pre>
</div>

<pre class="example">
003.14
0042
+42
 42
-42
-  23
+  23

</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org9f4ed47" class="outline-3">
<h3 id="org9f4ed47"><span class="section-number-3">7.2</span> 函数</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-org1063e7d" class="outline-4">
<h4 id="org1063e7d"><span class="section-number-4">7.2.1</span> 获取函数签名信息(inspect.signature)</h4>
<div class="outline-text-4" id="text-7-2-1">
<div class="org-src-container">
<pre class="src src-ipython">from inspect import signature

def foo(a, b=1, **c):
    pass

print(signature(foo))
print()
for name, param in sig.parameters.items():
    print(param.kind, ':', name, '=', param.default)
</pre>
</div>

<pre class="example">
(a, b=1, **c)

POSITIONAL_OR_KEYWORD : a = &lt;class 'inspect._empty'&gt;
POSITIONAL_OR_KEYWORD : b = 1
VAR_KEYWORD : c = &lt;class 'inspect._empty'&gt;

</pre>


<p>
<code>inspect.signature</code> 返回一个 <code>inspect.Signature</code> 对象，
它有一个 <code>parameters</code> 属性，这是一个有序映射，将参数名和 <code>inspect.Parameter</code> 对象对应起来。
<code>Parameter</code> 对象的属性有 <code>name</code>, <code>default</code>, <code>kind</code> 。
</p>

<p>
<code>inspect._empty</code> 表示没有默认值。（这里不能使用 <code>None</code> ，是因为 <code>None</code> 可以作为默认值）
</p>
</div>


<div id="outline-container-org853540d" class="outline-5">
<h5 id="org853540d"><span class="section-number-5">7.2.1.1</span> 绑定参数到函数签名中(inspect.Signature.bind)</h5>
<div class="outline-text-5" id="text-7-2-1-1">
<p>
<code>inspect.Signature</code> 对象有个 <code>bind</code> 方法，可以把任意个参数绑定到签名中的形参上，
所用的规则与实参到形参的匹配方式一样。
在框架中可以使用这个方法 <span class="underline">在真正调用函数前验证参数</span> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import inspect
def foo(a, b=1, **c):
    pass

args = {'a': 1, 'b': 2, 'x': '1', 'y': '2'}
sig = inspect.signature(foo)
bound_args = sig.bind(**args)
log("bound_args", bound_args)
print()
for name, value in bound_args.arguments.items():
    print(name, '=', value)

print()
del args['a']
try:
    bound_args = sig.bind(**args)
except Exception as e:
    print(e)


</pre>
</div>

<pre class="example">
================================== bound_args ==================================
&lt;BoundArguments (a=1, b=2, c={'x': '1', 'y': '2'})&gt;

a = 1
b = 2
c = {'x': '1', 'y': '2'}

missing a required argument: 'a'

</pre>
</div>
</div>
</div>



<div id="outline-container-org6400aa8" class="outline-4">
<h4 id="org6400aa8"><span class="section-number-4">7.2.2</span> 函数式编程风格(operator)</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
<code>operator</code> 模块以函数的形式提供了 Python 全部的中缀运算符，
从而避免编写类似 <code>lambda a, b: a * b</code> 这种平凡的匿名函数。
</p>
</div>

<div id="outline-container-orgb09760c" class="outline-5">
<h5 id="orgb09760c"><span class="section-number-5">7.2.2.1</span> 数学运算</h5>
<div class="outline-text-5" id="text-7-2-2-1">
<div class="org-src-container">
<pre class="src src-ipython">import functools
import operator
log("functools.reduce(operator.xor, range(6))", functools.reduce(operator.xor, range(6)))
log("functools.reduce(operator.mul, range(1, 7))", functools.reduce(operator.mul, range(1, 7)))
</pre>
</div>

<pre class="example">
=================== functools.reduce(operator.xor, range(6)) ===================
1
================= functools.reduce(operator.mul, range(1, 7)) ==================
720

</pre>
</div>
</div>

<div id="outline-container-orgbe3d590" class="outline-5">
<h5 id="orgbe3d590"><span class="section-number-5">7.2.2.2</span> 从序列中取出元素(itemgetter)</h5>
<div class="outline-text-5" id="text-7-2-2-2">
<div class="org-src-container">
<pre class="src src-ipython">from operator import itemgetter

data = [
    ('c', 2),
    ('b', 3),
    ('a', 1)
]

log("sorted(data, key=itemgetter(0))", sorted(data, key=itemgetter(0)))
</pre>
</div>

<pre class="example">
======================= sorted(data, key=itemgetter(0)) ========================
[('a', 1), ('b', 3), ('c', 2)]

</pre>

<p>
如果把多个参数传给 <code>itemgetter</code> ，它构建的函数会返回提取的值构成的元组：
</p>

<div class="org-src-container">
<pre class="src src-ipython">log("[itemgetter(1, 0)(t) for t in data]", [itemgetter(1, 0)(t) for t in data])
</pre>
</div>

<pre class="example">
===================== [itemgetter(1, 0)(t) for t in data] ======================
[(2, 'c'), (3, 'b'), (1, 'a')]

</pre>
</div>
</div>


<div id="outline-container-orgab3ae95" class="outline-5">
<h5 id="orgab3ae95"><span class="section-number-5">7.2.2.3</span> 读取对象属性(attrgetter)</h5>
<div class="outline-text-5" id="text-7-2-2-3">
<p>
<code>attrgetter</code> 与 <code>itemgetter</code> 作用类似，它创建的函数根据名称提取对象的属性。
如果把多个属性名传给 <code>attrgetter</code> ，它也会返回提取的值构成的元组。
</p>

<p>
此外，如果参数名中包含 <b>.</b> ， <code>attrgetter</code> 会深入嵌套对象，获取指定的属性。
</p>

<div class="org-src-container">
<pre class="src src-ipython">metro_data = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
    ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833))
]

from collections import namedtuple
LatLong = namedtuple('LatLong', 'lat long')
Metropolis = namedtuple('Metropolis', 'name cc pop coord')
metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long))
               for name, cc, pop, (lat, long) in metro_data]


log("metro_areas[0]", metro_areas[0])
name_lat = attrgetter('name', 'coord.lat')
log("name_lat(metro_areas[0])", name_lat(metro_areas[0]))
print()

from operator import attrgetter
for city in sorted(metro_areas, key=attrgetter('coord.lat')):
    print(name_lat(city))
</pre>
</div>

<pre class="example">
================================ metro_areas[0] ================================
Metropolis(name='Tokyo', cc='JP', pop=36.933, coord=LatLong(lat=35.689722, long=139.691667))
=========================== name_lat(metro_areas[0]) ===========================
('Tokyo', 35.689722)

('Sao Paulo', -23.547778)
('Mexico City', 19.433333)
('Delhi NCR', 28.613889)
('Tokyo', 35.689722)
('New York-Newark', 40.808611)
</pre>
</div>
</div>


<div id="outline-container-orgd37bebf" class="outline-5">
<h5 id="orgd37bebf"><span class="section-number-5">7.2.2.4</span> 调用对象方法(methodcall)</h5>
<div class="outline-text-5" id="text-7-2-2-4">
<div class="org-src-container">
<pre class="src src-ipython">from operator import methodcaller
s = "hello world"
log("methodcaller('upper')(s)", methodcaller('upper')(s))
log("methodcaller('replace', ' ', '-')(s)", methodcaller('replace', ' ', '-')(s))
</pre>
</div>

<pre class="example">
=========================== methodcaller('upper')(s) ===========================
HELLO WORLD
===================== methodcaller('replace', ' ', '-')(s) =====================
hello-world

</pre>
</div>
</div>
</div>



<div id="outline-container-org1b2d692" class="outline-4">
<h4 id="org1b2d692"><span class="section-number-4">7.2.3</span> 使用装饰器</h4>
<div class="outline-text-4" id="text-7-2-3">
</div>
<div id="outline-container-org926e3a9" class="outline-5">
<h5 id="org926e3a9"><span class="section-number-5">7.2.3.1</span> 记录函数运行时间</h5>
<div class="outline-text-5" id="text-7-2-3-1">
<div class="org-src-container">
<pre class="src src-ipython">import functools
import time

def clock(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        t0 = time.perf_counter()
        result = func(*args, **kw)
        elapsed = time.perf_counter() - t0
        name = func.__name__
        arg_lst = []
        if args:
            arg_lst.append(', '.join(repr(arg) for arg in args))
        if kw:
            pairs = ['{}={}'.format(k, w) for k, w in sorted(kw.items())]
            arg_lst.append(', '.join(pairs))
        arg_str = ', '.join(arg_lst)
        print("[{:0.8f}] {}({}) -&gt; {}".format(elapsed, name, arg_str, result))
        return result
    return wrapper

@clock
def snooze(t):
    time.sleep(t)

snooze(0.1)
snooze(0.2)
snooze(0.3)
</pre>
</div>

<pre class="example">
[0.10157284] snooze(0.1) -&gt; None
[0.20283653] snooze(0.2) -&gt; None
[0.30416814] snooze(0.3) -&gt; None

</pre>
</div>
</div>


<div id="outline-container-org483245f" class="outline-5">
<h5 id="org483245f"><span class="section-number-5">7.2.3.2</span> 缓存函数返回值(functools.lru_cache)</h5>
<div class="outline-text-5" id="text-7-2-3-2">
<p>
它把耗时的函数的结果缓存起来，避免传入相同的参数时重复计算，可以使用两个可选的参数来配置：
</p>

<ul class="org-ul">
<li><p>
<code>maxsize</code>
</p>

<p>
指定存储多少个调用的结果。缓存满了之后，旧的结果会被删除，腾出空间。
</p></li>
</ul>
<p>
为了得到最佳性能，=maxsize= 应设为 2 的幂。
</p>

<ul class="org-ul">
<li><p>
<code>typed</code>
</p>

<p>
如果设为 True ，把不同参数类型得到的结果分开保存，
即把通常认为相等的浮点数和整数参数(如 1 和 1.0)区分开。
</p></li>
</ul>

<p>
因为 <code>lru_cache</code> 使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，
因此被 <code>lru_cache</code> 装饰的函数， <span class="underline">它的所有参数必须是可散列的</span> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">@clock
def fib(n):
    if n &lt; 2: return n
    return fib(n-2) + fib(n-1)

print("result: ", fib(6))
</pre>
</div>

<pre class="example">
[0.00000045] fib(0) -&gt; 0
[0.00000053] fib(1) -&gt; 1
[0.00029566] fib(2) -&gt; 1
[0.00000040] fib(1) -&gt; 1
[0.00000035] fib(0) -&gt; 0
[0.00000041] fib(1) -&gt; 1
[0.00005358] fib(2) -&gt; 1
[0.00010595] fib(3) -&gt; 2
[0.00048775] fib(4) -&gt; 3
[0.00000033] fib(1) -&gt; 1
[0.00000032] fib(0) -&gt; 0
[0.00000110] fib(1) -&gt; 1
[0.00010550] fib(2) -&gt; 1
[0.00015888] fib(3) -&gt; 2
[0.00000056] fib(0) -&gt; 0
[0.00000050] fib(1) -&gt; 1
[0.00012996] fib(2) -&gt; 1
[0.00000042] fib(1) -&gt; 1
[0.00000048] fib(0) -&gt; 0
[0.00000041] fib(1) -&gt; 1
[0.00005725] fib(2) -&gt; 1
[0.00025901] fib(3) -&gt; 2
[0.00050781] fib(4) -&gt; 3
[0.00088358] fib(5) -&gt; 5
[0.00145318] fib(6) -&gt; 8
result:  8
</pre>

<div class="org-src-container">
<pre class="src src-ipython">import functools

@functools.lru_cache()
@clock
def fib(n):
    if n &lt; 2:
        return n
    return fib(n-2) + fib(n-1)

print("result:", fib(6))
</pre>
</div>

<pre class="example">
[0.00000047] fib(0) -&gt; 0
[0.00000077] fib(1) -&gt; 1
[0.00021293] fib(2) -&gt; 1
[0.00000149] fib(3) -&gt; 2
[0.00030547] fib(4) -&gt; 3
[0.00000166] fib(5) -&gt; 5
[0.00044729] fib(6) -&gt; 8
result: 8

</pre>
</div>
</div>





<div id="outline-container-org844f086" class="outline-5">
<h5 id="org844f086"><span class="section-number-5">7.2.3.3</span> 单分派泛函(functools.singledispatch)</h5>
<div class="outline-text-5" id="text-7-2-3-3">
<p>
使用 <code>singledispatch</code> 装饰的普通函数会变成分派泛函：
根据 <b>第一个参数的类型</b> ，执行具体的操作。
（正是因为根据第一个参数的类型，所以称为单分派，
若根据多个参数选择 <span class="underline">专门的函数</span> ，那就是多分派了）
</p>

<p>
专门的函数 <span class="underline">应该处理抽象基类</span> ，如 <code>numbers.Integral</code>, <code>abc.MutableSequence</code> ，
不要处理具体实现，如 <code>int</code>, <code>list</code> 。这样，代码支持的兼容类型才能更广泛。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from functools import singledispatch
from collections import abc
import numbers
import html

@singledispatch
def htmlize(obj):
    content = html.escape(repr(obj))
    return '&lt;pre&gt;{}&lt;/pre&gt;'.format(content)

@htmlize.register(str)
def _(text):
    content = html.escape(text).replace('\n', '&lt;br&gt;\n')
    return '&lt;p&gt;{0}&lt;/p&gt;'.format(content)

@htmlize.register(numbers.Integral)
def _(n):
    return '&lt;pre&gt;{0} (0x{0:x})&lt;/pre&gt;'.format(n)

@htmlize.register(tuple)
@htmlize.register(abc.MutableSequence)
def _(seq):
    inner = '&lt;/li&gt;\n&lt;li&gt;'.join(htmlize(item) for item in seq)
    return '&lt;ul&gt;\n&lt;li&gt;' + inner + '&lt;/li&gt;\n&lt;/ul&gt;'


log("htmlize({1, 2, 3})", htmlize({1, 2, 3}))
log("htmlize(abs)", htmlize(abs))
log("htmlize('helloworld')", htmlize('helloworld'))
log("htmlize(42)", htmlize(42))
log("htmlize([1, 2, 3])", htmlize([1, 2, 3]))

</pre>
</div>

<pre class="example">
============================== htmlize({1, 2, 3}) ==============================
&lt;pre&gt;{1, 2, 3}&lt;/pre&gt;
================================= htmlize(abs) =================================
&lt;pre&gt;&amp;lt;built-in function abs&amp;gt;&lt;/pre&gt;
============================ htmlize('helloworld') =============================
&lt;p&gt;helloworld&lt;/p&gt;
================================= htmlize(42) ==================================
&lt;pre&gt;42 (0x2a)&lt;/pre&gt;
============================== htmlize([1, 2, 3]) ==============================
&lt;ul&gt;
&lt;li&gt;&lt;pre&gt;1 (0x1)&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;2 (0x2)&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;3 (0x3)&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org5c0aa19" class="outline-3">
<h3 id="org5c0aa19"><span class="section-number-3">7.3</span> IO 编程</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org91a6f5d" class="outline-4">
<h4 id="org91a6f5d"><span class="section-number-4">7.3.1</span> 文件 IO</h4>
<div class="outline-text-4" id="text-7-3-1">
</div>
<div id="outline-container-org76e3d8d" class="outline-5">
<h5 id="org76e3d8d"><span class="section-number-5">7.3.1.1</span> 将文件描述符包装成文件对象</h5>
<div class="outline-text-5" id="text-7-3-1-1">
<div class="org-src-container">
<pre class="src src-ipython">from socket import socket, AF_INET, SOCK_STREAM

def echo_client(client_sock, addr):
    print("Got connection from", addr)

    # Make text-mode file wrappers for socket reading/writing
    client_in = open(client_sock.fileno(), 'rt', encoding='latin-1', closefd=False)
    client_out = open(client_sock.fileno(), 'wt', encoding='latin-1', closefd=False)

    # Echo lines back to the client using file I/O
    for line in client_in:
        client_out.write(line)
        client_out.flush()
    client_sock.close()

def echo_server(address):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(address)
    sock.listen(1)
    while True:
        client, addr = sock.accept()
        echo_client(client, addr)

print('Echo serving running on localhost:25000')
echo_server(('', 25000))
</pre>
</div>
</div>
</div>



<div id="outline-container-org8b3c426" class="outline-5">
<h5 id="org8b3c426"><span class="section-number-5">7.3.1.2</span> 改变已打开文件的编码方式</h5>
<div class="outline-text-5" id="text-7-3-1-2">
<div class="org-src-container">
<pre class="src src-ipython"># Example of adding a text encoding to existing file-like object

import urllib.request
import io

u = urllib.request.urlopen('http://www.python.org')
f = io.TextIOWrapper(u, encoding='utf-8')
text = f.read()

print(text)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org34d512b" class="outline-4">
<h4 id="org34d512b"><span class="section-number-4">7.3.2</span> 内存 IO</h4>
<div class="outline-text-4" id="text-7-3-2">
</div>
<div id="outline-container-org0dba786" class="outline-5">
<h5 id="org0dba786"><span class="section-number-5">7.3.2.1</span> 内存字符串</h5>
<div class="outline-text-5" id="text-7-3-2-1">
<div class="org-src-container">
<pre class="src src-ipython">from io import StringIO
f = StringIO()
f.write('hello')
f.write(' ')
f.write('world!')
print(f.getvalue())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">f = StringIO('Hello!\nHi!\nGoodbye!')
while True:
    s = f.readline()
    if s == '':  # eof
        break
    print(s, end='')
</pre>
</div>
</div>
</div>


<div id="outline-container-org4197d4f" class="outline-5">
<h5 id="org4197d4f"><span class="section-number-5">7.3.2.2</span> 内存比特流</h5>
<div class="outline-text-5" id="text-7-3-2-2">
<div class="org-src-container">
<pre class="src src-ipython">from io import BytesIO
f = BytesIO()
f.write('中文'.encode('utf-8'))
print(f.getvalue())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
r = f.read().decode('utf-8')
print(r)
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-org6f8b1e8" class="outline-3">
<h3 id="org6f8b1e8"><span class="section-number-3">7.4</span> 面向对象编程</h3>
<div class="outline-text-3" id="text-7-4">
</div>
<div id="outline-container-org0eb61cf" class="outline-4">
<h4 id="org0eb61cf"><span class="section-number-4">7.4.1</span> 为实例属性提供默认值</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
类属性可用于为实例属性提供默认值：
</p>

<div class="org-src-container">
<pre class="src src-ipython">class A:
    value = 'default value'
    pass

a = A()
print(a.value)
</pre>
</div>

<pre class="example">
default value

</pre>
</div>
</div>



<div id="outline-container-orgca48d17" class="outline-4">
<h4 id="orgca48d17"><span class="section-number-4">7.4.2</span> 创建缓存对象</h4>
<div class="outline-text-4" id="text-7-4-2">
<div class="org-src-container">
<pre class="src src-ipython">class Spam:
    def __init__(self, name):
        self.name = name

# Caching support
import weakref
_spam_cache = weakref.WeakValueDictionary()

def get_spam(name):
    if name not in _spam_cache:
        s = Spam(name)
        _spam_cache[name] = s
    else:
        s = _spam_cache[name]
    return s

if __name__ == '__main__':
    a = get_spam('foo')
    b = get_spam('bar')
    print('a is b:', a is b)
    c = get_spam('foo')
    print('a is c:', a is c)
</pre>
</div>

<pre class="example">
a is b: False
a is c: True

</pre>


<div class="org-src-container">
<pre class="src src-ipython">import weakref

class CachedSpamManager:
    def __init__(self):
        self._cache = weakref.WeakValueDictionary()
    def get_spam(self, name):
        if name not in self._cache:
            s = Spam(name)
            self._cache[name] = s
        else:
            s = self._cache[name]
        return s

class Spam:
    def __init__(self, name):
        self.name = name

Spam.manager = CachedSpamManager()

def get_spam(name):
    return Spam.manager.get_spam(name)

if __name__ == '__main__':
    a = get_spam('foo')
    b = get_spam('bar')
    print('a is b:', a is b)
    c = get_spam('foo')
    print('a is c:', a is c)
</pre>
</div>

<pre class="example">
a is b: False
a is c: True

</pre>

<div class="org-src-container">
<pre class="src src-ipython"># Example involving new and some of its problems

import weakref

class Spam:
    _spam_cache = weakref.WeakValueDictionary()
    def __new__(cls, name):
        if name in cls._spam_cache:
            return cls._spam_cache[name]
        else:
            self = super().__new__(cls)
            cls._spam_cache[name] = self
            return self

    def __init__(self, name):
        print('Initializing Spam')
        self.name = name

if __name__ == '__main__':
    print("This should print 'Initializing Spam' twice")
    s = Spam('Dave')
    t = Spam('Dave')
    print(s is t)
</pre>
</div>

<pre class="example">
This should print 'Initializing Spam' twice
Initializing Spam
Initializing Spam
True

</pre>
</div>
</div>



<div id="outline-container-org4633cb7" class="outline-4">
<h4 id="org4633cb7"><span class="section-number-4">7.4.3</span> 使用抽象类</h4>
<div class="outline-text-4" id="text-7-4-3">
<div class="org-src-container">
<pre class="src src-ipython">from abc import ABCMeta, abstractmethod

class A(metaclass=ABCMeta):
    @property
    @abstractmethod
    def name(self):
        pass

    @name.setter
    @abstractmethod
    def name(self, value):
        pass

    @classmethod
    @abstractmethod
    def method1(cls):
        pass

    @staticmethod
    @abstractmethod
    def method2():
        pass
</pre>
</div>
</div>
</div>



<div id="outline-container-org72ce371" class="outline-4">
<h4 id="org72ce371"><span class="section-number-4">7.4.4</span> 处理 Json 数据</h4>
<div class="outline-text-4" id="text-7-4-4">
</div>
<div id="outline-container-orgf8e1e53" class="outline-5">
<h5 id="orgf8e1e53"><span class="section-number-5">7.4.4.1</span> 使用 OrderedDict 处理 Json 数据</h5>
<div class="outline-text-5" id="text-7-4-4-1">
<div class="org-src-container">
<pre class="src src-ipython">import json

# Some JSON encoded text
s = '{"name": "ACME", "shares": 50, "price": 490.1}'

# (a) Turning JSON into an OrderedDict

from collections import OrderedDict
data = json.loads(s, object_pairs_hook=OrderedDict)
print(data)
</pre>
</div>

<pre class="example">
OrderedDict([('name', 'ACME'), ('shares', 50), ('price', 490.1)])

</pre>
</div>
</div>

<div id="outline-container-org07e5bff" class="outline-5">
<h5 id="org07e5bff"><span class="section-number-5">7.4.4.2</span> 使用 Json 数据填充对象</h5>
<div class="outline-text-5" id="text-7-4-4-2">
<div class="org-src-container">
<pre class="src src-ipython">class JSONObject:
    def __init__(self, d):
        self.__dict__ = d

data = json.loads(s, object_hook=JSONObject)
print(data.name)
print(data.shares)
print(data.price)
</pre>
</div>

<pre class="example">
ACME
50
490.1

</pre>
</div>
</div>


<div id="outline-container-org88e1f9a" class="outline-5">
<h5 id="org88e1f9a"><span class="section-number-5">7.4.4.3</span> 将对象序列化成 Json 数据</h5>
<div class="outline-text-5" id="text-7-4-4-3">
<div class="org-src-container">
<pre class="src src-ipython">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def serialize_instance(obj):
    d = { '__classname__' : type(obj).__name__ }
    d.update(vars(obj))
    return d

p = Point(3,4)
s = json.dumps(p, default=serialize_instance)
print(s)
</pre>
</div>

<pre class="example">
{"__classname__": "Point", "x": 3, "y": 4}

</pre>
</div>
</div>


<div id="outline-container-org8ff16b3" class="outline-5">
<h5 id="org8ff16b3"><span class="section-number-5">7.4.4.4</span> 将 Json 数据反序列化成对象</h5>
<div class="outline-text-5" id="text-7-4-4-4">
<div class="org-src-container">
<pre class="src src-ipython">classes = {
    'Point' : Point
}

def unserialize_object(d):
    clsname = d.pop('__classname__', None)
    if clsname:
        cls = classes[clsname]
        obj = cls.__new__(cls)
        for key, value in d.items():
            setattr(obj, key, value)
        return obj
    else:
        return d

a = json.loads(s, object_hook=unserialize_object)
print(a)
print(a.x)
print(a.y)
</pre>
</div>

<pre class="example">
&lt;__main__.Point object at 0x11c5f3e48&gt;
3
4

</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org1b8436b" class="outline-3">
<h3 id="org1b8436b"><span class="section-number-3">7.5</span> 流程控制</h3>
<div class="outline-text-3" id="text-7-5">
</div>
<div id="outline-container-orgf5ec898" class="outline-4">
<h4 id="orgf5ec898"><span class="section-number-4">7.5.1</span> 归约函数</h4>
<div class="outline-text-4" id="text-7-5-1">
</div>
<div id="outline-container-org3169de6" class="outline-5">
<h5 id="org3169de6"><span class="section-number-5">7.5.1.1</span> all(it)</h5>
</div>

<div id="outline-container-org7207c6e" class="outline-5">
<h5 id="org7207c6e"><span class="section-number-5">7.5.1.2</span> any(it)</h5>
</div>

<div id="outline-container-org3cac38b" class="outline-5">
<h5 id="org3cac38b"><span class="section-number-5">7.5.1.3</span> max(it, [key], [default])</h5>
<div class="outline-text-5" id="text-7-5-1-3">
<p>
如果可迭代对象为空，返回 <code>default</code> 。
</p>

<p>
可以这样调用：
</p>

<p>
<code>max(arg1, arg2, ..., [key])</code>
</p>
</div>
</div>

<div id="outline-container-orgdf8aaed" class="outline-5">
<h5 id="orgdf8aaed"><span class="section-number-5">7.5.1.4</span> min(it, [key], [default])</h5>
<div class="outline-text-5" id="text-7-5-1-4">
<p>
如果可迭代对象为空，返回 <code>default</code> 。
</p>

<p>
可以这样调用：
</p>

<p>
<code>min(arg1, arg2, ..., [key])</code>
</p>
</div>
</div>

<div id="outline-container-orgef171f2" class="outline-5">
<h5 id="orgef171f2"><span class="section-number-5">7.5.1.5</span> functools.reduce(func, it, [initial])</h5>
</div>

<div id="outline-container-orgc916733" class="outline-5">
<h5 id="orgc916733"><span class="section-number-5">7.5.1.6</span> sum(it, start=0)</h5>
</div>
</div>


<div id="outline-container-org8a703f9" class="outline-4">
<h4 id="org8a703f9"><span class="section-number-4">7.5.2</span> 标准库中的生成器函数</h4>
<div class="outline-text-4" id="text-7-5-2">
</div>
<div id="outline-container-org1e53855" class="outline-5">
<h5 id="org1e53855"><span class="section-number-5">7.5.2.1</span> 用于过滤的生成器函数</h5>
<div class="outline-text-5" id="text-7-5-2-1">
</div>
<div id="outline-container-org58141d3" class="outline-6">
<h6 id="org58141d3"><span class="section-number-6">7.5.2.1.1</span> itertools.compress(it, selector_it)</h6>
<div class="outline-text-6" id="text-7-5-2-1-1">
<p>
并行处理两个可迭代对象：如果 selector_it 中的元素是真值，产出 it 中对应的元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import itertools
def vowel(c):
    return c.lower() in 'aeiou'

result = list(itertools.compress('Aardvark', (1, 0, 1, 1, 0, 1)))
print(result)
</pre>
</div>

<pre class="example">
['A', 'r', 'd', 'a']

</pre>
</div>
</div>


<div id="outline-container-org87a40e3" class="outline-6">
<h6 id="org87a40e3"><span class="section-number-6">7.5.2.1.2</span> itertools.dropwhile(predicate, it)</h6>
<div class="outline-text-6" id="text-7-5-2-1-2">
<p>
处理 it ，跳过 predicate 计算结果为真值的元素，产出剩下的元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.dropwhile(vowel, 'Aardvark')))
</pre>
</div>

<pre class="example">
['r', 'd', 'v', 'a', 'r', 'k']

</pre>
</div>
</div>


<div id="outline-container-org86a4c65" class="outline-6">
<h6 id="org86a4c65"><span class="section-number-6">7.5.2.1.3</span> builtin.filter(predicate, it)</h6>
<div class="outline-text-6" id="text-7-5-2-1-3">
<p>
如果 <code>predicate(item)</code> 返回真值，产出对应的元素，如果 predicate 是 None ，则只产出真值元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(filter(vowel, 'Aardvark')))
</pre>
</div>

<pre class="example">
['A', 'a', 'a']

</pre>
</div>
</div>


<div id="outline-container-orgd2b2afb" class="outline-6">
<h6 id="orgd2b2afb"><span class="section-number-6">7.5.2.1.4</span> itertools.filterfalse(predicate, it)</h6>
<div class="outline-text-6" id="text-7-5-2-1-4">
<p>
如果 <code>predicate(item)</code> 返回假值，产出对应的元素。
</p>
</div>
</div>


<div id="outline-container-org9f1f81a" class="outline-6">
<h6 id="org9f1f81a"><span class="section-number-6">7.5.2.1.5</span> itertools.islice(it, [start], stop, step=1)</h6>
<div class="outline-text-6" id="text-7-5-2-1-5">
<p>
产出 it 的切片，类似于 <code>s[:stop]</code> 或 <code>s[start:stop:step]</code> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.islice('Aardvark', 4)))
print(list(itertools.islice('Aardvark', 4, 7)))
print(list(itertools.islice('Aardvark', 1, 7, 2)))
</pre>
</div>

<pre class="example">
['A', 'a', 'r', 'd']
['v', 'a', 'r']
['a', 'd', 'a']

</pre>
</div>
</div>


<div id="outline-container-org00a0af2" class="outline-6">
<h6 id="org00a0af2"><span class="section-number-6">7.5.2.1.6</span> itertools.takewhile(predicate, it)</h6>
<div class="outline-text-6" id="text-7-5-2-1-6">
<p>
如果 <code>predicate(item)</code> 返回真值，产出对应的元素，然后停止。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.takewhile(vowel, 'Aardvark')))
</pre>
</div>

<pre class="example">
['A', 'a']

</pre>
</div>
</div>


<div id="outline-container-org33d6c4b" class="outline-6">
<h6 id="org33d6c4b"><span class="section-number-6">7.5.2.1.7</span> builtin.iter(callable, sentinel)</h6>
<div class="outline-text-6" id="text-7-5-2-1-7">
<p>
第一个参数是一个没有参数的可调用对象，用于不断调用，产出各个值；第二个值是哨符，当可调用对象返回这个值时，迭代结束 (不产出哨符) 。
</p>

<p>
iter 的<a href="https://docs.python.org/3/library/functions.html#iter">文档</a>中有个实用的例子，这段代码逐行读取文件，直到遇到空行或到达文件末尾为止：
</p>

<div class="org-src-container">
<pre class="src src-ipython">with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgbc33e2c" class="outline-5">
<h5 id="orgbc33e2c"><span class="section-number-5">7.5.2.2</span> 用于映射的生成器函数</h5>
<div class="outline-text-5" id="text-7-5-2-2">
</div>
<div id="outline-container-orgf643e64" class="outline-6">
<h6 id="orgf643e64"><span class="section-number-6">7.5.2.2.1</span> itertools.accumulate(it, [func])</h6>
<div class="outline-text-6" id="text-7-5-2-2-1">
<p>
产出累计值，默认为求和；如果提供了 func ，则把前面两个元素传个 func ，
然后把计算结果和下一个元素传给它，以此类推，最后产出结果。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from operator import mul
sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1]

print(list(itertools.accumulate(sample)))
print(list(itertools.accumulate(sample, min)))
print(list(itertools.accumulate(sample, mul)))

</pre>
</div>

<pre class="example">
[5, 9, 11, 19, 26, 32, 35, 35, 44, 45]
[5, 4, 2, 2, 2, 2, 2, 0, 0, 0]
[5, 20, 40, 320, 2240, 13440, 40320, 0, 0, 0]

</pre>
</div>
</div>


<div id="outline-container-org04846f0" class="outline-6">
<h6 id="org04846f0"><span class="section-number-6">7.5.2.2.2</span> builtin.enumerate(it, start=0)</h6>
<div class="outline-text-6" id="text-7-5-2-2-2">
<p>
产出有两个元素组成的元组，结构是 (index, item) ，其中 index 从 start 开始计数，item 则从 iterable 中获取。
</p>
</div>
</div>


<div id="outline-container-org7926be5" class="outline-6">
<h6 id="org7926be5"><span class="section-number-6">7.5.2.2.3</span> builtin.map(func, it1, [it2, &#x2026;, itN])</h6>
<div class="outline-text-6" id="text-7-5-2-2-3">
<p>
如果传入 N 个 可迭代对象，则 func 必须能接受 N 个参数。
</p>
</div>
</div>


<div id="outline-container-orge56e3ee" class="outline-6">
<h6 id="orge56e3ee"><span class="section-number-6">7.5.2.2.4</span> itertools.starmap(func, it)</h6>
<div class="outline-text-6" id="text-7-5-2-2-4">
<p>
把 it 中各个元素传给 func ，产出结果。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.starmap(mul, enumerate('albatroz', 1))))
print(list(itertools.starmap(lambda a, b: b/a,
                             enumerate(itertools.accumulate(sample), 1))))
</pre>
</div>

<pre class="example">
['a', 'll', 'bbb', 'aaaa', 'ttttt', 'rrrrrr', 'ooooooo', 'zzzzzzzz']
[5.0, 4.5, 3.6666666666666665, 4.75, 5.2, 5.333333333333333, 5.0, 4.375, 4.888888888888889, 4.5]

</pre>
</div>
</div>
</div>


<div id="outline-container-orgaa1ae5f" class="outline-5">
<h5 id="orgaa1ae5f"><span class="section-number-5">7.5.2.3</span> 用于合并可迭代对象的生成器函数</h5>
<div class="outline-text-5" id="text-7-5-2-3">
</div>
<div id="outline-container-org6fc3b41" class="outline-6">
<h6 id="org6fc3b41"><span class="section-number-6">7.5.2.3.1</span> itertools.chain(it1, &#x2026;, itN)</h6>
<div class="outline-text-6" id="text-7-5-2-3-1">
<p>
无缝连接多个可迭代对象。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.chain('ABC', range(3))))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 0, 1, 2]

</pre>
</div>
</div>


<div id="outline-container-orgb9caa06" class="outline-6">
<h6 id="orgb9caa06"><span class="section-number-6">7.5.2.3.2</span> itertools.chain.from_iterable(it)</h6>
<div class="outline-text-6" id="text-7-5-2-3-2">
<p>
产出 it 生成的各个可迭代对象中的元素，无缝连接在一起。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.chain.from_iterable(enumerate('ABC'))))
</pre>
</div>

<pre class="example">
[0, 'A', 1, 'B', 2, 'C']

</pre>
</div>
</div>


<div id="outline-container-org57d04c0" class="outline-6">
<h6 id="org57d04c0"><span class="section-number-6">7.5.2.3.3</span> itertaools.product(it1, &#x2026;, itN, repeat=1)</h6>
<div class="outline-text-6" id="text-7-5-2-3-3">
<p>
计算笛卡尔积，合并成由 N 个元素组成的元组。
repeat 关键字参数告诉 product 函数重复 N 次处理输入的各个可迭代对象。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.product('ABC', range(2))))
# list(itertools.product('ABC', 'ABC'))
print(list(itertools.product('ABC', repeat=2)))
</pre>
</div>

<pre class="example">
[('A', 0), ('A', 1), ('B', 0), ('B', 1), ('C', 0), ('C', 1)]
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]

</pre>
</div>
</div>


<div id="outline-container-org7851d01" class="outline-6">
<h6 id="org7851d01"><span class="section-number-6">7.5.2.3.4</span> builtin.zip(it1, .., itN)</h6>
<div class="outline-text-6" id="text-7-5-2-3-4">
<p>
产出由 N 个元素组成的元组，只要有一个可迭代对象到头了，即停止。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(zip('ABC', range(5), [10, 20, 30, 40, 50, 60])))
</pre>
</div>

<pre class="example">
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30)]

</pre>
</div>
</div>


<div id="outline-container-orgc16c335" class="outline-6">
<h6 id="orgc16c335"><span class="section-number-6">7.5.2.3.5</span> itertools.zip_longest(it1, &#x2026;, itN, fillvalue=None)</h6>
<div class="outline-text-6" id="text-7-5-2-3-5">
<p>
产出由 N 个元素组成的元组，等到最长的可迭代对象到头了，即停止。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.zip_longest('ABC',
                                 range(5),
                                 [10, 20, 30, 40, 50, 60],
                                 fillvalue='?')))
</pre>
</div>

<pre class="example">
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30), ('?', 3, 40), ('?', 4, 50), ('?', '?', 60)]

</pre>
</div>
</div>
</div>


<div id="outline-container-orgc62f5f2" class="outline-5">
<h5 id="orgc62f5f2"><span class="section-number-5">7.5.2.4</span> 用于扩展输出元素的生成器函数</h5>
<div class="outline-text-5" id="text-7-5-2-4">
</div>
<div id="outline-container-org423aa0b" class="outline-6">
<h6 id="org423aa0b"><span class="section-number-6">7.5.2.4.1</span> itertools.combinations(it, out_len)</h6>
<div class="outline-text-6" id="text-7-5-2-4-1">
<p>
把 it 产出的 out_len 个元素组合在一起，然后产出。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.combinations('ABC', 2)))
</pre>
</div>

<pre class="example">
[('A', 'B'), ('A', 'C'), ('B', 'C')]

</pre>
</div>
</div>


<div id="outline-container-org3d20654" class="outline-6">
<h6 id="org3d20654"><span class="section-number-6">7.5.2.4.2</span> itertools.combinations_with_replacement(it, out_len)</h6>
<div class="outline-text-6" id="text-7-5-2-4-2">
<p>
把 it 产出的 out_len 个元素组合在一起，然后产出，包含相同元素的组合。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.combinations_with_replacement('ABC', 2)))
</pre>
</div>

<pre class="example">
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]

</pre>
</div>
</div>


<div id="outline-container-org3cd5156" class="outline-6">
<h6 id="org3cd5156"><span class="section-number-6">7.5.2.4.3</span> itertools.permutation(it, out_len=None)</h6>
<div class="outline-text-6" id="text-7-5-2-4-3">
<p>
把 out_len 个 it 产出元素排列在一起，然后产出这些排列；out_len 的默认值等于 <code>len(list(it))</code> 。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.permutations('ABC', 2)))
</pre>
</div>

<pre class="example">
[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

</pre>
</div>
</div>


<div id="outline-container-orgb4bf77d" class="outline-6">
<h6 id="orgb4bf77d"><span class="section-number-6">7.5.2.4.4</span> itertools.count(start=0, step=1)</h6>
<div class="outline-text-6" id="text-7-5-2-4-4">
<p>
从 start 开支不断产出数字，按 step 步幅增加。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.islice(itertools.count(1, .3), 3)))
</pre>
</div>

<pre class="example">
[1, 1.3, 1.6]

</pre>


<div class="org-src-container">
<pre class="src src-ipython">print(list(zip(count(), ['a', 'b', 'c'])))
</pre>
</div>

<pre class="example">
[(0, 'a'), (1, 'b'), (2, 'c')]

</pre>
</div>
</div>


<div id="outline-container-org21c0319" class="outline-6">
<h6 id="org21c0319"><span class="section-number-6">7.5.2.4.5</span> itertools.cycle(it)</h6>
<div class="outline-text-6" id="text-7-5-2-4-5">
<p>
从 it 中产出元素，存储各个元素的 <b>副本</b> ，然后按顺序重复不断地产出各个元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.islice(itertools.cycle('ABC'), 7)))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 'A', 'B', 'C', 'A']

</pre>
</div>
</div>


<div id="outline-container-org086c415" class="outline-6">
<h6 id="org086c415"><span class="section-number-6">7.5.2.4.6</span> itertools.repeat(item, [times])</h6>
<div class="outline-text-6" id="text-7-5-2-4-6">
<p>
不断产出指定元素，除非指定次数。常见用途，为 map 函数提供固定参数：
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(map(mul, range(11), itertools.repeat(5))))
</pre>
</div>

<pre class="example">
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]

</pre>
</div>
</div>
</div>




<div id="outline-container-org6af9e68" class="outline-5">
<h5 id="org6af9e68"><span class="section-number-5">7.5.2.5</span> 用于重新排列元素的生成器函数</h5>
<div class="outline-text-5" id="text-7-5-2-5">
</div>
<div id="outline-container-orgfbe4b43" class="outline-6">
<h6 id="orgfbe4b43"><span class="section-number-6">7.5.2.5.1</span> itertools.groupby(it, key=None)</h6>
<div class="outline-text-6" id="text-7-5-2-5-1">
<p>
产出由两个元素组成的元组，形式为 (key, group) ，其中 key 是分组标准，group 是生成器，用于产出分组里的元素。
</p>

<p>
注意， <code>itertool.groupby</code> 假定输入的可迭代对象已使用指定的 key 分组了各个元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(itertools.groupby('LLLAAGGG')))
print(list(itertools.groupby('LLAALAAGGG')))
</pre>
</div>

<pre class="example">
[('L', &lt;itertools._grouper object at 0x106a79208&gt;), ('A', &lt;itertools._grouper object at 0x106a791d0&gt;), ('G', &lt;itertools._grouper object at 0x106a79080&gt;)]
[('L', &lt;itertools._grouper object at 0x106a79cf8&gt;), ('A', &lt;itertools._grouper object at 0x106a791d0&gt;), ('L', &lt;itertools._grouper object at 0x106a79080&gt;), ('A', &lt;itertools._grouper object at 0x106a79160&gt;), ('G', &lt;itertools._grouper object at 0x106a79358&gt;)]

</pre>

<div class="org-src-container">
<pre class="src src-ipython">animals = ['duck', 'eagle', 'rat', 'giraffe', 'bear', 'bat', 'dolphin', 'shark', 'lion']
animals.sort(key=len)
for length, group in itertools.groupby(animals, len):
    print(length, '-&gt;', list(group))
</pre>
</div>

<pre class="example">
3 -&gt; ['rat', 'bat']
4 -&gt; ['duck', 'bear', 'lion']
5 -&gt; ['eagle', 'shark']
7 -&gt; ['giraffe', 'dolphin']

</pre>
</div>
</div>


<div id="outline-container-org73665d0" class="outline-6">
<h6 id="org73665d0"><span class="section-number-6">7.5.2.5.2</span> builtin.reversed(seq)</h6>
<div class="outline-text-6" id="text-7-5-2-5-2">
<p>
seq 必须是序列，或是实现了 <code>__reversed__</code> 特殊方法的对象。
</p>
</div>
</div>


<div id="outline-container-org4dfa3dc" class="outline-6">
<h6 id="org4dfa3dc"><span class="section-number-6">7.5.2.5.3</span> itertools.tee(it, n=2)</h6>
<div class="outline-text-6" id="text-7-5-2-5-3">
<p>
产出一个由 n 个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素。
</p>

<div class="org-src-container">
<pre class="src src-ipython">print(list(zip(*itertools.tee('ABC'))))
</pre>
</div>

<pre class="example">
[('A', 'A'), ('B', 'B'), ('C', 'C')]

</pre>
</div>
</div>
</div>
</div>







<div id="outline-container-org855d13e" class="outline-4">
<h4 id="org855d13e"><span class="section-number-4">7.5.3</span> 上下文管理 <a id="orgcc21107"></a></h4>
<div class="outline-text-4" id="text-7-5-3">
</div>
<div id="outline-container-org807b771" class="outline-5">
<h5 id="org807b771"><span class="section-number-5">7.5.3.1</span> 自动关闭对象(closing)</h5>
<div class="outline-text-5" id="text-7-5-3-1">
<p>
如果对象提供了 <code>close()</code> 方法，但没有实现 <code>__enter__/__exit__</code> 协议，则可以用这个函数构建上下文管理器。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from contextlib import closing

class Door:

    def open(self):
        print("door opened")

    def close(self):
        print("door closed")

with closing(Door()) as door:
    door.open()
</pre>
</div>

<pre class="example">
door opened
door closed

</pre>
</div>
</div>


<div id="outline-container-org42cbdd7" class="outline-5">
<h5 id="org42cbdd7"><span class="section-number-5">7.5.3.2</span> 忽略异常(suppress)</h5>
<div class="outline-text-5" id="text-7-5-3-2">
<p>
构建忽略指定异常的上下文管理器。
</p>

<div class="org-src-container">
<pre class="src src-ipython">from contextlib import suppress
import os

with suppress(FileNotFoundError):
    os.remove('somefile.tmp')
</pre>
</div>
</div>
</div>


<div id="outline-container-org9cb937d" class="outline-5">
<h5 id="org9cb937d"><span class="section-number-5">7.5.3.3</span> 重定向(redirect_stdout)</h5>
<div class="outline-text-5" id="text-7-5-3-3">
<div class="org-src-container">
<pre class="src src-ipython">import io
from contextlib import redirect_stdout

f = io.StringIO()
with redirect_stdout(f):
    help(pow)

log("f.getvalue()", f.getvalue())
</pre>
</div>

<pre class="example">
================================= f.getvalue() =================================
Help on built-in function pow in module builtins:

pow(x, y, z=None, /)
    Equivalent to x**y (with two arguments) or x**y % z (with three arguments)

    Some types, such as ints, are able to use a more efficient algorithm when
    invoked using the three argument form.


</pre>

<div class="org-src-container">
<pre class="src src-ipython">with open('/tmp/help.txt', 'w') as f:
    with redirect_stdout(f):
        help(pow)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd194af3" class="outline-5">
<h5 id="orgd194af3"><span class="section-number-5">7.5.3.4</span> 使用生成器作为上下文管理器(@contextmanager)</h5>
<div class="outline-text-5" id="text-7-5-3-4">
<p>
这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。
</p>

<p>
在使用 <code>@contextmanager</code> 装饰的生成器中， <code>yield</code>  语句的作用是把函数的定义体分成两部分：
</p>

<ul class="org-ul">
<li>yield 语句前面的所有代码在 with 块开始时 (即解释器调用 <code>__enter__</code> 方法时) 执行</li>
<li>yield 语句后面的代码在 with 块结束时 (即调用 <code>__exit__</code> 方法时) 执行</li>
</ul>


<div class="org-src-container">
<pre class="src src-ipython">from contextlib import contextmanager

class Query(object):

    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    with suppress(Exception):
        yield Query(name)  # 绑定到 as 子句的目标变量
    print('End')

with create_query('Bob') as q:
    q.query()
</pre>
</div>

<pre class="example">
Begin
Query info about Bob...
End

</pre>


<div class="org-src-container">
<pre class="src src-ipython">@contextmanager
def tag(name):
    print("&lt;%s&gt;" % name, end='')
    with suppress(Exception):
        yield  # 无需使用 as 子句
    print("&lt;/%s&gt;" % name)

with tag("h1"):
    print("hello", end='')
</pre>
</div>

<pre class="example">
&lt;h1&gt;hello&lt;/h1&gt;

</pre>

<p>
本质上，=contextlib.contextmanager= 装饰器会把函数包装成实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法的类
(类的名称是 _GeneraorContextManager) 。
</p>

<p>
这个类的 <code>__enter__</code> 方法有如下作用：
</p>

<ul class="org-ul">
<li>调用生成器函数，保存生成器对象 (这里把它成为 gen)</li>
<li>调用 <code>next(gen)</code> ，执行到 <code>yield</code> 关键字所在位置</li>
<li>返回上一步 <code>next(gen)</code> 产出的值，以便把产出的值绑定到 with/as 语句中的目标变量上</li>
</ul>

<p>
with 块终止时， <code>__exit__</code> 方法会做以下几件事：
</p>

<ul class="org-ul">
<li>检查有没有异常，如果有，调用 <code>gen.throw(ex)</code> ，在生成器函数定义体中包含 <code>yield</code> 关键字的那一行抛出异常</li>
<li>否则，再调用 <code>next(gen)</code> ，继续执行生成器函数定义体中 <code>yield</code> 语句之后的代码</li>
</ul>


<p>
<b>注意:</b>
</p>

<p>
如果在 with 块中抛出了异常，Python 解释器会将其捕获，然后会在生成器函数中 <code>yield</code> 表达式处再次抛出。
</p>

<p>
<b>因此使用 <code>@contextmanager</code> 装饰器时，要把 <code>yield</code> 语句放在 try/finally 语句中 (或者放在 with 语句中)。</b>
(因为我们永远不知道使用上下文管理器的用户会在 with 块中做什么)
</p>

<p>
另外，=@contextmanager= 装饰器提供的 <code>__exit__</code> 方法 <span class="underline">假定发给生成器的所有异常都得到处理了</span> ，因此应该压制异常。
如果不想让 <code>@contextmanager</code> 压制异常，必须在被装饰的函数中显式重新抛出异常。
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-orgf02367f" class="outline-3">
<h3 id="orgf02367f"><span class="section-number-3">7.6</span> 并发编程</h3>
<div class="outline-text-3" id="text-7-6">
</div>
<div id="outline-container-org5502fe0" class="outline-4">
<h4 id="org5502fe0"><span class="section-number-4">7.6.1</span> 创建子进程</h4>
<div class="outline-text-4" id="text-7-6-1">
<div class="org-src-container">
<pre class="src src-ipython">from multiprocessing import Process
import os

def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    p.start()
    p.join()  # 等待子进程结束后再继续往下运行
    print('Child process end.')
</pre>
</div>
</div>
</div>



<div id="outline-container-org400d913" class="outline-4">
<h4 id="org400d913"><span class="section-number-4">7.6.2</span> 子进程的输入输出</h4>
<div class="outline-text-4" id="text-7-6-2">
<div class="org-src-container">
<pre class="src src-ipython">import subprocess

r = subprocess.call(['nslookup', 'www.python.org'])
print('r: {}'.format(r))

p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
print(output.decode('utf-8'))
print('Exit code:', p.returncode)

# 相当于在命令行执行命令nslookup，然后手动输入：
# set q=mx
# python.org
# exit
</pre>
</div>

<pre class="example">
r: 0
Server:		64.104.123.144
Address:	64.104.123.144#53

Non-authoritative answer:
python.org	mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
org	nameserver = d0.org.afilias-nst.org.
org	nameserver = a2.org.afilias-nst.info.
org	nameserver = a0.org.afilias-nst.info.
org	nameserver = b0.org.afilias-nst.org.
org	nameserver = b2.org.afilias-nst.org.
org	nameserver = c0.org.afilias-nst.info.
a0.org.afilias-nst.info	internet address = 199.19.56.1
a2.org.afilias-nst.info	internet address = 199.249.112.1
b0.org.afilias-nst.org	internet address = 199.19.54.1
b2.org.afilias-nst.org	internet address = 199.249.120.1
c0.org.afilias-nst.info	internet address = 199.19.53.1
d0.org.afilias-nst.org	internet address = 199.19.57.1
a0.org.afilias-nst.info	has AAAA address 2001:500:e::1
a2.org.afilias-nst.info	has AAAA address 2001:500:40::1
b0.org.afilias-nst.org	has AAAA address 2001:500:c::1
b2.org.afilias-nst.org	has AAAA address 2001:500:48::1
c0.org.afilias-nst.info	has AAAA address 2001:500:b::1
d0.org.afilias-nst.org	has AAAA address 2001:500:f::1


Exit code: 0
</pre>
</div>
</div>



<div id="outline-container-org8509298" class="outline-4">
<h4 id="org8509298"><span class="section-number-4">7.6.3</span> 进程间通信</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
父进程中创建两个子进程，一个往 Queue 里写数据，一个从 Queue 里读数据：
</p>

<div class="org-src-container">
<pre class="src src-ipython">from multiprocessing import Process, Queue
import os, time, random

def write(q):
    print('Process to write: %s' % os.getpid())
    for value in ['A', 'B', 'C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())

def read(q):
    print('Process to read: %s' % os.getpid())
    while True:
        value = q.get(True)
        print('Get %s from queue.' % value)

q = Queue()
pw = Process(target=write, args=(q,))
pr = Process(target=read, args=(q,))
pw.start()
pr.start()
pw.join()
pr.terminate()  # pr 进程里是死循环，无法等待其结束，只能强行终止:
</pre>
</div>

<pre class="example">
Process to write: 92549
Put A to queue...
Process to read: 92550
Get A from queue.
Put B to queue...
Get B from queue.
Put C to queue...
Get C from queue.

</pre>
</div>
</div>



<div id="outline-container-org36062a3" class="outline-4">
<h4 id="org36062a3"><span class="section-number-4">7.6.4</span> 创建线程</h4>
<div class="outline-text-4" id="text-7-6-4">
<div class="org-src-container">
<pre class="src src-ipython">import time, threading

def worker():
    print('thread %s is running...' % threading.current_thread().name)
    time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

t = threading.Thread(target=worker, name='WorkerThread')
t.start()
t.join()
</pre>
</div>

<pre class="example">
thread WorkerThread is running...
thread WorkerThread ended.

</pre>
</div>
</div>



<div id="outline-container-org79f385c" class="outline-4">
<h4 id="org79f385c"><span class="section-number-4">7.6.5</span> 线程加锁</h4>
<div class="outline-text-4" id="text-7-6-5">
<div class="org-src-container">
<pre class="src src-ipython">import threading
from concurrent.futures import ThreadPoolExecutor

lock = threading.Lock()
count = 0

def run_thread_without_lock():
    global count
    while count &lt; 10:
        count += 1
        print("%s, " % count, end='')

def run_thread_with_lock():
    global count
    with lock:
        while count &lt; 10:
            count += 1
            print("%s, " % count, end='')

with ThreadPoolExecutor(max_workers=4) as executor:
    for i in range(5):
        executor.submit(run_thread_without_lock)

count = 0

with ThreadPoolExecutor(max_workers=4) as executor:
    for i in range(5):
        executor.submit(run_thread_with_lock)
</pre>
</div>

<pre class="example">
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,

</pre>
</div>
</div>



<div id="outline-container-org96612ca" class="outline-4">
<h4 id="org96612ca"><span class="section-number-4">7.6.6</span> thread local</h4>
<div class="outline-text-4" id="text-7-6-6">
<p>
一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。
</p>

<p>
最常用的地方就是为每个线程绑定一个数据库连接，HTTP 请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
</p>

<div class="org-src-container">
<pre class="src src-ipython">import threading, time

tl = threading.local()

def worker(name):
    tl.name = name
    time.sleep(3)
    print("in thread:", tl.name)

t = threading.Thread(target=worker, args=("hello",), name='Thread-A')
t.start()
tl.name = 'world'
print("in main:", tl.name)
</pre>
</div>

<pre class="example">
in main: world

</pre>
</div>
</div>



<div id="outline-container-orgeb1b65e" class="outline-4">
<h4 id="orgeb1b65e"><span class="section-number-4">7.6.7</span> 线程池</h4>
<div class="outline-text-4" id="text-7-6-7">
<div class="org-src-container">
<pre class="src src-ipython">from concurrent.futures import ThreadPoolExecutor
import urllib.request

def fetch_url(url):
    u = urllib.request.urlopen(url)
    data = u.read()
    return data

pool = ThreadPoolExecutor(10)
# Submit work to the pool
a = pool.submit(fetch_url, 'http://www.python.org')
b = pool.submit(fetch_url, 'http://www.pypy.org')

# Get the results back
x = a.result()
y = b.result()
</pre>
</div>

<pre class="example">
# Out[1]:

</pre>
</div>
</div>
</div>



<div id="outline-container-org4dfe418" class="outline-3">
<h3 id="org4dfe418"><span class="section-number-3">7.7</span> 元编程</h3>
<div class="outline-text-3" id="text-7-7">
</div>
<div id="outline-container-orgfe8afd5" class="outline-4">
<h4 id="orgfe8afd5"><span class="section-number-4">7.7.1</span> 控制类的属性定义的顺序</h4>
<div class="outline-text-4" id="text-7-7-1">
<div class="org-src-container">
<pre class="src src-ipython">import collections

class EntityMeta(type):

    @classmethod
    def __prepare__(cls, name, bases):
        return collections.OrderedDict()
</pre>
</div>
</div>
</div>


<div id="outline-container-org3552ece" class="outline-4">
<h4 id="org3552ece"><span class="section-number-4">7.7.2</span> 控制类的创建</h4>
<div class="outline-text-4" id="text-7-7-2">
</div>
<div id="outline-container-org115fb22" class="outline-5">
<h5 id="org115fb22"><span class="section-number-5">7.7.2.1</span> 实例缓存</h5>
<div class="outline-text-5" id="text-7-7-2-1">
<div class="org-src-container">
<pre class="src src-ipython"># Cached instances

import weakref

class Cached(type):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__cache = weakref.WeakValueDictionary()

    def __call__(self, *args):
        if args in self.__cache:
            return self.__cache[args]
        else:
            obj = super().__call__(*args)
            self.__cache[args] = obj
            return obj

class Spam(metaclass=Cached):
    def __init__(self, name):
        print('Creating Spam({!r})'.format(name))
        self.name = name

if __name__ == '__main__':
    a = Spam('foo')
    b = Spam('bar')
    print('a is b:', a is b)
    c = Spam('foo')
    print('a is c:', a is c)
</pre>
</div>

<pre class="example">
Creating Spam('foo')
Creating Spam('bar')
a is b: False
a is c: True

</pre>
</div>
</div>


<div id="outline-container-org178c163" class="outline-5">
<h5 id="org178c163"><span class="section-number-5">7.7.2.2</span> 单例</h5>
<div class="outline-text-5" id="text-7-7-2-2">
<div class="org-src-container">
<pre class="src src-ipython"># Singleton

class Singleton(type):
    def __init__(self, *args, **kwargs):
        self.__instance = None
        super().__init__(*args, **kwargs)

    def __call__(self, *args, **kwargs):
        if self.__instance is None:
            self.__instance = super().__call__(*args, **kwargs)
            return self.__instance
        else:
            return self.__instance

class Spam(metaclass=Singleton):
    def __init__(self):
        print('Creating Spam')

if __name__ == '__main__':
    a = Spam()
    b = Spam()
    print(a is b)
</pre>
</div>

<pre class="example">
Creating Spam
True

</pre>
</div>
</div>


<div id="outline-container-org3c1b318" class="outline-5">
<h5 id="org3c1b318"><span class="section-number-5">7.7.2.3</span> 禁用直接实例化</h5>
<div class="outline-text-5" id="text-7-7-2-3">
<div class="org-src-container">
<pre class="src src-ipython"># Not allowing direct instantiation

class NoInstances(type):
    def __call__(self, *args, **kwargs):
        raise TypeError("Can't instantiate directly")

class Spam(metaclass=NoInstances):
    @staticmethod
    def grok(x):
        print('Spam.grok')

if __name__ == '__main__':
    try:
        s = Spam()
    except TypeError as e:
        print(e)

    Spam.grok(42)
</pre>
</div>

<pre class="example">
Can't instantiate directly
Spam.grok

</pre>
</div>
</div>
</div>



<div id="outline-container-org6e48d73" class="outline-4">
<h4 id="org6e48d73"><span class="section-number-4">7.7.3</span> 不通过__init__方法创建实例</h4>
<div class="outline-text-4" id="text-7-7-3">
<div class="org-src-container">
<pre class="src src-ipython">from time import localtime

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Class method that bypasses __init__
    @classmethod
    def today(cls):
        d = cls.__new__(cls)
        t = localtime()
        d.year = t.tm_year
        d.month = t.tm_mon
        d.day = t.tm_mday
        return d

d = Date.__new__(Date)
print(d)
print(hasattr(d,'year'))

data = {
    'year' : 2012,
    'month' : 8,
    'day' : 29
}

d.__dict__.update(data)
print(d.year)
print(d.month)

d = Date.today()
print(d.year, d.month, d.day)
</pre>
</div>

<pre class="example">
&lt;__main__.Date object at 0x1085e1588&gt;
False
2012
8
2018 6 13

</pre>
</div>
</div>




<div id="outline-container-orga215475" class="outline-4">
<h4 id="orga215475"><span class="section-number-4">7.7.4</span> 动态定义类</h4>
<div class="outline-text-4" id="text-7-7-4">
<div class="org-src-container">
<pre class="src src-ipython"># Example of making a class manually from parts

# Methods
def __init__(self, name, shares, price):
    self.name = name
    self.shares = shares
    self.price = price

def cost(self):
    return self.shares * self.price

cls_dict = {
    '__init__' : __init__,
    'cost' : cost,
}

# Make a class
import types

Stock = types.new_class('Stock', (), {}, lambda ns: ns.update(cls_dict))

if __name__ == '__main__':
    s = Stock('ACME', 50, 91.1)
    print(s)
    print(s.cost())
</pre>
</div>

<pre class="example">
&lt;types.Stock object at 0x1085e1518&gt;
4555.0

</pre>


<div class="org-src-container">
<pre class="src src-ipython"># An alternative formulation of namedtuples

import operator
import types
import sys

def named_tuple(classname, fieldnames):
    # Populate a dictionary of field property accessors
    cls_dict = { name: property(operator.itemgetter(n))
                 for n, name in enumerate(fieldnames) }

    # Make a __new__ function and add to the class dict
    def __new__(cls, *args):
        if len(args) != len(fieldnames):
            raise TypeError('Expected {} arguments'.format(len(fieldnames)))
        return tuple.__new__(cls, (args))

    cls_dict['__new__'] = __new__

    # Make the class
    cls = types.new_class(classname, (tuple,), {},
                           lambda ns: ns.update(cls_dict))
    cls.__module__ = sys._getframe(1).f_globals['__name__']
    return cls

if __name__ == '__main__':
    Point = named_tuple('Point', ['x', 'y'])
    print(Point)
    p = Point(4, 5)
    print(len(p))
    print(p.x, p[0])
    print(p.y, p[1])
    try:
        p.x = 2
    except AttributeError as e:
        print(e)
    print('%s %s' % p)
</pre>
</div>

<pre class="example">
&lt;class '__main__.Point'&gt;
2
4 4
5 5
can't set attribute
4 5

</pre>
</div>
</div>



<div id="outline-container-org7d0d654" class="outline-4">
<h4 id="org7d0d654"><span class="section-number-4">7.7.5</span> 猴子补丁</h4>
<div class="outline-text-4" id="text-7-7-5">
<div class="org-src-container">
<pre class="src src-ipython">import importlib
import sys
from collections import defaultdict

_post_import_hooks = defaultdict(list)

class PostImportFinder:
    def __init__(self):
        self._skip = set()

    def find_module(self, fullname, path=None):
        if fullname in self._skip:
            return None
        self._skip.add(fullname)
        return PostImportLoader(self)

class PostImportLoader:
    def __init__(self, finder):
        self._finder = finder

    def load_module(self, fullname):
        importlib.import_module(fullname)
        module = sys.modules[fullname]
        for func in _post_import_hooks[fullname]:
            func(module)
        self._finder._skip.remove(fullname)
        return module

def when_imported(fullname):
    def decorate(func):
        if fullname in sys.modules:
            func(sys.modules[fullname])
        else:
            _post_import_hooks[fullname].append(func)
        return func
    return decorate

sys.meta_path.insert(0, PostImportFinder())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">@when_imported('threading')
def warn_threads(mod):
    print('Threads? Are you crazy?')

import threading
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org5ede079" class="outline-2">
<h2 id="org5ede079"><span class="section-number-2">8</span> 参考文档</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li><a href="https://docs.python.org/3/library/stdtypes.html#truth">真值检验标准</a></li>

<li><a href="https://docs.python.org/3/reference/datamodel.html">特殊方法</a></li>

<li><a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes">collection.abc 中各个抽象基类的总结</a></li>

<li><a href="https://docs.python.org/3/library/numbers.html">numbers 包</a></li>

<li><a href="https://docs.python.org/dev/library/exceptions.html#exception-hierarchy">异常层次结构</a></li>

<li><a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup">特殊方法查找</a> <a id="orgc1760e3"></a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hao Ruan</p>
<p class="date">Created: 2019-05-10 Fri 16:18</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>