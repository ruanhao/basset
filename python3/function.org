#+TITLE:     Function
#+AUTHOR:    Hao Ruan
#+EMAIL:     ruanhao1116@gmail.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/style.css" />
#+OPTIONS:   H:2 num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t
#+STARTUP:   showall

* 一，基本知识

** 1.1，使用默认参数的注意事项

定义默认参数时，默认参数必须指向不可变对象

#+BEGIN_SRC python
  def add_end(L=[]):
      L.append('END')
      return L

  add_end()                       # ['END']
  add_end()                       # ['END', 'END']
  add_end()                       # ['END', 'END', 'END']
#+END_SRC

原因：

函数在定义的时候，默认参数 L 的值就被计算出来了，即 [] ，因为默认参数 L 也是一个变量，它指向对象 [] ，\\
每次调用该函数，如果改变了 L 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 [] 了。

修改上面的例子，可以用 None 这个不可变对象来实现：

#+BEGIN_SRC python
  def add_end(L=None):
      if L is None:
          L = []
      L.append('END')
      return L
#+END_SRC


** 1.2，命名关键字参数

可以用于限制关键字参数的名字\\
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

#+BEGIN_SRC python
  # 只接收 city 和 job 作为关键字参数
  def person(name, age, *, city, job):             # 命名关键字参数需要一个特殊分隔符 *
      print(name, age, city, job)                  # * 后面的参数被视为命名关键字参数

  def person2(name, age, *, city='Beijing', job):  # 可以有默认值
      print(name, age, city, job)

  # 调用方式：
  person('Jack', 24, city='Beijing', job='Engineer')
#+END_SRC

#+BEGIN_SRC python
  # 如果函数定义中已经有了一个可变参数
  # 后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了
  def person(name, age, *args, city, job):
      print(name, age, args, city, job)
#+END_SRC


** 1.3，参数组合顺序

在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。\\
组合参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。


** 1.4，使用闭包的陷阱

#+BEGIN_SRC python
  def count():
      fs = []
      for i in range(1, 4):
          def f():
               return i*i
          fs.append(f)
      return fs

  f1, f2, f3 = count()
  f1()                            # 9
  f2()                            # 9
  f3()                            # 9
#+END_SRC

原因在于返回的函数引用了变量 i，但它并非立刻执行。\\
等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，因此最终结果为 9。

返回闭包时需注意： *返回函数中不要引用任何可能会变化的变量*

如果一定要引用会变化的变量，可以再创建一个函数：

#+BEGIN_SRC python
  def count():
      def f(j):
          def g():
              return j*j
          return g
      fs = []
      for i in range(1, 4):
          fs.append(f(i))
      return fs
#+END_SRC

** 1.5，Lambda 表达式（匿名函数）

匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果

** 1.6，装饰器

在代码运行期间动态增加函数功能的方式，称之为“装饰器”（Decorator）。\\
本质上，Decorator 就是一个返回函数的高阶函数。\\
Python 的 Decorator 可以用函数实现，也可以用类实现。

** 1.7，偏函数

当函数的参数个数太多，需要简化时，使用 functools.partial 可以创建一个新的函数。\\
这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

* 二，常见用法

- 创建装饰器

  - 不带参数的装饰器

    #+BEGIN_SRC python
      import functools

      def log(func):
          @functools.wraps(func)      # 把原始函数的 __name__ 等属性复制到 wrapper 函数中
          def wrapper(*args, **kw):   # 可以接受任意参数的调用
              print('call %s():' % func.__name__)
              return func(*args, **kw)
          return wrapper
    #+END_SRC

    #+BEGIN_SRC python
      @log
      def now():                      # 相当于：now = log(now)
          print('2017-01-26')
    #+END_SRC

  - 带参数的装饰器

      #+BEGIN_SRC python
        import functools

        def log(text):
            def decorator(func):
                @functools.wraps(func)
                def wrapper(*args, **kw):
                    print('%s %s():' % (text, func.__name__))
                    return func(*args, **kw)
                return wrapper
            return decorator
      #+END_SRC

      #+BEGIN_SRC python
        @log('execute')
        def now():                      # 相当于：now = log('execute')(now)
            print('2015-3-25')          # log('execute') 返回的还是一个装饰器
      #+END_SRC

- 创建偏函数

  #+BEGIN_SRC python
    import functools
    int2 = functools.partial(int, base=2)
    int2('1000000')                 # 64
    int2('1010101')                 # 85

    # 上面新的 int2 函数，仅仅是把 base 参数重新设定默认值为2
    # 也可以在函数调用时传入其他值：
    int2('1000000', base=10)        # 1000000
  #+END_SRC
