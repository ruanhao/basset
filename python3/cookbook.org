#+TITLE:     代码仓库
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 3
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
 #+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>


* 类

** 不调用 =__init__= 方法来创建实例

#+BEGIN_SRC ipython :session :exports both :results output
  from time import localtime

  class Date:
      def __init__(self, year, month, day):
          self.year = year
          self.month = month
          self.day = day

      # Class method that bypasses __init__
      @classmethod
      def today(cls):
          d = cls.__new__(cls)
          t = localtime()
          d.year = t.tm_year
          d.month = t.tm_mon
          d.day = t.tm_mday
          return d

  d = Date.__new__(Date)
  print(d)
  print(hasattr(d,'year'))

  data = {
      'year' : 2012,
      'month' : 8,
      'day' : 29
  }

  d.__dict__.update(data)
  print(d.year)
  print(d.month)

  d = Date.today()
  print(d.year, d.month, d.day)
#+END_SRC


** 创建缓存对象

#+BEGIN_SRC ipython :session :exports both :results output
  class Spam:
      def __init__(self, name):
          self.name = name

  # Caching support
  import weakref
  _spam_cache = weakref.WeakValueDictionary()

  def get_spam(name):
      if name not in _spam_cache:
          s = Spam(name)
          _spam_cache[name] = s
      else:
          s = _spam_cache[name]
      return s

  if __name__ == '__main__':
      a = get_spam('foo')
      b = get_spam('bar')
      print('a is b:', a is b)
      c = get_spam('foo')
      print('a is c:', a is c)
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  import weakref

  class CachedSpamManager:
      def __init__(self):
          self._cache = weakref.WeakValueDictionary()
      def get_spam(self, name):
          if name not in self._cache:
              s = Spam(name)
              self._cache[name] = s
          else:
              s = self._cache[name]
          return s

  class Spam:
      def __init__(self, name):
          self.name = name

  Spam.manager = CachedSpamManager()

  def get_spam(name):
      return Spam.manager.get_spam(name)

  if __name__ == '__main__':
      a = get_spam('foo')
      b = get_spam('bar')
      print('a is b:', a is b)
      c = get_spam('foo')
      print('a is c:', a is c)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  # Example involving new and some of its problems

  import weakref

  class Spam:
      _spam_cache = weakref.WeakValueDictionary()
      def __new__(cls, name):
          if name in cls._spam_cache:
              return cls._spam_cache[name]
          else:
              self = super().__new__(cls)
              cls._spam_cache[name] = self
              return self

      def __init__(self, name):
          print('Initializing Spam')
          self.name = name

  if __name__ == '__main__':
      print("This should print 'Initializing Spam' twice")
      s = Spam('Dave')
      t = Spam('Dave')
      print(s is t)
#+END_SRC

** 抽象类

#+BEGIN_SRC ipython :session :exports both :results output
  from abc import ABCMeta, abstractmethod

  class A(metaclass=ABCMeta):
      @property
      @abstractmethod
      def name(self):
          pass

      @name.setter
      @abstractmethod
      def name(self, value):
          pass

      @classmethod
      @abstractmethod
      def method1(cls):
          pass

      @staticmethod
      @abstractmethod
      def method2():
          pass
#+END_SRC


** 动态定义类

#+BEGIN_SRC ipython :session :exports both :results output
  # Example of making a class manually from parts

  # Methods
  def __init__(self, name, shares, price):
      self.name = name
      self.shares = shares
      self.price = price

  def cost(self):
      return self.shares * self.price

  cls_dict = {
      '__init__' : __init__,
      'cost' : cost,
  }

  # Make a class
  import types

  Stock = types.new_class('Stock', (), {}, lambda ns: ns.update(cls_dict))

  if __name__ == '__main__':
      s = Stock('ACME', 50, 91.1)
      print(s)
      print(s.cost())
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  # An alternative formulation of namedtuples

  import operator
  import types
  import sys

  def named_tuple(classname, fieldnames):
      # Populate a dictionary of field property accessors
      cls_dict = { name: property(operator.itemgetter(n))
                   for n, name in enumerate(fieldnames) }

      # Make a __new__ function and add to the class dict
      def __new__(cls, *args):
          if len(args) != len(fieldnames):
              raise TypeError('Expected {} arguments'.format(len(fieldnames)))
          return tuple.__new__(cls, (args))

      cls_dict['__new__'] = __new__

      # Make the class
      cls = types.new_class(classname, (tuple,), {},
                             lambda ns: ns.update(cls_dict))
      cls.__module__ = sys._getframe(1).f_globals['__name__']
      return cls

  if __name__ == '__main__':
      Point = named_tuple('Point', ['x', 'y'])
      print(Point)
      p = Point(4, 5)
      print(len(p))
      print(p.x, p[0])
      print(p.y, p[1])
      try:
          p.x = 2
      except AttributeError as e:
          print(e)
      print('%s %s' % p)
#+END_SRC


** 使用元类控制类的创建

*** 实例缓存

#+BEGIN_SRC ipython :session :exports both :results output
  # Cached instances

  import weakref

  class Cached(type):
      def __init__(self, *args, **kwargs):
          super().__init__(*args, **kwargs)
          self.__cache = weakref.WeakValueDictionary()

      def __call__(self, *args):
          if args in self.__cache:
              return self.__cache[args]
          else:
              obj = super().__call__(*args)
              self.__cache[args] = obj
              return obj

  class Spam(metaclass=Cached):
      def __init__(self, name):
          print('Creating Spam({!r})'.format(name))
          self.name = name

  if __name__ == '__main__':
      a = Spam('foo')
      b = Spam('bar')
      print('a is b:', a is b)
      c = Spam('foo')
      print('a is c:', a is c)
#+END_SRC


*** 单例

#+BEGIN_SRC ipython :session :exports both :results output
  # Singleton

  class Singleton(type):
      def __init__(self, *args, **kwargs):
          self.__instance = None
          super().__init__(*args, **kwargs)

      def __call__(self, *args, **kwargs):
          if self.__instance is None:
              self.__instance = super().__call__(*args, **kwargs)
              return self.__instance
          else:
              return self.__instance

  class Spam(metaclass=Singleton):
      def __init__(self):
          print('Creating Spam')

  if __name__ == '__main__':
      a = Spam()
      b = Spam()
      print(a is b)
#+END_SRC


*** 禁用直接实例化

#+BEGIN_SRC ipython :session :exports both :results output
  # Not allowing direct instantiation

  class NoInstances(type):
      def __call__(self, *args, **kwargs):
          raise TypeError("Can't instantiate directly")

  class Spam(metaclass=NoInstances):
      @staticmethod
      def grok(x):
          print('Spam.grok')

  if __name__ == '__main__':
      try:
          s = Spam()
      except TypeError as e:
          print(e)

      Spam.grok(42)
#+END_SRC


* 进程与多线程

** 创建子进程

#+BEGIN_SRC ipython :session :exports both :results output
  from multiprocessing import Process
  import os

  def run_proc(name):
      print('Run child process %s (%s)...' % (name, os.getpid()))

  if __name__=='__main__':
      print('Parent process %s.' % os.getpid())
      p = Process(target=run_proc, args=('test',))
      print('Child process will start.')
      p.start()
      p.join()  # 等待子进程结束后再继续往下运行
      print('Child process end.')
#+END_SRC


** 子进程的输入输出

#+BEGIN_SRC ipython :session :exports both :results output
  import subprocess

  r = subprocess.call(['nslookup', 'www.python.org'])
  print('r: {}'.format(r))

  p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
  print(output.decode('utf-8'))
  print('Exit code:', p.returncode)

  # 相当于在命令行执行命令nslookup，然后手动输入：
  # set q=mx
  # python.org
  # exit
#+END_SRC


** 进程间通信

父进程中创建两个子进程，一个往 Queue 里写数据，一个从 Queue 里读数据：

#+BEGIN_SRC ipython :session :exports both :results output
  from multiprocessing import Process, Queue
  import os, time, random

  def write(q):
      print('Process to write: %s' % os.getpid())
      for value in ['A', 'B', 'C']:
          print('Put %s to queue...' % value)
          q.put(value)
          time.sleep(random.random())

  def read(q):
      print('Process to read: %s' % os.getpid())
      while True:
          value = q.get(True)
          print('Get %s from queue.' % value)

  q = Queue()
  pw = Process(target=write, args=(q,))
  pr = Process(target=read, args=(q,))
  pw.start()
  pr.start()
  pw.join()
  pr.terminate()  # pr 进程里是死循环，无法等待其结束，只能强行终止:
#+END_SRC


** 创建线程

#+BEGIN_SRC ipython :session :exports both :results output
  import time, threading

  def worker():
      print('thread %s is running...' % threading.current_thread().name)
      time.sleep(1)
      print('thread %s ended.' % threading.current_thread().name)

  t = threading.Thread(target=worker, name='WorkerThread')
  t.start()
  t.join()
#+END_SRC


** 线程加锁

#+BEGIN_SRC ipython :session :exports both :results output
  import threading
  from concurrent.futures import ThreadPoolExecutor

  lock = threading.Lock()
  count = 0

  def run_thread_without_lock():
      global count
      while count < 10:
          count += 1
          print("\x1b[31m%s\x1b[0m, " % count, end='')

  def run_thread_with_lock():
      global count
      with lock:
          while count < 10:
              count += 1
              print("%s, " % count, end='')

  with ThreadPoolExecutor(max_workers=4) as executor:
      for i in range(5):
          executor.submit(run_thread_without_lock)

  count = 0

  with ThreadPoolExecutor(max_workers=4) as executor:
      for i in range(5):
          executor.submit(run_thread_with_lock)
#+END_SRC


** thread local 变量

一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。

最常用的地方就是为每个线程绑定一个数据库连接，HTTP 请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。

#+BEGIN_SRC ipython :session :exports both :results output
  import threading, time

  tl = threading.local()

  def worker(name):
      tl.name = name
      time.sleep(3)
      print("in thread:", tl.name)

  t = threading.Thread(target=worker, args=("hello",), name='Thread-A')
  t.start()
  tl.name = 'world'
  print("in main:", tl.name)
#+END_SRC


** 线程池

#+BEGIN_SRC ipython
  from concurrent.futures import ThreadPoolExecutor
  import urllib.request

  def fetch_url(url):
      u = urllib.request.urlopen(url)
      data = u.read()
      return data

  pool = ThreadPoolExecutor(10)
  # Submit work to the pool
  a = pool.submit(fetch_url, 'http://www.python.org')
  b = pool.submit(fetch_url, 'http://www.pypy.org')

  # Get the results back
  x = a.result()
  y = b.result()
#+END_SRC


* 数据结构

** 列表

*** 列表中出现频率最高

#+BEGIN_SRC ipython :session :exports both :results output
  words = [
     'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
     'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
     'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
     'my', 'eyes', "you're", 'under'
  ]

  from collections import Counter
  word_counts = Counter(words)
  top_three = word_counts.most_common(3)
  print(top_three)
#+END_SRC


*** 列表中最大或最小的几项

#+BEGIN_SRC ipython :session :exports both :results output
  import heapq

  portfolio = [
     {'name': 'IBM', 'shares': 100, 'price': 91.1},
     {'name': 'AAPL', 'shares': 50, 'price': 543.22},
     {'name': 'FB', 'shares': 200, 'price': 21.09},
     {'name': 'HPQ', 'shares': 35, 'price': 31.75},
     {'name': 'YHOO', 'shares': 45, 'price': 16.35},
     {'name': 'ACME', 'shares': 75, 'price': 115.65}
  ]

  cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
  expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
  r = {'cheap': cheap, 'expensive': expensive}
  print(r)
#+END_SRC


***  对列表中的数据分组

#+BEGIN_SRC ipython :session :exports both :results output
  rows = [
      {'address': '5412 N CLARK', 'date': '07/01/2012'},
      {'address': '5148 N CLARK', 'date': '07/04/2012'},
      {'address': '5800 E 58TH', 'date': '07/02/2012'},
      {'address': '2122 N CLARK', 'date': '07/03/2012'},
      {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
      {'address': '1060 W ADDISON', 'date': '07/02/2012'},
      {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
      {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
  ]

  from itertools import groupby

  rows.sort(key=lambda r: r['date'])
  for date, items in groupby(rows, key=lambda r: r['date']):
      print(date)
      for i in items:
          print('    ', i)
#+END_SRC

或者使用 defaultdict 来实现：

#+BEGIN_SRC ipython :session :exports both :results output
  from collections import defaultdict
  rows_by_date = defaultdict(list)
  for row in rows:
      rows_by_date[row['date']].append(row)
  print(rows_by_date)
#+END_SRC


*** 消除序列中的重复数据，同时保持数据顺序

#+BEGIN_SRC ipython :session :exports both :results output
  def dedupe(items, key=None):
      seen = set()
      for item in items:
          val = item if key is None else key(item)
          if val not in seen:
              yield item
              seen.add(val)


  a = [
          {'x': 2, 'y': 3},
          {'x': 1, 'y': 4},
          {'x': 2, 'y': 3},
          {'x': 2, 'y': 3},
          {'x': 10, 'y': 15}
      ]
  print(list(dedupe(a, key=lambda a: (a['x'],a['y']))))
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  def dedupe(items):
      seen = set()
      for item in items:
          if item not in seen:
              yield item
              seen.add(item)

  a = [1, 5, 2, 1, 9, 1, 5, 10]
  print(list(dedupe(a)))
#+END_SRC


*** 序列解包 (unpack)

#+BEGIN_SRC ipython :session :exports both :results output
  records = [
       ('foo', 1, 2),
       ('bar', 'hello'),
       ('foo', 3, 4),
  ]

  def do_foo(x,y):
      print('foo', x, y)

  def do_bar(s):
      print('bar', s)

  for tag, *args in records:
      if tag == 'foo':
          do_foo(*args)
      elif tag == 'bar':
          do_bar(*args)
#+END_SRC


*** flatten 列表

#+BEGIN_SRC ipython :session :exports both :results output
  from collections import Iterable

  def flatten(items, ignore_types=(str, bytes)):
      for x in items:
          if isinstance(x, Iterable) and not isinstance(x, ignore_types):
              yield from flatten(x)
          else:
              yield x

  items = [1, 2, [3, 4, [5, 6], 7], 8]

  # Produces 1 2 3 4 5 6 7 8
  for x in flatten(items):
      print(x)

  items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
  for x in flatten(items):
      print(x)

#+END_SRC


** 字典

*** 对字典作集合运算

#+BEGIN_SRC ipython :session :exports both :results output
  a = {
     'x' : 1,
     'y' : 2,
     'z' : 3
  }

  b = {
     'w' : 10,
     'x' : 11,
     'y' : 2
  }

  print('Common keys:', a.keys() & b.keys())
  print('Keys in a not in b:', a.keys() - b.keys())
  print('(key,value) pairs in common:', a.items() & b.items())
#+END_SRC


*** 组合多个字典当作一个字典使用

#+BEGIN_SRC ipython :session :exports both :results output
  a = {'x': 1, 'z': 3 }
  b = {'y': 2, 'z': 4 }

  # (a) Simple example of combining
  from collections import ChainMap
  c = ChainMap(a,b)

  print("c:", c)

  print(c['x'])      # Outputs 1  (from a)
  print(c['y'])      # Outputs 2  (from b)
  print(c['z'])      # Outputs 3  (from a)

  # Output some common values
  print('len(c):', len(c))
  print('c.keys():', list(c.keys()))
  print('c.values():', list(c.values()))

  # Modify some values
  c['z'] = 10
  c['w'] = 40
  del c['x']
  print("a:", a)
#+END_SRC


*** 字典栈

#+BEGIN_SRC ipython :session :exports both :results output
  # Example of stacking mappings (like scopes)
  values = ChainMap()
  values['x'] = 1

  # Add a new mapping
  values = values.new_child()
  values['x'] = 2

  # Add a new mapping
  values = values.new_child()
  values['x'] = 3

  print(values)
  print(values['x'])

  # Discard last mapping
  values = values.parents
  print(values)
  print(values['x'])

  # Discard last mapping
  values = values.parents
  print(values)
  print(values['x'])
#+END_SRC


** 队列

*** 优先队列

#+BEGIN_SRC ipython :session :exports both :results output
  import heapq

  class PriorityQueue:
      def __init__(self):
          self._queue = []
          self._index = 0

      def push(self, item, priority):
          heapq.heappush(self._queue, (-priority, self._index, item))
          self._index += 1

      def pop(self):
          return heapq.heappop(self._queue)[-1]

  # Example use
  class Item:
      def __init__(self, name):
          self.name = name
      def __repr__(self):
          return 'Item({!r})'.format(self.name)

  q = PriorityQueue()
  q.push(Item('foo'), 1)
  q.push(Item('bar'), 5)
  q.push(Item('spam'), 4)
  q.push(Item('grok'), 1)

  print("Should be bar:", q.pop())
  print("Should be spam:", q.pop())
  print("Should be foo:", q.pop())
  print("Should be grok:", q.pop())
#+END_SRC




* IO

** 文件

*** 将文件描述符包装成文件对象

#+BEGIN_SRC ipython
  from socket import socket, AF_INET, SOCK_STREAM

  def echo_client(client_sock, addr):
      print("Got connection from", addr)

      # Make text-mode file wrappers for socket reading/writing
      client_in = open(client_sock.fileno(), 'rt', encoding='latin-1', closefd=False)
      client_out = open(client_sock.fileno(), 'wt', encoding='latin-1', closefd=False)

      # Echo lines back to the client using file I/O
      for line in client_in:
          client_out.write(line)
          client_out.flush()
      client_sock.close()

  def echo_server(address):
      sock = socket(AF_INET, SOCK_STREAM)
      sock.bind(address)
      sock.listen(1)
      while True:
          client, addr = sock.accept()
          echo_client(client, addr)

  print('Echo serving running on localhost:25000')
  echo_server(('', 25000))
#+END_SRC

*** 改变已打开文件的编码方式

#+BEGIN_SRC ipython
  # Example of adding a text encoding to existing file-like object

  import urllib.request
  import io

  u = urllib.request.urlopen('http://www.python.org')
  f = io.TextIOWrapper(u, encoding='utf-8')
  text = f.read()

  print(text)
#+END_SRC


** 内存 IO

*** 内存字符串

#+BEGIN_SRC ipython :session :exports both :results output
  from io import StringIO
  f = StringIO()
  f.write('hello')
  f.write(' ')
  f.write('world!')
  print(f.getvalue())
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  f = StringIO('Hello!\nHi!\nGoodbye!')
  while True:
      s = f.readline()
      if s == '':  # eof
          break
      print(s, end='')
#+END_SRC


*** 内存比特流

#+BEGIN_SRC ipython :session :exports both :results output
  from io import BytesIO
  f = BytesIO()
  f.write('中文'.encode('utf-8'))
  print(f.getvalue())
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
  r = f.read().decode('utf-8')
  print(r)
#+END_SRC



** 读写 JSON

#+BEGIN_SRC ipython :session :exports both :results output
  # Some advanced JSON examples involving ordered dicts and classes
  import json

  # Some JSON encoded text
  s = '{"name": "ACME", "shares": 50, "price": 490.1}'

  # (a) Turning JSON into an OrderedDict

  from collections import OrderedDict
  data = json.loads(s, object_pairs_hook=OrderedDict)
  print(data)

  # (b) Using JSON to populate an instance

  class JSONObject:
      def __init__(self, d):
          self.__dict__ = d

  data = json.loads(s, object_hook=JSONObject)
  print(data.name)
  print(data.shares)
  print(data.price)

  # (c) Encoding instances

  class Point:
      def __init__(self, x, y):
          self.x = x
          self.y = y

  def serialize_instance(obj):
      d = { '__classname__' : type(obj).__name__ }
      d.update(vars(obj))
      return d

  p = Point(3,4)
  s = json.dumps(p, default=serialize_instance)
  print(s)

  # (d) Decoding instances
  classes = {
      'Point' : Point
  }

  def unserialize_object(d):
      clsname = d.pop('__classname__', None)
      if clsname:
          cls = classes[clsname]
          obj = cls.__new__(cls)
          for key, value in d.items():
              setattr(obj, key, value)
          return obj
      else:
          return d

  a = json.loads(s, object_hook=unserialize_object)
  print(a)
  print(a.x)
  print(a.y)
#+END_SRC


* 模块

** 猴子补丁

#+BEGIN_SRC ipython :session :exports both :results output
  import importlib
  import sys
  from collections import defaultdict

  _post_import_hooks = defaultdict(list)

  class PostImportFinder:
      def __init__(self):
          self._skip = set()

      def find_module(self, fullname, path=None):
          if fullname in self._skip:
              return None
          self._skip.add(fullname)
          return PostImportLoader(self)

  class PostImportLoader:
      def __init__(self, finder):
          self._finder = finder

      def load_module(self, fullname):
          importlib.import_module(fullname)
          module = sys.modules[fullname]
          for func in _post_import_hooks[fullname]:
              func(module)
          self._finder._skip.remove(fullname)
          return module

  def when_imported(fullname):
      def decorate(func):
          if fullname in sys.modules:
              func(sys.modules[fullname])
          else:
              _post_import_hooks[fullname].append(func)
          return func
      return decorate

  sys.meta_path.insert(0, PostImportFinder())
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  @when_imported('threading')
  def warn_threads(mod):
      print('Threads? Are you crazy?')

  import threading
#+END_SRC


** 将模块拆分出多个文件

模块 mymodule 目录结构：

#+BEGIN_EXAMPLE
  mymodule
  ├── __init__.py
  ├── a.py
  └── b.py
#+END_EXAMPLE

=__init__.py= 文件内容:

#+BEGIN_EXAMPLE
  from .a import A
  from .b import B
#+END_EXAMPLE

=a.py= 文件内容：

#+BEGIN_EXAMPLE
  class A:
      def spam(self):
          print('A.spam')
#+END_EXAMPLE

=b.py= 文件内容：

#+BEGIN_EXAMPLE
  from .a import A

  class B(A):
      def bar(self):
          print('B.bar')
#+END_EXAMPLE

#+BEGIN_SRC ipython :session :exports both :results output
  import mymodule
  a = mymodule.A()
  a.spam()

  b = mymodule.B()
  b.bar()
#+END_SRC


* 数字，日期，时间

** time 模块

time 模块始终返回 UTC 时间。

*** 获取 Unix Timestamp

即从 Epoch (1970年1月1日00:00:00 UTC) 开始所经过的秒数。

#+BEGIN_SRC ipython :session :exports both :results output
  import time
  print(time.time())
#+END_SRC

*** 获取具体时间值

#+BEGIN_SRC ipython :session :exports both :results output
  current_time = time.time()
  current_struct_time = time.gmtime(current_time)
  print(current_struct_time)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  current_year = current_struct_time.tm_year
  current_mon  = current_struct_time.tm_mon
  current_mday = current_struct_time.tm_mday
  current_hour = current_struct_time.tm_hour
  current_min  = current_struct_time.tm_min
  r = (current_year, current_mon, current_mday, current_hour, current_min)
  print(r)
#+END_SRC

** datetime 模块

datetime 模块简化了日期操作，如增加天数，设置时区等。

*** 创建时间

#+BEGIN_SRC ipython :session :exports both :results output
  import datetime
  d = datetime.datetime(year=2017, month=12, day=31, hour=12, minute=59, second=59)
  r = (d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond)
  print(r)
#+END_SRC


*** 获取 UTC 时间

#+BEGIN_SRC ipython :session :exports both :results output
  print(datetime.datetime.utcnow())
#+END_SRC


*** 获取当前时区时间

#+BEGIN_SRC ipython :session :exports both :results output
  print(datetime.datetime.now())
#+END_SRC

*** 日期运算

#+BEGIN_SRC ipython :session :exports both :results output
  today = datetime.datetime.now()
  diff = datetime.timedelta(weeks=3, days=2)
  future = today + diff
  past = today - diff
  print((future, past))
#+END_SRC


*** 日期转字符串

#+BEGIN_SRC ipython :session :exports both :results output
  r = '{:%Y-%m-%d %H:%M}'.format(datetime.datetime(2001, 2, 3, 4, 5))
  print(r)
#+END_SRC


*** 字符串转日期

#+BEGIN_SRC ipython :session :exports both :results output
  r = datetime.datetime.strptime("Mar 03, 2010", "%b %d, %Y")
  print(r)
#+END_SRC

** 月份缩写

#+BEGIN_SRC ipython :session :exports both :results output
  from calendar import month_abbr
  print(list(month_abbr))
#+END_SRC


** 数字精度格式化

#+BEGIN_SRC ipython :session :exports both :results output
  print('{:06.2f}'.format(3.141592653589793))
  print('{:04d}'.format(42))
  print('{:+d}'.format(42))
  print('{: d}'.format(42))
  print('{: d}'.format(-42))
  print('{:=5d}'.format((- 23)))
  print('{:=+5d}'.format((23)))

#+END_SRC


* 字符串与文本

** 格式化

*** 填充与对齐

#+BEGIN_SRC ipython :session :exports both :results output
  print('{:>10}'.format('test'))
  print('{:10}'.format('test'))
  print('{:^10}'.format('test'))
  print('{:_<10}'.format('test'))
#+END_SRC


*** 字符串截断

#+BEGIN_SRC ipython :session :exports both :results output
  print('{:.5}'.format('xylophone'))
  print('{:10.5}'.format('xylophone'))
#+END_SRC


*** 占位符

#+BEGIN_SRC ipython :session :exports both :results output
  data = {'first': 'Hodor', 'last': 'Hodor!'}
  print('{first} {last}'.format(**data))

  print('{first} {last}'.format(first='Hodor', last='Hodor!'))
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  person = {'first': 'Jean-Luc', 'last': 'Picard'}
  data = [4, 8, 15, 16, 23, 42]
  class Plant(object):
      category = 'tree'
      kinds = [{'name': 'oak'}, {'name': 'maple'}]

  print('{p[first]} {p[last]}'.format(p=person))
  print('{d[4]} {d[5]}'.format(d=data))
  print('{p.category}: {p.kinds[0][name]}'.format(p=Plant()))
#+END_SRC



*** 排版

#+BEGIN_SRC ipython :session :exports both :results output
  import textwrap

  s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
  the eyes, not around the eyes, don't look around the eyes, \
  look into my eyes, you're under."

  print(textwrap.fill(s, 70))
  print()

  print(textwrap.fill(s, 40))
  print()

  print(textwrap.fill(s, 40, initial_indent='    '))
  print()

  print(textwrap.fill(s, 40, subsequent_indent='    '))
  print()
#+END_SRC

** 字符串匹配

*** 使用 shell 风格的通配符匹配字符串

#+BEGIN_SRC ipython :session :exports both :results output
  from fnmatch import fnmatchcase as match

  addresses = [
      '5412 N CLARK ST',
      '1060 W ADDISON ST',
      '1039 W GRANVILLE AVE',
      '2122 N CLARK ST',
      '4802 N BROADWAY',
  ]

  a = [addr for addr in addresses if match(addr, '* ST')]
  print(a)

  b = [addr for addr in addresses if match(addr, '54[0-9][0-9] *CLARK*')]
  print(b)
#+END_SRC


*** 贪婪和非贪婪匹配

#+BEGIN_SRC ipython :session :exports both :results output
  import re

  # Sample text
  text = 'Computer says "no." Phone says "yes."'

  # (a) Regex that finds quoted strings - longest match
  str_pat = re.compile(r'\"(.*)\"')
  print(str_pat.findall(text))

  # (b) Regex that finds quoted strings - shortest match
  str_pat = re.compile(r'\"(.*?)\"')
  print(str_pat.findall(text))
#+END_SRC


** 密码输入

#+BEGIN_SRC ipython
  import getpass

  user = getpass.getuser()
  passwd = getpass.getpass()

  print('User:', user)
  print('Passwd:', passwd)
#+END_SRC


* 参考资料