#+TITLE:     Pandas
#+AUTHOR:    Hao Ruan
#+EMAIL:     haoru@cisco.com
#+LANGUAGE:  en
#+LINK_HOME: http://www.github.com/ruanhao
#+OPTIONS:   h:6 html-postamble:nil html-preamble:t tex:t f:t ^:nil
#+STARTUP:   showall
#+TOC:       headlines 4
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="../org-html-themes/css/style.css" rel="stylesheet" type="text/css" />
#+HTML: <div class="outline-2" id="meta">
| Author   | {{{author}}} ({{{email}}})    |
| Date     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
#+HTML: </div>

#+BEGIN_SRC ipython :session :exports none
  #! /usr/bin/env python3
  # -*- coding: utf-8 -*-


  import pandas as pd
  import numpy as np
  import matplotlib.pyplot as plt
  import subprocess
  from PIL import Image

  def run_script(script):
      """Returns (stdout, stderr), raises error on non-zero return code"""
      proc = subprocess.Popen(['bash', '-c', script],
                              stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                              stdin=subprocess.PIPE)
      stdout, stderr = proc.communicate()
      if proc.returncode:
          raise Exception('exit code %s' % proc.returncode)
      return stdout, stderr

  def show_dataframe(df):
      global path
      df.to_html("/tmp/df.html")
      run_script('webkit2png -F --transparent /tmp/df.html -D /tmp -o df')
      # try:
      #     subprocess.call('webkit2png -F --transparent /tmp/df.html -D /tmp -o df', shell=True, timeout=5)
      # except:
      #     pass
      image = Image.open('/tmp/df-full.png')
      box = image.getbbox()
      cropped = image.crop(box)
      image.close()
      w = cropped.size[0]
      h = cropped.size[1]
      ratio = 0.618
      cropped.thumbnail((int(w*ratio), int(h*ratio)), Image.ANTIALIAS)
      cropped.save(path)
      cropped.close()

  def show_fig(o):
      global path
      plt.clf()
      o.plot()
      plt.savefig(path)


  def log(title0, value):
      title1 = ' ' + title0 + ' '
      print("{}\n{}".format(title1.center(80, '='), value))
#+END_SRC

* 核心数据结构

** Series

Series 是一维带标签的数组，数组里可以放任意的数据（整数，浮点数，字符串，Python Object）。

其基本的创建函数是： =pd.Series(data, index=index)=

其中 index 是一个列表，用来作为数据的标签。data 可以是不同的数据类型：

- Python 字典
- ndarray 对象
- 一个标量值，如 5

*** 创建

**** 从 ndarray 创建

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
  log("s", s)
  log("s.index", s.index)
  s2 = pd.Series(np.random.randn(5))
  log("s2", s2)
  log("s2.index", s2.index)
#+END_SRC

**** 从字典创建

#+BEGIN_SRC ipython :session :exports both :results output
  d = {'a' : 0., 'b' : 1., 'd' : 3}
  s = pd.Series(d, index=list('abcd'))
  log("s", s)
#+END_SRC

**** 从标量创建

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(3, index=list('abcde'))
  log("s", s)
#+END_SRC


*** 特性

**** 类 ndarray 对象

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.randn(5))

  log("s[0]", s[0])
  log("s[:3]", s[:3])
  log("s[[1, 3, 4]]", s[[1, 3, 4]])
  log("np.exp(s)", np.exp(s))
  log("np.sin(s)", np.sin(s))
#+END_SRC


**** 类字典对象

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
  s['e'] = 5
  log("s", s)
  log("'e' in s", 'e' in s)
  log("s.get('f', np.nan)", s.get('f', np.nan))
#+END_SRC


**** 标签对齐

相同索引值才进行操作

#+BEGIN_SRC ipython :session :exports both :results output
  s1 = pd.Series(np.random.randn(3), index=['a', 'c', 'e'])
  s2 = pd.Series(np.random.randn(3), index=['a', 'd', 'e'])

  log("s1", s1)
  log("s2", s2)


  log("s1 + s2", s1 + s2)
#+END_SRC


** DataFrame

DataFrame 是 *二维带行标签和列标签的数组* 。

可以把 DataFrame 想象成一个 Excel 表格或一个 SQL 数据库的表格，还可以想象成是一个 Series 对象字典。

它是 Pandas 里最常用的数据结构。

创建 DataFrame 的基本格式是：

#+BEGIN_SRC ipython
  pd.DataFrame(data, index=index, columns=columns)
#+END_SRC

其中 index 是行标签，columns 是列标签，data 可以是下面的数据：

- 由一维 numpy 数组，list，Series 构成的字典
- 二维 numpy 数组
- 一个 Series
- 另外的 DataFrame 对象

*** 创建

**** 从字典创建

key 为 DataFrame 的列；value 为对应列下的值

#+BEGIN_SRC ipython :session :exports both :results output
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
       'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

  log("pd.DataFrame(d)", pd.DataFrame(d))
  log("pd.DataFrame(d, index=['d', 'b', 'a'])", pd.DataFrame(d, index=['d', 'b', 'a']))
  log("pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])", pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three']))
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  d = {'one' : [1, 2, 3, 4],
       'two' : [21, 22, 23, 24]}

  log("pd.DataFrame(d)", pd.DataFrame(d))
  log("pd.DataFrame(d, index=['a', 'b', 'c', 'd'])", pd.DataFrame(d, index=['a', 'b', 'c', 'd']))
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame({
                    'A': 1,
                    'B': pd.Timestamp('20160301'),
                    'C': range(4),
                    'D': np.arange(5, 9),
                    'E': 'text',
                    'F': ['AA', 'BB', 'CC', 'DD']})
  log("df", df)
#+END_SRC


**** 从结构化数据列表创建

#+BEGIN_SRC ipython :session :exports both :results output
  data = [(1, 2.2, 'Hello'), (2, 3., "World")]

  log("pd.DataFrame(data)", pd.DataFrame(data))
  log("pd.DataFrame(data, index=['first', 'second'], columns=['A', 'B', 'C'])",
      pd.DataFrame(data, index=['first', 'second'], columns=['A', 'B', 'C']))
#+END_SRC


**** 从字典列表创建

#+BEGIN_SRC ipython :session :exports both :results output
  data = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]

  log("pd.DataFrame(data)", pd.DataFrame(data))
  log("pd.DataFrame(data, index=['first', 'second'])",
      pd.DataFrame(data, index=['first', 'second']))
  log("pd.DataFrame(data, columns=['a', 'b'])",
      pd.DataFrame(data, columns=['a', 'b']))

#+END_SRC


**** 从元组字典创建

实际应用中，会通过数据清洗的方式，把数据整理成方便 Pandas 导入且可读性好的格式。
然后再通过 *reindex/groupby* 等方式转换成复杂数据结构。

#+BEGIN_SRC ipython :session :exports both :results output
  d = {('a', 'b'): {('A', 'B'): 1, ('A', 'C'): 2},
       ('a', 'a'): {('A', 'C'): 3, ('A', 'B'): 4},
       ('a', 'c'): {('A', 'B'): 5, ('A', 'C'): 6},
       ('b', 'a'): {('A', 'C'): 7, ('A', 'B'): 8},
       ('b', 'b'): {('A', 'D'): 9, ('A', 'B'): 10}}

  # 多级标签
  log("pd.DataFrame(d)", pd.DataFrame(d))
#+END_SRC


**** 从 Series 创建

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
  log("pd.DataFrame(s)", pd.DataFrame(s))
  log("pd.DataFrame(s, index=['a', 'c', 'd'])",
      pd.DataFrame(s, index=['a', 'c', 'd']))
  log("pd.DataFrame(s, index=['a', 'c', 'd'], columns=['A'])",
      pd.DataFrame(s, index=['a', 'c', 'd'], columns=['A']))
#+END_SRC


**** 指定行列索引创建

#+BEGIN_SRC ipython :session :results output :exports both
  dates = pd.date_range('20160301', periods=6)
  log("dates", dates)

  df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
  log("df", df)
#+END_SRC


*** 数据操作

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(6, 4),
                    index=list('ABCDEF'),
                    columns=['one', 'two', 'three', 'four'])
  log("df", df)
#+END_SRC

**** 列选择(Series)

#+BEGIN_SRC ipython :session :exports both :results output
  log("df['one']", df['one'])
  log("df.one", df.one)
#+END_SRC


**** 列选择(DataFrame)

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.loc[:, ['one', 'two']]", df.loc[:, ['one', 'two']])
  log("df.iloc[:, 0:1]", df.iloc[:, 0:1])
#+END_SRC


**** 列赋值

#+BEGIN_SRC ipython :session :exports both :results output
  df['three'] = df['one'] + df['two']
  log("df", df)
#+END_SRC


**** 列删除

#+BEGIN_SRC ipython :session :exports both :results output
  del df['three']
  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  s = df.pop('four')
  log("s", s)
  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.drop(['one', 'two'], axis=1)  # df 不变
  log("result", result)
#+END_SRC


**** 增加列

***** 添加到最后

#+BEGIN_SRC ipython :session :exports both :results output
  df['flag'] = df['one'] > 0
  df['five'] = 5
  df['one_trunc'] = df['one'][:2]
  log("df", df)
#+END_SRC

***** 指定位置添加

#+BEGIN_SRC ipython :session :exports both :results output
  df.insert(1, 'bar', df.one + df.two)
  log("df", df)
#+END_SRC


***** assign()

assign 方法并不会 inplace 地改变原来的 dataframe ，
该方法的 *优势* 在于可以对 dataframe 对象使用链式操作。

#+BEGIN_SRC ipython :session :exports both :results output
  df1 = df.assign(Ratio=df.one/df.two)
  log("df1", df1)
  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.assign(Ratio=lambda x: x.one - x.two)",
      df.assign(Ratio=lambda x: x.one - x.two))

  log("df.assign(ABRatio=df.one/df.two).assign(BarValue=lambda x: x.ABRatio*x.bar)",
      df.assign(ABRatio=df.one/df.two).assign(BarValue=lambda x: x.ABRatio*x.bar))

#+END_SRC


**** 行选择(Series)

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.loc['A']", df.loc['A'])  # 行标签方式
  log("df.iloc[0]", df.iloc[0])    # 行位置方式
#+END_SRC


**** 行选择(DataFrame)

#+BEGIN_SRC ipython :session :exports both :results output
   log("df[2:4]", df[2:4])
   log("df['A':'C']", df['A':'C'])
   log("df.iloc[2:4]", df.iloc[2:4])         # 效率高
   log("df[df.one > 0.5]", df[df.one > 0.5])  # 布尔方式
   log("df[df > 0]", df[df > 0])             # 布尔方式
   log("df[[False, True, True, False, True, False]]",
       df[[False, True, True, False, True, False]])  # 布尔方式

#+END_SRC


**** 行删除

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.drop('A')           # result 是一份新的数据拷贝
  log("result", result)
#+END_SRC

**** 行与列选择

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.loc['A':'B', ['one', 'two']]", df.loc['A':'B', ['one', 'two']])
  log("df.iloc[0:2, 0:3]", df.iloc[0:2, 0:3])
#+END_SRC


**** 选择指定坐标

#+BEGIN_SRC ipython :session :results output :exports both
  log("df.loc['A', 'one']", df.loc['A', 'one'])
  log("df.at['A', 'one']", df.at['A', 'one'])
  log("df.iloc[1, 1]", df.iloc[1, 1])
  log("df.iat[1, 1]", df.iat[1, 1])
#+END_SRC


**** 数据对齐

DataFrame 在进行数据计算时， *会自动按行和列进行数据对齐* 。
最终的计算结果会合并两个 DataFrame 。

#+BEGIN_SRC ipython :session :exports both :results output
  df1 = pd.DataFrame(np.random.randn(10, 4),
                     index=list('abcdefghij'),
                     columns=['A', 'B', 'C', 'D'])

  df2 = pd.DataFrame(np.random.randn(7, 3),
                     index=list('cdefghi'),
                     columns=['A', 'B', 'C'])

  log("df1", df1)
  log("df2", df2)

  log("df1 + df2", df1 + df2)
  log("df1 - df1.iloc[0]", df1 - df1.iloc[0])
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  df3 = df2.loc[:, ['B', 'C']].copy()
  log("df3 (before)", df3)
  df3[df3 > 0] = -df3
  log("df3 (after)", df3)
#+END_SRC

**** 使用 numpy 函数

因为从本质上讲，DataFrame 内部用的数据结构就是 numpy 的 ndarray 。

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(10, 4), columns=['one', 'two', 'three', 'four'])
  log("np.exp(df)", np.exp(df))
  log("np.sin(df)", np.sin(df))
#+END_SRC

***** DataFrame 转换为 ndarray 对象

#+BEGIN_SRC ipython :session :exports both :results output
  ary = np.asarray(df)
  log("ary", ary)
  log("ary == df.values", ary == df.values)
  log("ary == df", ary == df)
#+END_SRC


** Panel

Panel 是三维带标签的数组。

Panel 由三个标签组成：

- items :: 坐标轴 0 ，索引对应的元素是一个 DataFrame
- major_axis :: 坐标轴 1 , DataFrame 里的行标签
- minor_axis :: 坐标轴 2 , DataFrame 里的列标签



* 函数应用

** 将数据按行或列进行计算(apply)

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.arange(12).reshape(4, 3),
                    index=['one', 'two', 'three', 'four'],
                    columns=list('ABC'))

  log("df", df)
#+END_SRC

**** 按列进行运算

每一列作为一个 Series 作为参数传递给 lambda 函数

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.apply(lambda x: x.max() - x.min())
  log("result", result)
#+END_SRC

**** 按行进行运算

每一行作为一个 Series 作为参数传递给 lambda 函数

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.apply(lambda x: x.max() - x.min(), axis=1)
  log("result", result)
#+END_SRC

**** 返回多个值组成的 Series

#+BEGIN_SRC ipython :session :exports both :results output
  def min_max(x):
      return pd.Series([x.min(), x.max()], index=['min', 'max'])
  result = df.apply(min_max, axis=1)
  log("result", result)
#+END_SRC


** 逐元素运算(applymap)

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(4, 3),
                    index=['one', 'two', 'three', 'four'],
                    columns=list('ABC'))

  log("df", df)
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  # x 表示 dataframe 中的每个元素
  result = df.applymap(lambda x: '{0:.03f}'.format(x))
  log("result", result)
#+END_SRC


** 排序(sort_values)


#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randint(1, 10, (4, 3)),
                    index=list('ABCD'),
                    columns=['one', 'two', 'three'])

  log("df", df)
#+END_SRC


*** 按列排序

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.sort_values(by='two', ascending=False)
  log("result", result)
#+END_SRC

*** 按行排序

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.sort_values(by='C', axis=1, ascending=False)
  log("result", result)
#+END_SRC


** 索引排序(sort_index)

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randint(1, 10, (4, 3)),
                    index=list('ABCD'),
                    columns=['one', 'two', 'three'])

  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  col_sort = df.sort_index(axis=1, ascending=False)
  row_sort = df.sort_index(ascending=False)

  log("col_sort", col_sort)
  log("row_sort", row_sort)

#+END_SRC


** 排名(rank)

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series([3, 6, 2, 6, 4])
  df = pd.DataFrame(np.random.randint(1, 10, (4, 3)),
                    index=list('ABCD'),
                    columns=['one', 'two', 'three'])

  log("s", s)
  log("df", df)
#+END_SRC



#+BEGIN_SRC ipython :session :exports both :results output
  s_result = s.rank(method='first', ascending=False)
  log("s_result", s_result)
#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  df_result = df.rank(method='first')
  log("df_result", df_result)
#+END_SRC


** Series 元素统计

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(list('abbcdabacad'))
  log("s", s)
#+END_SRC

*** 个数统计(value_counts)

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.value_counts()", s.value_counts())
#+END_SRC

*** 唯一性统计(uniq)

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.unique()", s.unique())
#+END_SRC


*** 成员资格统计(isin)

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.isin(['a', 'b', 'c'])", s.isin(['a', 'b', 'c']))
#+END_SRC





* 索引

** 重新索引

即把索引值进行重新赋值， *以增加一些行的数据* 。

*** Series

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series([1, 3, 5, 6, 8], index=list('acefh'))
  log("s", s)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.reindex(list('abcdefgh'))",
      s.reindex(list('abcdefgh')))
#+END_SRC


***** 填充默认值

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.reindex(list('abcdefgh'), fill_value=0)",
      s.reindex(list('abcdefgh'), fill_value=0))
#+END_SRC

***** 往前填充

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.reindex(list('abcdefgh'), method='ffill')",
      s.reindex(list('abcdefgh'), method='ffill'))
#+END_SRC


***** 往后填充

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.reindex(list('abcdefgh'), method='bfill')",
      s.reindex(list('abcdefgh'), method='bfill'))
#+END_SRC


*** DataFrame

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(4, 6),
                    index=list('ADFH'),
                    columns=['one', 'two', 'three', 'four', 'five', 'six'])
  log("df", df)
#+END_SRC

***** 对行重新索引

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.reindex(index=list('ABCDEFGH'))",
      df.reindex(index=list('ABCDEFGH')))
#+END_SRC

****** 向前填充

*fill method 只对行重新索引有效，不适用列*

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.reindex(index=list('ABCDEFGH'), method='ffill')",
      df.reindex(index=list('ABCDEFGH'), method='ffill'))
#+END_SRC

***** 对列重新索引

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.reindex(columns=['one', 'three', 'five', 'seven'], fill_value=0)",
      df.reindex(columns=['one', 'three', 'five', 'seven'], fill_value=0))
#+END_SRC





** 索引命名

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.rand(5), index=list('abcde'))
  df = pd.DataFrame(np.random.randn(4, 3), columns=['one', 'two', 'three'])

  log("s", s)
  log("df", df)

#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.index", s.index)
  s.index.name = 'alpha'
  log("s", s)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.index", df.index)
  log("df.columns", df.columns)

  df.index.name = 'row'
  df.columns.name = 'col'

  log("df", df)
#+END_SRC


** 重复索引

索引值有重复项的索引

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.arange(6), index=list('abcbda'))
  log("s", s)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("s['a']", s['a'])
  log("s.index.is_unique", s.index.is_unique)
#+END_SRC


*** 对重复索引的处理（清洗）

#+BEGIN_SRC ipython :session :exports both :results output
  sum_result = s.groupby(s.index).sum()  # 对重复索引内容进行求和
  log("sum_result", sum_result)

  first_result = s.groupby(s.index).first()  # 对重复索引内容只取第一项
  log("first_result", first_result)

  avg_result = s.groupby(s.index).mean()  # 对重复索引内容取平均值
  log("avg_result", avg_result)
#+END_SRC


** 多级索引

*用二维的数据表达更高维度的数据* ，使数据组织方式更清晰，它使用 =pd.MultiIndex= 类来表示。

*** 层次化索引的作用

比如在分析股票数据：
- 一级行索引可以是日期
- 二级行索引可以是股票代码
- 列索引可以是股票的交易量，开盘价，收盘价等等

这样就可以把多个股票放在同一个时间维度下进行考察和分析。


*** Series 多级索引


**** 创建

#+BEGIN_SRC ipython :session :exports both :results output
  a = [['a', 'a', 'a', 'b', 'b', 'c', 'c'], [1, 2, 3, 1, 2, 2, 3]]
  tuples = list(zip(*a))
  log("tuples", tuples)
  index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
  log("index", index)
  s = pd.Series(np.random.randn(7), index=index)
  log("s", s)
  log("s.index", s.index)
  log("s.index.levels[1]", s.index.levels[1])
#+END_SRC

**** 选取

#+BEGIN_SRC ipython :session :exports both :results output
  log("s['b']", s['b'])
  log("s['b':'c']", s['b':'c'])
  log("s[['b', 'a']]", s[['b', 'a']])
  log("s['b', 1]", s['b', 1])
  log("s[:, 2]", s[:, 2])
#+END_SRC

*** DataFrame 多级索引

**** 创建

#+BEGIN_SRC ipython :session :var path="img/fig75428gsV.png"
  df = pd.DataFrame(np.random.randint(1, 10, (4, 3)),  # 1-10 之间的随机数，4 行 3 列
                    index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                    columns=[['one', 'one', 'two'], ['blue', 'red', 'blue']])
  df.index.names = ['row-1', 'row-2']
  df.columns.names = ['col-1', 'col-2']
  show_dataframe(df)
#+END_SRC

[[file:img/fig75428gsV.png]]

**** 选取

#+BEGIN_SRC ipython :session :var path="img/fig754286Ai.png"
  show_dataframe(df.loc['a'])
#+END_SRC

[[file:img/fig754286Ai.png]]

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.loc['a', 1]", df.loc['a', 1])
#+END_SRC


**** 多级索引交换

#+BEGIN_SRC ipython :session :var path="img/fig75428UVu.png"
  df2 = df.swaplevel('row-1', 'row-2')
  show_dataframe(df2)
#+END_SRC

[[file:img/fig75428UVu.png]]


**** 多级索引排序

#+BEGIN_SRC ipython :session :var path="img/fig75428TpD.png"
  show_dataframe(df2.sortlevel(0))  # 0 表示根据一级索引进行排序
#+END_SRC

[[file:img/fig75428TpD.png]]

#+BEGIN_SRC ipython :session :var path="img/fig75428t9P.png"
  show_dataframe(df2.sortlevel(1))  # 根据二级索引进行排序
#+END_SRC

[[file:img/fig75428t9P.png]]


**** 多级索引统计


#+BEGIN_SRC ipython :session :var path="img/fig75428HSc.png"
  show_dataframe(df.sum(level=0))
#+END_SRC

[[file:img/fig75428HSc.png]]


#+BEGIN_SRC ipython :session :var path="img/fig75428hmo.png"
  show_dataframe(df.sum(level=1))
#+END_SRC

[[file:img/fig75428hmo.png]]


**** 列与索引的转换

创建多级索引比较复杂，一般情况下会从文件中读取一个 DataFrame ，
然后将其中某个列转换为多级索引，最终得到一个基于多级索引的 DataFrame 。

#+BEGIN_SRC ipython :session :var path="img/fig75428760.png"
  df = pd.DataFrame({
      'a': range(7),
      'b': range(7, 0, -1),
      'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'],
      'd': [0, 1, 2, 0, 1, 2, 3]
  })
  show_dataframe(df)
#+END_SRC

[[file:img/fig75428760.png]]

***** 列转换为索引

#+BEGIN_SRC ipython :session :var path="img/fig754286OK.png"
  show_dataframe(df.set_index('c'))
#+END_SRC

[[file:img/fig754286OK.png]]

#+BEGIN_SRC ipython :session :var path="img/fig75428UjW.png"
  df2 = df.set_index(['c', 'd'])
  show_dataframe(df2)
#+END_SRC

[[file:img/fig75428UjW.png]]



***** 索引转换为列

将所有索引转换为列

#+BEGIN_SRC ipython :session :var path="img/fig75428u3i.png"
  show_dataframe(df2.reset_index().sort_index('columns'))
#+END_SRC

[[file:img/fig75428u3i.png]]





* 分组与聚合

#+BEGIN_SRC ipython :session :var path="img/fig75428IMv.png"
  df = pd.DataFrame({'key1': ['a', 'a', 'b', 'b', 'a'],
                     'key2': ['one', 'two', 'one', 'two', 'one'],
                     'data1': np.random.randint(1, 10, 5),
                     'data2': np.random.randint(1, 10, 5)})

  show_dataframe(df)
#+END_SRC

[[file:img/fig75428IMv.png]]

** 原理

三步曲：

1. 拆分：根据什么进行分组
2. 应用：每个分组进行什么样的计算（每个组应用一个 *计算规则* ，输出一个结果）
3. 聚合：把每个分组的计算结果合并起来，构成最终输出

** 分组

*** 对 Series 进行分组

通过索引对齐关联起来


#+BEGIN_SRC ipython :session :exports both :results output
  grouped = df['data1'].groupby(df['key1'])
  log("grouped", grouped)         # groupby 对象
  log("grouped.mean()", grouped.mean())
  key = [1, 2, 1, 2, 1]
  log("df['data1'].groupby(key)", df['data1'].groupby(key))

#+END_SRC


#+BEGIN_SRC ipython :session :exports both :results output
  log("df['data1'].groupby([df['key1'], df['key2']]).mean()",
      df['data1'].groupby([df['key1'], df['key2']]).mean())
  log("df['data1'].groupby([df['key1'], df['key2']]).size()",
      df['data1'].groupby([df['key1'], df['key2']]).size())
#+END_SRC


*** 对 DataFrame 进行分组（默认按行分组）


#+BEGIN_SRC ipython :session :var path="img/fig75428HgE.png"
  show_dataframe(df.groupby('key1').mean())
#+END_SRC

[[file:img/fig75428HgE.png]]


#+BEGIN_SRC ipython :session :var path="img/fig75428h0Q.png"
  df1 = df.groupby(['key1', 'key2']).mean()
  show_dataframe(df1)
#+END_SRC

[[file:img/fig75428h0Q.png]]


*** 对分组对象进行迭代

#+BEGIN_SRC ipython :session :exports both :results output
  for name, group in df.groupby('key1'):
      print(name)
      print(group)

  print('='*80)

  for name, group in df.groupby(['key1', 'key2']):
      print(name)
      print(group)
#+END_SRC


*** 通过字典进行分组

#+BEGIN_SRC ipython :session :var path="img/fig754287Id.png"
  df = pd.DataFrame(np.random.randint(1, 10, (5, 5)),
                    columns=['a', 'b', 'c', 'd', 'e'],
                    index=['Alice', 'Bob', 'Candy', 'Dark', 'Emily'])
  df.iloc[1, 1:3] = np.NaN
  show_dataframe(df)
#+END_SRC

[[file:img/fig754287Id.png]]


#+BEGIN_SRC ipython :session :var path="img/fig75428Vdp.png"
  mapping = {'a': 'red', 'b': 'red', 'c': 'blue', 'd': 'orange', 'e': 'blue'}
  grouped = df.groupby(mapping, axis=1)  # 按列分组
  show_dataframe(grouped.sum())
#+END_SRC

[[file:img/fig75428Vdp.png]]


#+BEGIN_SRC ipython :session :var path="img/fig75428uFL.png"
  show_dataframe(grouped.count())
#+END_SRC

[[file:img/fig75428uFL.png]]


#+BEGIN_SRC ipython :session :exports both :results output
  log("grouped.size()", grouped.size())
#+END_SRC


*** 通过函数分组

当函数作为分组依据时，数据表里的每个索引（可以是行索引，也可以是列索引）都会调用一次函数，
*函数的返回值作为分组的索引* ，即相同的返回值分在同一组。

#+BEGIN_SRC ipython :session :var path="img/fig75428iuj.png"
  df = pd.DataFrame(np.random.randint(1, 10, (5, 5)),
                    columns=['a', 'b', 'c', 'd', 'e'],
                    index=['Alice', 'Bob', 'Candy', 'Dark', 'Emily'])
  show_dataframe(df)
#+END_SRC

#+NAME: img/fig75428iuj.png
#+CAPTION: 示例数据
[[file:img/fig75428iuj.png]]


#+BEGIN_SRC ipython :session :exports both :results output
  def _dummy_group(idx):
      print("idx:", idx)
      return idx

  print("axis=0")
  df.groupby(_dummy_group)
  print("axis=1")
  df.groupby(_dummy_group, axis=1)
#+END_SRC

#+BEGIN_SRC ipython :session :var path="img/fig754288Cw.png"
  grouped = df.groupby(len)
  show_dataframe(grouped.sum())
#+END_SRC

[[file:img/fig754288Cw.png]]


*** 多级索引数据根据索引级别来分组

#+BEGIN_SRC ipython :session :var path="img/fig754287WF.png"
  columns = pd.MultiIndex.from_arrays([['China', 'USA', 'China', 'USA', 'China'],
                                       ['A', 'A', 'B', 'C', 'B']], names=['country', 'index'])
  df = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)
  show_dataframe(df)
#+END_SRC

#+NAME: img/fig754287WF.png
#+CAPTION: 示例数据
[[file:img/fig754287WF.png]]


#+BEGIN_SRC ipython :session :var path="img/fig75428VrR.png"
  show_dataframe(df.groupby(level='country', axis=1).count())
#+END_SRC

[[file:img/fig75428VrR.png]]

#+BEGIN_SRC ipython :session :var path="img/fig3702047R.png"
  show_dataframe(df.groupby(level='country', axis=1).sum())
#+END_SRC

[[file:img/fig3702047R.png]]


#+BEGIN_SRC ipython :session :var path="img/fig37020FNM.png"
  show_dataframe(df.groupby(level='index', axis=1).count())
#+END_SRC


[[file:img/fig37020FNM.png]]

** 数据聚合






#+BEGIN_SRC ipython :session :var path="img/fig37020fhY.png"
  df = pd.DataFrame({'key1': ['a', 'a', 'b', 'b', 'a'],
                     'key2': ['one', 'two', 'one', 'two', 'one'],
                     'data1': np.random.randint(1, 10, 5),
                     'data2': np.random.randint(1, 10, 5),
                     'data3': np.random.randint(1, 10, 5)})
  show_dataframe(df)
#+END_SRC

#+NAME: img/fig37020fhY.png
#+CAPTION: 示例数据
[[file:img/fig37020fhY.png]]

*** 内置聚合函数

**** sum

#+BEGIN_SRC ipython :session :var path="img/fig37020TKx.png"
  show_dataframe(df.groupby('key1').sum())
#+END_SRC

#+NAME: img/fig37020TKx.png
#+CAPTION: sum
[[file:img/fig37020TKx.png]]

**** mean

#+BEGIN_SRC ipython :session :var path="img/fig37020SeG.png"
  show_dataframe(df.groupby('key1').mean())
#+END_SRC

#+NAME: img/fig37020SeG.png
#+CAPTION: mean
[[file:img/fig37020SeG.png]]

**** size

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.groupby('key1').size()", df.groupby('key1').size())
#+END_SRC

**** count

#+BEGIN_SRC ipython :session :var path="img/fig37020GHf.png"
  show_dataframe(df.groupby('key1').count())
#+END_SRC

#+NAME: img/fig37020GHf.png
#+CAPTION: count
[[file:img/fig37020GHf.png]]

**** min/max

#+BEGIN_SRC ipython :session :var path="img/fig37020gbr.png"
  show_dataframe(df.groupby('key1').min())
#+END_SRC

#+NAME: img/fig37020gbr.png
#+CAPTION: min
[[file:img/fig37020gbr.png]]

**** describe

#+BEGIN_SRC ipython :session :var path="img/fig37020fvA.png"
  show_dataframe(df.groupby('key1').describe())
#+END_SRC

#+NAME: img/fig37020fvA.png
#+CAPTION: describe
[[file:img/fig37020fvA.png]]

*** 自定义聚合函数

自定义聚合函数时，需使用 =agg()= 或 =aggregate()= 函数。


#+BEGIN_SRC ipython :session :exports both :results output
  def peak_range(s):
      print(s)
      print(type(s))
      print('=====')
      return s.max() - s.min()

  grouped = df.groupby('key1')
  result = grouped.agg(peak_range)
#+END_SRC

#+BEGIN_SRC ipython :session :var path="img/fig3702051k.png"
  show_dataframe(result)
#+END_SRC

[[file:img/fig3702051k.png]]

*** 应用多个聚合函数

#+BEGIN_SRC ipython :session :var path="img/fig370205DN.png"
  show_dataframe(grouped.agg(['std', 'mean', peak_range]))
#+END_SRC

#+NAME: img/fig370205DN.png
#+CAPTION: 多个聚合函数
[[file:img/fig370205DN.png]]


*** 给聚合后的列起别名

#+BEGIN_SRC ipython :session :var path="img/fig37020TYZ.png"
  show_dataframe(grouped.agg(['std', 'mean', ('high-low', peak_range)]))
#+END_SRC

#+NAME: img/fig37020TYZ.png
#+CAPTION: 别名
[[file:img/fig37020TYZ.png]]


*** 自定义需要显示的列

#+BEGIN_SRC ipython :session :var path="img/fig37020tsl.png"
  show_dataframe(grouped.sum())
#+END_SRC

#+NAME: img/fig37020tsl.png
#+CAPTION: 所有列
[[file:img/fig37020tsl.png]]

#+BEGIN_SRC ipython :session :var path="img/fig37020HBy.png"
  show_dataframe(grouped['data1', 'data3'].sum())
#+END_SRC

#+NAME: img/fig37020HBy.png
#+CAPTION: 自定义后的列
[[file:img/fig37020HBy.png]]



*** 给不同的列应用不同的聚合函数

使用 dict 作为参数来实现，此方法也能实现自定义需要显示的列。

#+BEGIN_SRC ipython :session :var path="img/fig37020GVH.png"
  d = {'data1': ['mean', peak_range, 'max', 'min'],
       'data2': 'sum'}
  show_dataframe(grouped.agg(d))
#+END_SRC

#+NAME: img/fig37020GVH.png
#+CAPTION: 不同的聚合函数
[[file:img/fig37020GVH.png]]


*** 索引重置

#+BEGIN_SRC ipython :session :var path="img/fig37020gpT.png"
  # 等效于 df.groupby('key1', as_index=False).agg(d)
  show_dataframe(grouped.agg(d).reset_index())
#+END_SRC

#+NAME: img/fig37020gpT.png
#+CAPTION: reset_index 效果
[[file:img/fig37020gpT.png]]


* 处理丢失数据

#+BEGIN_SRC ipython :session :exports both :results output
  dates = pd.date_range('20160301', periods=6)
  df = pd.DataFrame(data=np.random.randn(6, 4), index=dates, columns=list('ABCD'))
  df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])
  df1.loc[dates[1:3], 'E'] = 1
  log("df1", df1)
#+END_SRC

** 丢弃 NaN 行

#+BEGIN_SRC ipython :session :exports both :results output
  log("df1.dropna(how='any')", df1.dropna(how='any'))
#+END_SRC

** 用默认值替换 NaN

#+BEGIN_SRC ipython :session :exports both :results output
  log("df1.fillna(value=5)", df1.fillna(value=5))
#+END_SRC

** 判断数据集是否包含 NaN

#+BEGIN_SRC ipython :session :exports both :results output
  log("pd.isnull(df1)", pd.isnull(df1))
  log("pd.isnull(df1).any()", pd.isnull(df1).any())
  log("pd.isnull(df1).any().any()", pd.isnull(df1).any().any())
#+END_SRC


** NaN 不参与运算

#+BEGIN_SRC ipython :session :exports both :results output
  log("df1.mean()", df1.mean())
  log("df1.mean(axis=1)", df1.mean(axis=1))
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("df1.sum()", df1.sum())
  log("df1.sum(axis=1)", df1.sum(axis=1))
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)
  log("s", s)
  log("df", df)
  log("df.sub(s, axis='index')", df.sub(s, axis='index'))
#+END_SRC


* 数据操作

#+BEGIN_SRC ipython :session :exports both :results output
  dates = pd.date_range('20160301', periods=6)
  df = pd.DataFrame(data=np.random.randn(6, 4), index=dates, columns=list('ABCD'))
  log("df", df)
#+END_SRC



** concat

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(10, 4), columns=list('ABCD'))
  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  result = pd.concat([df.iloc[:3], df.iloc[3:7], df.iloc[7:]])
  log("result", result)
  log("(result == df).all().all()", (result == df).all().all())
#+END_SRC


** merge

#+BEGIN_SRC ipython :session :exports both :results output
  left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
  right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})
  log("left", left)
  log("right", right)

  # SELECT * FROM left INNER JOIN right ON left.key = right.key;
  result = pd.merge(left, right, on='key')
  log("result", result)
#+END_SRC


** append

#+BEGIN_SRC ipython :session :exports both :results output
  s = pd.Series(np.random.randint(1, 5, size=4), index=list('ABCD'))
  log("s", s)
  result = df.append(s, ignore_index=True)
  log("result", result)
#+END_SRC


** 数据整形

#+BEGIN_SRC ipython :session :exports both :results output
  tuples = list(zip(*[['bar', 'bar', 'baz', 'baz',
                       'foo', 'foo', 'qux', 'qux'],
                      ['one', 'two', 'one', 'two',
                       'one', 'two', 'one', 'two']]))
  log("tuples", tuples)
  index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
  df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])
  log("df", df)
#+END_SRC

*** 将列索引变为行索引 (stack)

#+BEGIN_SRC ipython :session :exports both :results output
stacked = df.stack()
log("stacked", stacked)
log("type(stacked)", type(stacked))
log("stacked.index", stacked.index)
#+END_SRC

*** 将行索引变为列索引 (unstack)

#+BEGIN_SRC ipython :session :exports both :results output
log("stacked.unstack()", stacked.unstack())
#+END_SRC

*** 透视图（pivot_table）

只观察 data frame 中一部分数据

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame({'A' : ['one', 'one', 'two', 'three'] * 3,
                     'B' : ['A', 'B', 'C'] * 4,
                     'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2,
                     'D' : np.random.randn(12),
                     'E' : np.random.randn(12)})

  log("df", df)
#+END_SRC

以 A ，B 为行索引，以 C 为列索引的，针对 D 的数据：

#+BEGIN_SRC ipython :session :exports both :results output
  result = pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C'])
  log("result", result)

#+END_SRC

*当透视表结果为多个值的时候，返回平均值* ，如：

#+BEGIN_SRC ipython :session :exports both :results output
  result = pd.pivot_table(df, values=['E'], index=['A'], columns=['C'])
  log("result", result)
#+END_SRC

针对 A 为 one 的那行数据，其计算过程相当于：

#+BEGIN_SRC ipython :session :exports both :results output
  result = df[df.A=='one'].groupby('C').mean()
  log("result", result)
#+END_SRC


** Category

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame({"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
  df["grade"] = df["raw_grade"].astype("category")
  log("df", df)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  log("df.grade", df.grade)
  log("df.grade.cat.categories", df.grade.cat.categories)
  df.grade.cat.categories = ['very good', 'good', 'bad']
  log("df", df)
  # 以 raw_grade 列为排序标准
  sort_result = df.sort_values(by='grade', ascending=False)
  log("sort_result", sort_result)
#+END_SRC


* 信息统计


** mode

#+BEGIN_SRC ipython :session :exports both :results output
  log("s.mode()", s.mode())
#+END_SRC


* 分组统计


#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
                            'foo', 'bar', 'foo', 'foo'],
                     'B' : ['one', 'one', 'two', 'three',
                            'two', 'two', 'one', 'three'],
                     'C' : np.random.randn(8),
                     'D' : np.random.randn(8)})
  log("df", df)
#+END_SRC

** 对单列分组

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.groupby('A').sum()
  log("result", result)
#+END_SRC


** 对多列分组

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.groupby(['A', 'B']).sum()
  log("result", result)
#+END_SRC

#+BEGIN_SRC ipython :session :exports both :results output
  result = df.groupby(['B', 'A']).sum()
  log("result", result)
#+END_SRC


* 时间序列

pandas 提供了强大的时间序列功能，比如把秒级的股票数据转换为 5 分钟周期数据等。

** data_range

#+BEGIN_SRC ipython :session :exports both :results output
  rng = pd.date_range('20160301', periods=600, freq='s')
  log("rng", rng)
  ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)
  log("ts", ts)
#+END_SRC

** 重采样

#+BEGIN_SRC ipython :session :exports both :results output
  result_sum = ts.resample('2Min', how='sum')
  log("result_sum", result_sum)
  result_mean = ts.resample('2Min', how='mean')
  log("result_mean", result_mean)
#+END_SRC

** period_range

#+BEGIN_SRC ipython :session :exports both :results output
  rng = pd.period_range('2000Q1', '2016Q1', freq='Q')
  log("rng", rng)
  log("rng.to_timestamp()", rng.to_timestamp())
#+END_SRC

** 时间计算

#+BEGIN_SRC ipython :session :exports both :results output
  log("pd.Timestamp('20160301') - pd.Timestamp('20160201')", pd.Timestamp('20160301') - pd.Timestamp('20160201'))
  log("pd.Timestamp('20160301') + pd.Timedelta(days=5)", pd.Timestamp('20160301') + pd.Timedelta(days=5))

#+END_SRC


* 可视化

** Series

#+BEGIN_SRC ipython :session :var path="img/fig75428HE0.png"
  ts = pd.Series(np.random.randn(1000), index=pd.date_range('20000101', periods=1000))
  ts = ts.cumsum()
  show_fig(ts)
#+END_SRC

[[file:img/fig75428HE0.png]]


* 导入导出

** 导出 csv

#+BEGIN_SRC ipython :session :exports both :results output
  df = pd.DataFrame(np.random.randn(100, 4), columns=list('ABCD'))
  df.to_csv("/tmp/df.csv")
#+END_SRC

** 导入 csv

#+BEGIN_SRC ipython :session :exports both :results output
pd.read_csv('/tmp/df.csv', index_col=0)
#+END_SRC


* 示例工程

** 电影数据分析

*** 数据读取

#+BEGIN_SRC ipython :session :exports both :results output
  user_names = ['user_id', 'gender', 'age', 'occupation', 'zip']
  users = pd.read_table('data/ml-1m/users.dat', sep='::', header=None, names=user_names, engine='python')

  rating_names = ['user_id', 'movie_id', 'rating', 'timestamp']
  ratings = pd.read_table('data/ml-1m/ratings.dat', sep='::', header=None, names=rating_names, engine='python')

  movie_names = ['movie_id', 'title', 'genres']
  movies = pd.read_table('data/ml-1m/movies.dat', sep='::', header=None, names=movie_names, engine='python')

  log("users.head()", users.head())
  log("ratings.head()", ratings.head())
  log("movies.head()", movies.head())
#+END_SRC

*** 数据合并 (merge)

在 pandas 中，数据只有合并后才能进行分析

#+BEGIN_SRC ipython :session :var path="img/fig75428GYJ.png"
  data = pd.merge(pd.merge(users, ratings), movies)
  show_dataframe(data.head())
#+END_SRC

[[file:img/fig75428GYJ.png]]

*** 按性别查看各个电影的平均评分 (pivot_table)

*关心的值* 是 rating ，以 title 作为 *行索引* ，gender 作为 *列索引*

#+BEGIN_SRC ipython :session :exports both :results output
  mean_ratings_gender = data.pivot_table(values='rating', index='title', columns='gender', aggfunc='mean')
  log("mean_ratings_gender.head()", mean_ratings_gender.head())

#+END_SRC

*** 男女意见想差最大的电影 (sort_values)

#+BEGIN_SRC ipython :session :exports both :results output
  mean_ratings_gender['diff'] = mean_ratings_gender.F - mean_ratings_gender.M
  result = mean_ratings_gender.sort_values(by='diff', ascending=True)
  log("result.head()", result.head())
#+END_SRC

*** 参与评分人数最多 (group_by)

#+BEGIN_SRC ipython :session :exports both :results output

  ratings_by_movie_title = data.groupby('title').size()
  top_ratings = ratings_by_movie_title[ratings_by_movie_title > 1000]
  top_10_ratings = top_ratings.sort_values(ascending=False).head()
  log("top_10_ratings", top_10_ratings)
#+END_SRC


*** 活跃度超过 1000 的高分电影


#+BEGIN_SRC ipython :session :exports both :results output
  mean_ratings = data.pivot_table(values='rating', index='title', aggfunc='mean')
  top_10_movies = mean_ratings.loc[top_ratings.index].sort_values(by='rating', ascending=False).head(10)
  # 把平均评分和热度综合起来
  df_top_10_movies = pd.DataFrame(top_10_movies)
  df_top_10_movies['hot'] = top_ratings.loc[top_10_movies.index]
  log("df_top_10_movies", df_top_10_movies)

#+END_SRC
