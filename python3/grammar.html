<!DOCTYPE html>
<html>
<head>
<title>Python3</title>
<!-- 2018-02-22 Thu 21:28 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Hao Ruan">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
<link href="../org-html-themes/solarized/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Python3</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 类</a>
<ul>
<li><a href="#sec-1-1">1.1. 抽象类</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. 内置抽象基类</a></li>
<li><a href="#sec-1-1-2">1.1.2. 自定义抽象基类</a></li>
<li><a href="#sec-1-1-3">1.1.3. 虚拟子类</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. 继承</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 并发编程</a>
<ul>
<li><a href="#sec-2-1">2.1. 全局解释锁 (GIL)</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. I/O 密集型操作</a></li>
<li><a href="#sec-2-1-2">2.1.2. CPU 密集型操作</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. concurrent.futures 模块</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Executor.map()</a></li>
<li><a href="#sec-2-2-2">2.2.2. Executor.sumit()</a></li>
<li><a href="#sec-2-2-3">2.2.3. concurrent.futures.as_completed()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. async 并发编程</a>
<ul>
<li><a href="#sec-3-1">3.1. asyncio 基本思想 (面向事件编程)</a></li>
<li><a href="#sec-3-2">3.2. @asyncio.coroutine</a></li>
<li><a href="#sec-3-3">3.3. asyncio.Future</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. 从 Future ，Task ，和协程中产出值</a></li>
<li><a href="#sec-3-3-2">3.3.2. 协程和 Future 测试脚本</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. 常用 API</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. BaseEventLoop.run_in_executor()</a></li>
<li><a href="#sec-3-4-2">3.4.2. asyncio.as_complete()</a></li>
<li><a href="#sec-3-4-3">3.4.3. asyncio.Semaphore</a></li>
<li><a href="#sec-3-4-4">3.4.4. asyncio.wait()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. 上下文管理</a>
<ul>
<li><a href="#sec-4-1">4.1. for/else, while/else, try/else</a></li>
<li><a href="#sec-4-2">4.2. with</a></li>
<li><a href="#sec-4-3">4.3. contextlib 模块中的实用工具</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1. closing</a></li>
<li><a href="#sec-4-3-2">4.3.2. suppress</a></li>
<li><a href="#sec-4-3-3">4.3.3. redirect</a></li>
<li><a href="#sec-4-3-4">4.3.4. @contextmanager</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. 协程</a>
<ul>
<li><a href="#sec-5-1">5.1. 状态</a></li>
<li><a href="#sec-5-2">5.2. send()</a></li>
<li><a href="#sec-5-3">5.3. 执行过程举例</a></li>
<li><a href="#sec-5-4">5.4. 预激 (prime) 协程的装饰器</a></li>
<li><a href="#sec-5-5">5.5. 终止协程和异常处理</a>
<ul>
<li><a href="#sec-5-5-1">5.5.1. generator.throw()</a></li>
<li><a href="#sec-5-5-2">5.5.2. generator.close()</a></li>
</ul>
</li>
<li><a href="#sec-5-6">5.6. 有返回值的协程</a></li>
<li><a href="#sec-5-7">5.7. yield from</a>
<ul>
<li><a href="#sec-5-7-1">5.7.1. 结构示意图</a></li>
<li><a href="#sec-5-7-2">5.7.2. yield from 意义</a>
<ul>
<li><a href="#sec-5-7-2-1">5.7.2.1. RESULT = yield from EXPR 执行逻辑</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5-8">5.8. 使用协程进行离散事件仿真</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 数据结构</a>
<ul>
<li><a href="#sec-6-1">6.1. 元组</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. 基本用法</a>
<ul>
<li><a href="#sec-6-1-1-1">6.1.1.1. 占位</a></li>
<li><a href="#sec-6-1-1-2">6.1.1.2. 星号(*)的使用</a></li>
<li><a href="#sec-6-1-1-3">6.1.1.3. 嵌套拆包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. 具名元组</a></li>
<li><a href="#sec-6-3">6.3. 列表</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1. 切片选择</a></li>
<li><a href="#sec-6-3-2">6.3.2. 切片赋值</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4. bisect</a>
<ul>
<li><a href="#sec-6-4-1">6.4.1. 搜索</a></li>
<li><a href="#sec-6-4-2">6.4.2. 插入新元素</a></li>
</ul>
</li>
<li><a href="#sec-6-5">6.5. 数组</a></li>
<li><a href="#sec-6-6">6.6. 内存视图</a></li>
<li><a href="#sec-6-7">6.7. 双向队列</a></li>
<li><a href="#sec-6-8">6.8. 生成器</a>
<ul>
<li><a href="#sec-6-8-1">6.8.1. 生成器函数</a></li>
<li><a href="#sec-6-8-2">6.8.2. 标准库中的生成器函数</a>
<ul>
<li><a href="#sec-6-8-2-1">6.8.2.1. 用于过滤的生成器函数</a></li>
<li><a href="#sec-6-8-2-2">6.8.2.2. 用于映射的生成器函数</a></li>
<li><a href="#sec-6-8-2-3">6.8.2.3. 用于合并可迭代对象的生成器函数</a></li>
<li><a href="#sec-6-8-2-4">6.8.2.4. 用于扩展输出元素的生成器函数</a></li>
<li><a href="#sec-6-8-2-5">6.8.2.5. 用于重新排列元素的生成器函数</a></li>
</ul>
</li>
<li><a href="#sec-6-8-3">6.8.3. yield from 语法</a></li>
<li><a href="#sec-6-8-4">6.8.4. 把生成器当成协程</a></li>
</ul>
</li>
<li><a href="#sec-6-9">6.9. 字典</a>
<ul>
<li><a href="#sec-6-9-1">6.9.1. 广义映射类型</a></li>
<li><a href="#sec-6-9-2">6.9.2. 字典构造</a></li>
<li><a href="#sec-6-9-3">6.9.3. 字典推导</a></li>
<li><a href="#sec-6-9-4">6.9.4. 弹性键查询</a>
<ul>
<li><a href="#sec-6-9-4-1">6.9.4.1. defaultdict</a></li>
<li><a href="#sec-6-9-4-2">6.9.4.2. 使用特殊方法</a></li>
</ul>
</li>
<li><a href="#sec-6-9-5">6.9.5. OrderedDict</a></li>
<li><a href="#sec-6-9-6">6.9.6. ChainMap</a></li>
<li><a href="#sec-6-9-7">6.9.7. Counter</a></li>
<li><a href="#sec-6-9-8">6.9.8. UserDict</a></li>
<li><a href="#sec-6-9-9">6.9.9. 不可变映射类型</a></li>
</ul>
</li>
<li><a href="#sec-6-10">6.10. 集合</a>
<ul>
<li><a href="#sec-6-10-1">6.10.1. 创建</a></li>
<li><a href="#sec-6-10-2">6.10.2. 合集，交集，差集</a></li>
<li><a href="#sec-6-10-3">6.10.3. Hash 算法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. 函数</a>
<ul>
<li><a href="#sec-7-1">7.1. 提取函数签名</a></li>
<li><a href="#sec-7-2">7.2. 支持函数式编程的模块</a>
<ul>
<li><a href="#sec-7-2-1">7.2.1. operator 模块</a>
<ul>
<li><a href="#sec-7-2-1-1">7.2.1.1. itemgetter</a></li>
<li><a href="#sec-7-2-1-2">7.2.1.2. attrgetter</a></li>
<li><a href="#sec-7-2-1-3">7.2.1.3. methodcall</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7-3">7.3. 闭包</a>
<ul>
<li><a href="#sec-7-3-1">7.3.1. nonlocal</a></li>
<li><a href="#sec-7-3-2">7.3.2. 闭包的陷阱</a></li>
</ul>
</li>
<li><a href="#sec-7-4">7.4. 装饰器</a>
<ul>
<li><a href="#sec-7-4-1">7.4.1. functool.wraps</a></li>
<li><a href="#sec-7-4-2">7.4.2. functools.lru_cache</a></li>
<li><a href="#sec-7-4-3">7.4.3. functools.singledispatch</a></li>
</ul>
</li>
<li><a href="#sec-7-5">7.5. 参数</a>
<ul>
<li><a href="#sec-7-5-1">7.5.1. 命名关键字参数</a></li>
<li><a href="#sec-7-5-2">7.5.2. 默认参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-8">8. 模块</a>
<ul>
<li><a href="#sec-8-1">8.1. 包目录结构</a></li>
</ul>
</li>
<li><a href="#sec-9">9. 对象</a>
<ul>
<li><a href="#sec-9-1">9.1. == 与 is</a></li>
<li><a href="#sec-9-2">9.2. 弱引用</a>
<ul>
<li><a href="#sec-9-2-1">9.2.1. weakref.finalize</a></li>
<li><a href="#sec-9-2-2">9.2.2. weakref.WeakValueDictionary</a></li>
<li><a href="#sec-9-2-3">9.2.3. weakref.WeakKeyDictionary</a></li>
<li><a href="#sec-9-2-4">9.2.4. weakref.WeakSet</a></li>
<li><a href="#sec-9-2-5">9.2.5. 弱引用的局限</a></li>
</ul>
</li>
<li><a href="#sec-9-3">9.3. <span class="underline"><span class="underline">slots</span></span></a>
<ul>
<li><a href="#sec-9-3-1">9.3.1. 节省的内存也可能被再次吃掉</a></li>
<li><a href="#sec-9-3-2">9.3.2. 让对象支持弱引用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-10">10. 元编程</a>
<ul>
<li><a href="#sec-10-1">10.1. <span class="underline"><span class="underline">new</span></span></a></li>
<li><a href="#sec-10-2">10.2. 描述符</a>
<ul>
<li><a href="#sec-10-2-1">10.2.1. 属性查找</a>
<ul>
<li><a href="#sec-10-2-1-1">10.2.1.1. 从类中查找属性</a></li>
<li><a href="#sec-10-2-1-2">10.2.1.2. 从实例中查找属性</a></li>
</ul>
</li>
<li><a href="#sec-10-2-2">10.2.2. 覆盖型描述符</a>
<ul>
<li><a href="#sec-10-2-2-1">10.2.2.1. 没有 <span class="underline"><span class="underline">get</span></span> 方法的覆盖型描述符</a></li>
</ul>
</li>
<li><a href="#sec-10-2-3">10.2.3. 非覆盖型描述符</a></li>
</ul>
</li>
<li><a href="#sec-10-3">10.3. 元类</a>
<ul>
<li><a href="#sec-10-3-1">10.3.1. 使用 type 动态创建类</a></li>
<li><a href="#sec-10-3-2">10.3.2. 使用 metaclass 控制类的创建</a></li>
<li><a href="#sec-10-3-3">10.3.3. <span class="underline"><span class="underline">prepare</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-11">11. Unicode</a>
<ul>
<li><a href="#sec-11-1">11.1. 字符编码工作方式</a></li>
<li><a href="#sec-11-2">11.2. Code Point 转换</a></li>
<li><a href="#sec-11-3">11.3. 编解码</a></li>
</ul>
</li>
<li><a href="#sec-12">12. 参考资料</a></li>
</ul>
</div>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 类</a>
<ul>
<li><a href="#sec-1-1">1.1. 抽象类</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. 内置抽象基类</a></li>
<li><a href="#sec-1-1-2">1.1.2. 自定义抽象基类</a></li>
<li><a href="#sec-1-1-3">1.1.3. 虚拟子类</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. 继承</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 并发编程</a>
<ul>
<li><a href="#sec-2-1">2.1. 全局解释锁 (GIL)</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. I/O 密集型操作</a></li>
<li><a href="#sec-2-1-2">2.1.2. CPU 密集型操作</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. concurrent.futures 模块</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Executor.map()</a></li>
<li><a href="#sec-2-2-2">2.2.2. Executor.sumit()</a></li>
<li><a href="#sec-2-2-3">2.2.3. concurrent.futures.as_completed()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. async 并发编程</a>
<ul>
<li><a href="#sec-3-1">3.1. asyncio 基本思想 (面向事件编程)</a></li>
<li><a href="#sec-3-2">3.2. @asyncio.coroutine</a></li>
<li><a href="#sec-3-3">3.3. asyncio.Future</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. 从 Future ，Task ，和协程中产出值</a></li>
<li><a href="#sec-3-3-2">3.3.2. 协程和 Future 测试脚本</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. 常用 API</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. BaseEventLoop.run_in_executor()</a></li>
<li><a href="#sec-3-4-2">3.4.2. asyncio.as_complete()</a></li>
<li><a href="#sec-3-4-3">3.4.3. asyncio.Semaphore</a></li>
<li><a href="#sec-3-4-4">3.4.4. asyncio.wait()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. 上下文管理</a>
<ul>
<li><a href="#sec-4-1">4.1. for/else, while/else, try/else</a></li>
<li><a href="#sec-4-2">4.2. with</a></li>
<li><a href="#sec-4-3">4.3. contextlib 模块中的实用工具</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1. closing</a></li>
<li><a href="#sec-4-3-2">4.3.2. suppress</a></li>
<li><a href="#sec-4-3-3">4.3.3. redirect</a></li>
<li><a href="#sec-4-3-4">4.3.4. @contextmanager</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. 协程</a>
<ul>
<li><a href="#sec-5-1">5.1. 状态</a></li>
<li><a href="#sec-5-2">5.2. send()</a></li>
<li><a href="#sec-5-3">5.3. 执行过程举例</a></li>
<li><a href="#sec-5-4">5.4. 预激 (prime) 协程的装饰器</a></li>
<li><a href="#sec-5-5">5.5. 终止协程和异常处理</a>
<ul>
<li><a href="#sec-5-5-1">5.5.1. generator.throw()</a></li>
<li><a href="#sec-5-5-2">5.5.2. generator.close()</a></li>
</ul>
</li>
<li><a href="#sec-5-6">5.6. 有返回值的协程</a></li>
<li><a href="#sec-5-7">5.7. yield from</a>
<ul>
<li><a href="#sec-5-7-1">5.7.1. 结构示意图</a></li>
<li><a href="#sec-5-7-2">5.7.2. yield from 意义</a>
<ul>
<li><a href="#sec-5-7-2-1">5.7.2.1. RESULT = yield from EXPR 执行逻辑</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5-8">5.8. 使用协程进行离散事件仿真</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 数据结构</a>
<ul>
<li><a href="#sec-6-1">6.1. 元组</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. 基本用法</a>
<ul>
<li><a href="#sec-6-1-1-1">6.1.1.1. 占位</a></li>
<li><a href="#sec-6-1-1-2">6.1.1.2. 星号(*)的使用</a></li>
<li><a href="#sec-6-1-1-3">6.1.1.3. 嵌套拆包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. 具名元组</a></li>
<li><a href="#sec-6-3">6.3. 列表</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1. 切片选择</a></li>
<li><a href="#sec-6-3-2">6.3.2. 切片赋值</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4. bisect</a>
<ul>
<li><a href="#sec-6-4-1">6.4.1. 搜索</a></li>
<li><a href="#sec-6-4-2">6.4.2. 插入新元素</a></li>
</ul>
</li>
<li><a href="#sec-6-5">6.5. 数组</a></li>
<li><a href="#sec-6-6">6.6. 内存视图</a></li>
<li><a href="#sec-6-7">6.7. 双向队列</a></li>
<li><a href="#sec-6-8">6.8. 生成器</a>
<ul>
<li><a href="#sec-6-8-1">6.8.1. 生成器函数</a></li>
<li><a href="#sec-6-8-2">6.8.2. 标准库中的生成器函数</a>
<ul>
<li><a href="#sec-6-8-2-1">6.8.2.1. 用于过滤的生成器函数</a></li>
<li><a href="#sec-6-8-2-2">6.8.2.2. 用于映射的生成器函数</a></li>
<li><a href="#sec-6-8-2-3">6.8.2.3. 用于合并可迭代对象的生成器函数</a></li>
<li><a href="#sec-6-8-2-4">6.8.2.4. 用于扩展输出元素的生成器函数</a></li>
<li><a href="#sec-6-8-2-5">6.8.2.5. 用于重新排列元素的生成器函数</a></li>
</ul>
</li>
<li><a href="#sec-6-8-3">6.8.3. yield from 语法</a></li>
<li><a href="#sec-6-8-4">6.8.4. 把生成器当成协程</a></li>
</ul>
</li>
<li><a href="#sec-6-9">6.9. 字典</a>
<ul>
<li><a href="#sec-6-9-1">6.9.1. 广义映射类型</a></li>
<li><a href="#sec-6-9-2">6.9.2. 字典构造</a></li>
<li><a href="#sec-6-9-3">6.9.3. 字典推导</a></li>
<li><a href="#sec-6-9-4">6.9.4. 弹性键查询</a>
<ul>
<li><a href="#sec-6-9-4-1">6.9.4.1. defaultdict</a></li>
<li><a href="#sec-6-9-4-2">6.9.4.2. 使用特殊方法</a></li>
</ul>
</li>
<li><a href="#sec-6-9-5">6.9.5. OrderedDict</a></li>
<li><a href="#sec-6-9-6">6.9.6. ChainMap</a></li>
<li><a href="#sec-6-9-7">6.9.7. Counter</a></li>
<li><a href="#sec-6-9-8">6.9.8. UserDict</a></li>
<li><a href="#sec-6-9-9">6.9.9. 不可变映射类型</a></li>
</ul>
</li>
<li><a href="#sec-6-10">6.10. 集合</a>
<ul>
<li><a href="#sec-6-10-1">6.10.1. 创建</a></li>
<li><a href="#sec-6-10-2">6.10.2. 合集，交集，差集</a></li>
<li><a href="#sec-6-10-3">6.10.3. Hash 算法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. 函数</a>
<ul>
<li><a href="#sec-7-1">7.1. 提取函数签名</a></li>
<li><a href="#sec-7-2">7.2. 支持函数式编程的模块</a>
<ul>
<li><a href="#sec-7-2-1">7.2.1. operator 模块</a>
<ul>
<li><a href="#sec-7-2-1-1">7.2.1.1. itemgetter</a></li>
<li><a href="#sec-7-2-1-2">7.2.1.2. attrgetter</a></li>
<li><a href="#sec-7-2-1-3">7.2.1.3. methodcall</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7-3">7.3. 闭包</a>
<ul>
<li><a href="#sec-7-3-1">7.3.1. nonlocal</a></li>
<li><a href="#sec-7-3-2">7.3.2. 闭包的陷阱</a></li>
</ul>
</li>
<li><a href="#sec-7-4">7.4. 装饰器</a>
<ul>
<li><a href="#sec-7-4-1">7.4.1. functool.wraps</a></li>
<li><a href="#sec-7-4-2">7.4.2. functools.lru_cache</a></li>
<li><a href="#sec-7-4-3">7.4.3. functools.singledispatch</a></li>
</ul>
</li>
<li><a href="#sec-7-5">7.5. 参数</a>
<ul>
<li><a href="#sec-7-5-1">7.5.1. 命名关键字参数</a></li>
<li><a href="#sec-7-5-2">7.5.2. 默认参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-8">8. 模块</a>
<ul>
<li><a href="#sec-8-1">8.1. 包目录结构</a></li>
</ul>
</li>
<li><a href="#sec-9">9. 对象</a>
<ul>
<li><a href="#sec-9-1">9.1. == 与 is</a></li>
<li><a href="#sec-9-2">9.2. 弱引用</a>
<ul>
<li><a href="#sec-9-2-1">9.2.1. weakref.finalize</a></li>
<li><a href="#sec-9-2-2">9.2.2. weakref.WeakValueDictionary</a></li>
<li><a href="#sec-9-2-3">9.2.3. weakref.WeakKeyDictionary</a></li>
<li><a href="#sec-9-2-4">9.2.4. weakref.WeakSet</a></li>
<li><a href="#sec-9-2-5">9.2.5. 弱引用的局限</a></li>
</ul>
</li>
<li><a href="#sec-9-3">9.3. <span class="underline"><span class="underline">slots</span></span></a>
<ul>
<li><a href="#sec-9-3-1">9.3.1. 节省的内存也可能被再次吃掉</a></li>
<li><a href="#sec-9-3-2">9.3.2. 让对象支持弱引用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-10">10. 元编程</a>
<ul>
<li><a href="#sec-10-1">10.1. <span class="underline"><span class="underline">new</span></span></a></li>
<li><a href="#sec-10-2">10.2. 描述符</a>
<ul>
<li><a href="#sec-10-2-1">10.2.1. 属性查找</a>
<ul>
<li><a href="#sec-10-2-1-1">10.2.1.1. 从类中查找属性</a></li>
<li><a href="#sec-10-2-1-2">10.2.1.2. 从实例中查找属性</a></li>
</ul>
</li>
<li><a href="#sec-10-2-2">10.2.2. 覆盖型描述符</a>
<ul>
<li><a href="#sec-10-2-2-1">10.2.2.1. 没有 <span class="underline"><span class="underline">get</span></span> 方法的覆盖型描述符</a></li>
</ul>
</li>
<li><a href="#sec-10-2-3">10.2.3. 非覆盖型描述符</a></li>
</ul>
</li>
<li><a href="#sec-10-3">10.3. 元类</a>
<ul>
<li><a href="#sec-10-3-1">10.3.1. 使用 type 动态创建类</a></li>
<li><a href="#sec-10-3-2">10.3.2. 使用 metaclass 控制类的创建</a></li>
<li><a href="#sec-10-3-3">10.3.3. <span class="underline"><span class="underline">prepare</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-11">11. Unicode</a>
<ul>
<li><a href="#sec-11-1">11.1. 字符编码工作方式</a></li>
<li><a href="#sec-11-2">11.2. Code Point 转换</a></li>
<li><a href="#sec-11-3">11.3. 编解码</a></li>
</ul>
</li>
<li><a href="#sec-12">12. 参考资料</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="meta">
<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">Author</td>
<td class="left">Hao Ruan (haoru@cisco.com)</td>
</tr>

<tr>
<td class="left">Date</td>
<td class="left">2018-02-22 21:27:08</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 抽象类</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 内置抽象基类</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
大多数内置抽象基类在 <code>collection.abc</code>, <code>numbers</code> 和 <code>io</code> 模块中定义，
<code>collection.abc</code> 中的抽象基类最常用。
</p>

<p>
<a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes">collection.abc 中各个抽象基类的总结</a>
</p>
</div>
</div>


<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 自定义抽象基类</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
抽象基类中的抽象方法可以有实现代码。
</p>

<p>
即使实现了， <b>子类也必须覆盖抽象方法</b> ，但是在子类中可以使用 <code>super()</code> 函数调用抽象方法。
</p>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> abc <span style="color: #a1db00;">import</span> ABC, abstractmethod

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Pet</span>(ABC):
    <span style="color: #00d7af;">@classmethod</span>
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">from_name</span>(cls, name):
        <span style="color: #a1db00;">for</span> s_cls <span style="color: #a1db00;">in</span> cls.__subclasses__():  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#27880;&#24847; __subclasses__ &#30340;&#29992;&#27861;</span>
            <span style="color: #a1db00;">if</span> name == s_cls.<span style="color: #d18aff;">__name__</span>.lower():
                <span style="color: #a1db00;">return</span> s_cls()

    <span style="color: #00d7af;">@abstractmethod</span>
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">hello</span>(<span style="color: #a1db00;">self</span>):
        <span style="color: #a1db00;">pass</span>

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Dog</span>(Pet):

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">hello</span>(<span style="color: #a1db00;">self</span>):
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"WonWonWon"</span>)

Pet.from_name(<span style="color: #ff4ea3;">"dog"</span>).hello()
</pre>
</div>

<pre class="example">
WonWonWon
</pre>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> 虚拟子类</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
注册虚拟子类的方式是在抽象基类上调用 <code>register</code> 方法，
<code>register</code> 方法通常作为普通函数调用，也可以作为装饰器使用。
</p>

<p>
这么做之后，注册的类会变成抽象基类的虚拟子类，而且 <code>issubclass</code> 和 <code>isinstance</code> 都能识别，
<b>但是注册的类不会从抽象基类中继承任何方法或属性</b> 。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #00d7af;">@Pet.register</span>
<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Cat</span>:
    <span style="color: #a1db00;">pass</span>

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Bird</span>(<span style="color: #d18aff;">list</span>):
    <span style="color: #a1db00;">pass</span>

Pet.register(Bird)

log(<span style="color: #ff4ea3;">"issubclass(Cat, Pet)"</span>, <span style="color: #d18aff;">issubclass</span>(Cat, Pet))
log(<span style="color: #ff4ea3;">"isinstance(Bird(), Pet)"</span>, <span style="color: #d18aff;">isinstance</span>(Bird(), Pet))
log(<span style="color: #ff4ea3;">"Bird.__mro__"</span>, Bird.__mro__)
</pre>
</div>

<pre class="example">
==== issubclass(Cat, Pet) ====
True
== isinstance(Bird(), Pet) ===
True
======== Bird.__mro__ ========
(&lt;class '__main__.Bird'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)
</pre>

<p>
虚拟子类的 <code>__mro__</code> 属性中没有虚拟基类，也从侧面反映了虚拟子类没有从虚拟基类中继承任何方法。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 继承</h3>
<div class="outline-text-3" id="text-1-2">
<p>
直接子类化内置类型 (如 <code>dict</code>, <code>list</code> 或 <code>str</code>) 容易出错，
因为内置类型的方法通常会忽略用户覆盖的方法。
</p>

<p>
<b>不要子类化内置类型</b> ，用户自己定义的类应该继承 <code>collection</code> 模块中的类，
如 UserDict, UserList 和 UserString ，这些类 <b>做了特殊设计</b> ，因此易于扩展。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 并发编程</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 全局解释锁 (GIL)</h3>
<div class="outline-text-3" id="text-2-1">
<p>
CPython 解释器本身不是线程安全的，因此有全局解释器锁 (GIL) ，一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程不能同时使用多个 CPU 。
</p>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> I/O 密集型操作</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL 。
这意味着在 Python 语言这个层次上可以使用多线程，I/O 密集型的程序能从中受益。
( <code>time.sleep()</code> 函数也会释放 GIL)
</p>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> CPU 密集型操作</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
使用 ProcessPoolExecutor 类把工作分配给多个进程处理可以实现真正的并行运算。因此，如果需要做 CPU 密集型处理，可以使用它绕开 GIL ，从而利用所有可用的 CPU 。(多个 Python 进程有各自独立的 GIL 锁，互不影响)
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> concurrent.futures 模块</h3>
<div class="outline-text-3" id="text-2-2">
<p>
concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPoolExecutor 类，
这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。
</p>

<p>
通常情况下 future 对象不应由用户创建，而是由并发框架 (concurrent.futures 或 asyncio) 来实例化。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Executor.map()</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
<b>Executor.map(func, *iterables, timeout=None, chunksize=1)</b>
</p>

<p>
chunksize 只对 ProcessPoolExecutor 有用，用于切分 iterables ，提高运行效率。
</p>

<p>
因为 future 结果的返回涉及到 IPC ，如果每个进程每次消耗 iterables 中的一个数据，整个过程涉及多个 IPC ，这样效率不高；但如果对 iterables 进行切分，N 个 数据同时交给一个进程进行处理，运算结果通过一个 IPC 一并返回，这样就可以提升效率。
</p>

<p>
返回值是一个迭代器， <b>迭代器的 <span class="underline"><span class="underline">next</span></span> 方法调用各个 future 对象的 result 方法，得到各个 future 的结果。</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> concurrent.futures <span style="color: #a1db00;">import</span> ThreadPoolExecutor
<span style="color: #a1db00;">import</span> time

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">sleep_and_double</span>(value):
    time.sleep(value)
    <span style="color: #a1db00;">return</span> value * 2

<span style="color: #a1db00;">with</span> ThreadPoolExecutor(max_workers=4) <span style="color: #a1db00;">as</span> executor:
    <span style="color: #ff8700;">time0</span> =time.time()
    <span style="color: #ff8700;">values</span> = executor.<span style="color: #d18aff;">map</span>(sleep_and_double, [3, 2, 1])
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed0: "</span>, time_delta)
    <span style="color: #a1db00;">print</span>(values)
    <span style="color: #ff8700;">time0</span> =time.time()
    <span style="color: #a1db00;">print</span>([v <span style="color: #a1db00;">for</span> v <span style="color: #a1db00;">in</span> values])
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed1: "</span>, time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  0.0011630058288574219
&lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10b21d0f8&gt;
[6, 4, 2]
time consumed1:  3.0038888454437256
</pre>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Executor.sumit()</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
<code>Executor.sumit(fn, *args, **kwargs)</code>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">with</span> ThreadPoolExecutor(max_workers=1) <span style="color: #a1db00;">as</span> executor:
    <span style="color: #ff8700;">time0</span> = time.time()
    <span style="color: #ff8700;">future</span> = executor.submit(sleep_and_double, 3)
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed0: "</span>, time_delta)
    <span style="color: #ff8700;">time0</span> = time.time()
    <span style="color: #a1db00;">print</span>(future.result())
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed1: "</span>, time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  0.0004010200500488281
6
time consumed1:  3.0031349658966064
</pre>
</div>
</div>


<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> concurrent.futures.as_completed()</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
<b>concurrent.futures.as_completed(fs, timeout=None)</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> concurrent <span style="color: #a1db00;">import</span> futures
<span style="color: #ff8700;">fs</span> = []

<span style="color: #a1db00;">with</span> ThreadPoolExecutor(max_workers=5) <span style="color: #a1db00;">as</span> executor:
    <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> [5, 4, 3, 2, 1]:
        <span style="color: #ff8700;">f</span> = executor.submit(sleep_and_double, i)
        fs.append(f)
    <span style="color: #ff8700;">time0</span> = time.time()
    <span style="color: #ff8700;">finishes</span> = futures.as_completed(fs)
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed0: "</span>, time_delta)
    <span style="color: #ff8700;">time0</span> = time.time()
    <span style="color: #a1db00;">print</span>([f.result() <span style="color: #a1db00;">for</span> f <span style="color: #a1db00;">in</span> finishes])
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time consumed1: "</span>, time_delta)
</pre>
</div>

<pre class="example">
time consumed0:  2.86102294921875e-06
[2, 4, 6, 8, 10]
time consumed1:  5.004166841506958
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> async 并发编程</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>适合 asyncio API 的协程在定义体中必须使用 yield from ，而不能用 yield 。</b>
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> asyncio 基本思想 (面向事件编程)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
在 asyncio 中，基本的流程和 <a href="#simulation">使用协程进行离散事件仿真</a> 中提到的是一样的：
</p>

<ol class="org-ol">
<li>在一个单线程中使用主循环依次激活队列里的协程
</li>
<li>各个协程向前执行几步，然后把控制权让给主循环
</li>
<li>主循环再激活队列里的下一个协程
</li>
</ol>

<p>
编写基于 asyncio 的程序需注意下述细节：
</p>

<ul class="org-ul">
<li>编写的协程链始终通过把最外层委派生成器传给 asyncio 包中的某个函数驱动，例如 <code>loop.run_until_complete()</code> 。即我们的代码不通过调用 <code>next()</code> 函数或 <code>send()</code> 方法驱动协程。驱动由 asyncio 包实现的事件循环去做。
</li>

<li>编写的协程链最终通过 <code>yield from</code> 把职责委托给 asyncio 包中的某个协程函数，如 <code>yeild from asyncio.sleep()</code> ，或者其他库中实现高层协议的协程，如 <code>response = yield from aiohttp.request('GET', url)</code> 。也就是说，最内层的子生成器是库中真正执行 I/O 操作的函数，而不是我们自己编写的函数。
</li>
</ul>

<p>
概括起来就是：使用 asyncio 包时，我们编写的代码中包含委派生成器，
而生成器最终把职责 <b>委托</b> 给 asyncio 包或第三方库中的协程。
这种处理方式相当于架起了管道，让 asyncio 事件循环驱动执行低层异步 I/O 操作的库函数。
</p>
</div>
</div>


<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> @asyncio.coroutine</h3>
<div class="outline-text-3" id="text-3-2">
<p>
交给 asyncio 处理的协程要使用 <code>@asyncio.coroutine</code> 装饰，这虽不是强制要求，但是建议这么做。
因为这样能在一众普通函数中把协程凸显出来，也有助于调试：如果还没从协程中产出值，协程就被垃圾回收了，可以发出警告。
也可以使用 <b>async</b> 关键字。
</p>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> asyncio.Future</h3>
<div class="outline-text-3" id="text-3-3">
<p>
在 asyncio 包中，=BaseEventLoop.create_task()= 方法接收一个协程，排定它的运行时间，
然后返回一个 asyncio.Task 实例，也是 asyncio.Future 类的实例，因为前者是后者的子类，用于包装协程。
</p>

<p>
asyncio.Future 类的目的是与 <code>yield from</code> 一起使用，通常不需要使用以下方法：
</p>

<ul class="org-ul">
<li>无需调用 <code>asyncio.Future.add_done_callback()</code>

<p>
因为可以直接把在 Future 运行结束后执行的操作放在 <code>yield from</code> 表达式后面。
</p>
</li>
<li>无需调用 <code>asyncio.Future.result()</code>

<p>
因为 <code>yield from</code> 从 Future 对象中产出的值就是结果，例如： <code>result = yield from my_future</code> 。
</p>
</li>
</ul>
</div>


<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> 从 Future ，Task ，和协程中产出值</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
在 asyncio 包中，可以这样写： <code>result = yield from foo()</code> ，其中 foo 可以是协程函数，或者是返回 asyncio.Future 或 Task 实例的普通函数， <b>这是 asyncio 包的 API 中很多地方可以互换协程和 Future 对象的原因之一。</b>
</p>

<p>
获取 Task 对象有两种主要方式：
</p>

<ul class="org-ul">
<li><code>asyncio.async(coro_or_future, *, loop=None)</code>

<p>
这个函数排定了协程的运行时间并统一了协程和 Future ：如果第一个参数是 Future 或 Task 对象，则原封不动地返回；如果是协程，则会调用 <code>loop.create_task()</code> 方法创建 Task 对象。loop 关键词参数是可选的，用于传入事件循环，如果没有传入，则将调用 <code>asyncio.get_event_loop()</code> 获取。
</p>
</li>

<li><code>BaseEventLoop.create_task(coro)</code>

<p>
这个方法排定了协程的执行时间，返回 Task 对象。
</p>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> 协程和 Future 测试脚本</h4>
<div class="outline-text-4" id="text-3-3-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> asyncio
<span style="color: #a1db00;">import</span> time

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">run_sync</span>(coro_or_future):
    <span style="color: #ff8700;">loop</span> = asyncio.get_event_loop()
    <span style="color: #a1db00;">return</span> loop.run_until_complete(coro_or_future)

<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">test_coro</span>():
    <span style="color: #ff8700;">time0</span> = time.time()
    <span style="color: #a1db00;">await</span> asyncio.sleep(3)
    <span style="color: #ff8700;">time_delta</span> = time.time() - time0
    <span style="color: #a1db00;">return</span> time_delta

<span style="color: #ff8700;">result</span> = run_sync(test_coro())
log(<span style="color: #ff4ea3;">"result"</span>, result)
</pre>
</div>

<pre class="example">
=========== result ===========
3.0022881031036377
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 常用 API</h3>
<div class="outline-text-3" id="text-3-4">
</div><div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> BaseEventLoop.run_in_executor()</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
<b>BaseEventLoop.run_in_executor(executor, func, *args)</b>
</p>

<p>
asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，
可以调用 run_in_executor 方法，把可调用对象发给它执行。
</p>

<p>
第一个参数是 Executor 实例，如果为 None ，则使用默认的 ThreadPoolExecutor 实例。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">loop</span> = asyncio.get_event_loop()
loop.run_in_executor(<span style="color: #5fafd7;">None</span>, )
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> asyncio.as_complete()</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
<b>asyncio.as_complete(fs, *, loop=None, timeout=None)</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> asyncio
<span style="color: #a1db00;">import</span> time

<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">foo</span>(seconds):
    <span style="color: #a1db00;">await</span> asyncio.sleep(seconds)
    <span style="color: #a1db00;">return</span> seconds

<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">coro</span>():
    <span style="color: #ff8700;">fs</span> = [foo(10), foo(5), foo(1)]
    <span style="color: #a1db00;">for</span> f <span style="color: #a1db00;">in</span> asyncio.as_completed(fs):
        <span style="color: #ff8700;">time0</span> = time.time()
        <span style="color: #ff8700;">result</span> = <span style="color: #a1db00;">await</span> f
        <span style="color: #a1db00;">print</span>(result, <span style="color: #ff4ea3;">"delta"</span>, time.time() - time0)

asyncio.get_event_loop().run_until_complete(coro())
</pre>
</div>

<pre class="example">
1 delta 1.0034959316253662
5 delta 3.997586965560913
10 delta 5.0023698806762695
</pre>
</div>
</div>


<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> asyncio.Semaphore</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
<b>asyncio.Semaphore(value=1, *, loop=None)</b>
</p>

<p>
Semaphore 类用于限制并发请求数量。
</p>

<p>
Semaphore 对象维护一个内部计数器:
</p>

<ul class="org-ul">
<li>如果在对象上调用 <code>acquire()</code> 方法，计数器递减；
</li>
<li>如果调用 <code>release()</code> 方法，计数器递增。
</li>
</ul>

<p>
可以把 Semaphore 对象 <span class="underline">当作上下文管理器使用</span> 。
</p>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">time0</span> = time.time()

<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">foo</span>(semaphore):
    <span style="color: #a1db00;">with</span> (<span style="color: #a1db00;">await</span> semaphore):
        <span style="color: #a1db00;">await</span> asyncio.sleep(2)
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"time delta:"</span>, time.time() - time0)

<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">coro</span>():
    <span style="color: #ff8700;">semaphore</span> = asyncio.Semaphore(3)
    <span style="color: #ff8700;">fs</span> = [foo(semaphore) <span style="color: #a1db00;">for</span> _ <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(5)]
    <span style="color: #a1db00;">for</span> f <span style="color: #a1db00;">in</span> asyncio.as_completed(fs):
        <span style="color: #a1db00;">await</span> f

asyncio.get_event_loop().run_until_complete(coro())
</pre>
</div>

<pre class="example">
time delta: 2.0043020248413086
time delta: 2.0048139095306396
time delta: 2.0052309036254883
time delta: 4.010546922683716
time delta: 4.010922908782959
</pre>
</div>
</div>


<div id="outline-container-sec-3-4-4" class="outline-4">
<h4 id="sec-3-4-4"><span class="section-number-4">3.4.4</span> asyncio.wait()</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
<b>asyncio.wait(futures, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</b>
</p>

<p>
参数是一个由 Future 或协程构成的可迭代对象，wait 会分别把各个协程包装进一个 Task 对象。
wait 是协程函数，因此它 <b>不会阻塞</b> ，默认行为是等传给它的所有协程运行完毕后结束。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> random
<span style="color: #a1db00;">async def</span> <span style="color: #ffd700;">foo</span>():
    <span style="color: #ff8700;">sec</span> = random.randint(1, 3)
    <span style="color: #a1db00;">await</span> asyncio.sleep(sec)
    <span style="color: #a1db00;">return</span> sec

<span style="color: #ff8700;">to_do</span> = [foo() <span style="color: #a1db00;">for</span> _ <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(10)]
<span style="color: #ff8700;">wait_coro</span> = asyncio.wait(to_do)
<span style="color: #ff8700;">result</span> = asyncio.get_event_loop().run_until_complete(wait_coro)
log(<span style="color: #ff4ea3;">"result"</span>, result)
</pre>
</div>

<pre class="example">
=========== result ===========
({&lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=2&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=3&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=3&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=2&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=3&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=3&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=1&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=3&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=2&gt;, &lt;Task finished coro=&lt;foo() done, defined at &lt;ipython-input-2240-3b55a6d5d391&gt;:2&gt; result=1&gt;}, set())
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 上下文管理</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> for/else, while/else, try/else</h3>
<div class="outline-text-3" id="text-4-1">
<p>
在所有情况下，如果因为异常或者 return，break 或 continue 语句导致控制权跳到了块之外，else 子句也会被跳过。
</p>

<ul class="org-ul">
<li>for/else

<p>
仅当 for 循环运行完毕时 (即 for 循环没有被 break 语句中止) 才运行 else 块。
</p>
</li>

<li>while/else

<p>
仅当 while 循环因为条件为假值而退出时 (即 while 循环没有被 break 语句中止) 才运行 else 块。
</p>
</li>

<li>try/else

<p>
仅当 try 块中没有异常抛出时才运行 else 块， <b>else 子句抛出的异常不会由前面的 except 子句处理。</b>
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> with</h3>
<div class="outline-text-3" id="text-4-2">
<p>
with 语句的目的是简化 try/finally 模式。
</p>

<p>
上下文管理器协议包含 <code>__enter__</code> 和 <code>__exit__</code> 两个方法:
</p>

<ul class="org-ul">
<li>with 语句开始运行时，会在上下文管理器对象上调用 <code>__enter__</code> 方法。
</li>
<li>with 语句运行结束后，会在上下文管理器对象上调用 <code>__exit__</code> 方法，以此扮演 finally 子句的角色。
</li>
</ul>

<p>
<code>__exit__</code> 方法如果返回 True 之外的值 (包括 None) ，则 with 块中的任何异常都会向上冒泡。
如果返回 True ，即告诉解释器，异常已经处理了。
</p>
</div>
</div>


<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> contextlib 模块中的实用工具</h3>
<div class="outline-text-3" id="text-4-3">
</div><div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> closing</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
如果对象提供了 <code>close()</code> 方法，但没有实现 <code>__enter__/__exit__</code> 协议，则可以用这个函数构建上下文管理器。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> contextlib <span style="color: #a1db00;">import</span> closing

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Door</span>:

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">open</span>(<span style="color: #a1db00;">self</span>):
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"door opened"</span>)

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">close</span>(<span style="color: #a1db00;">self</span>):
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"door closed"</span>)

<span style="color: #a1db00;">with</span> closing(Door()) <span style="color: #a1db00;">as</span> door:
    door.<span style="color: #d18aff;">open</span>()
</pre>
</div>

<pre class="example">
door opened
door closed
</pre>
</div>
</div>


<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> suppress</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
构建忽略指定异常的上下文管理器。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> contextlib <span style="color: #a1db00;">import</span> suppress
<span style="color: #a1db00;">import</span> os

<span style="color: #a1db00;">with</span> suppress(FileNotFoundError):
    os.remove(<span style="color: #ff4ea3;">'somefile.tmp'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3"><span class="section-number-4">4.3.3</span> redirect</h4>
<div class="outline-text-4" id="text-4-3-3">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> io
<span style="color: #a1db00;">from</span> contextlib <span style="color: #a1db00;">import</span> redirect_stdout

<span style="color: #ff8700;">f</span> = io.StringIO()
<span style="color: #a1db00;">with</span> redirect_stdout(f):
    <span style="color: #d18aff;">help</span>(<span style="color: #d18aff;">pow</span>)

log(<span style="color: #ff4ea3;">"f.getvalue()"</span>, f.getvalue())
</pre>
</div>

<pre class="example">
======== f.getvalue() ========
Help on built-in function pow in module builtins:

pow(x, y, z=None, /)
    Equivalent to x**y (with two arguments) or x**y % z (with three arguments)

    Some types, such as ints, are able to use a more efficient algorithm when
    invoked using the three argument form.
</pre>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">with</span> <span style="color: #d18aff;">open</span>(<span style="color: #ff4ea3;">'/tmp/help.txt'</span>, <span style="color: #ff4ea3;">'w'</span>) <span style="color: #a1db00;">as</span> f:
    <span style="color: #a1db00;">with</span> redirect_stdout(f):
        <span style="color: #d18aff;">help</span>(<span style="color: #d18aff;">pow</span>)
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4"><span class="section-number-4">4.3.4</span> @contextmanager</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。
</p>

<p>
在使用 @contextmanager 装饰的生成器中，yield 语句的作用是把函数的定义体分成两部分：
</p>

<ul class="org-ul">
<li>yield 语句前面的所有代码在 with 块开始时 (即解释器调用 <code>__enter__</code> 方法时) 执行
</li>
<li>yield 语句后面的代码在 with 块结束时 (即调用 <code>__exit__</code> 方法时) 执行
</li>
</ul>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> contextlib <span style="color: #a1db00;">import</span> contextmanager

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Query</span>(<span style="color: #d18aff;">object</span>):

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__init__</span>(<span style="color: #a1db00;">self</span>, name):
        <span style="color: #a1db00;">self</span>.name = name

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">query</span>(<span style="color: #a1db00;">self</span>):
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'Query info about %s...'</span> % <span style="color: #a1db00;">self</span>.name)

<span style="color: #00d7af;">@contextmanager</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">create_query</span>(name):
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'Begin'</span>)
    <span style="color: #a1db00;">with</span> suppress(<span style="color: #00d7af;">Exception</span>):
        <span style="color: #a1db00;">yield</span> Query(name)  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#38656;&#35201;&#20351;&#29992; as</span>
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'End'</span>)

<span style="color: #a1db00;">with</span> create_query(<span style="color: #ff4ea3;">'Bob'</span>) <span style="color: #a1db00;">as</span> q:
    q.query()
</pre>
</div>

<pre class="example">
Begin
Query info about Bob...
End
</pre>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #00d7af;">@contextmanager</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">tag</span>(name):
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"&lt;%s&gt;"</span> % name, end=<span style="color: #ff4ea3;">''</span>)
    <span style="color: #a1db00;">with</span> suppress(<span style="color: #00d7af;">Exception</span>):
        <span style="color: #a1db00;">yield</span>  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#26080;&#38656;&#20351;&#29992; as</span>
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"&lt;/%s&gt;"</span> % name)

<span style="color: #a1db00;">with</span> tag(<span style="color: #ff4ea3;">"h1"</span>):
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"hello"</span>, end=<span style="color: #ff4ea3;">''</span>)
</pre>
</div>

<pre class="example">
&lt;h1&gt;hello&lt;/h1&gt;
</pre>

<p>
本质上，contextlib.contextmanager 装饰器会把函数包装成实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法的类 (类的名称是 _GeneraorContextManager) 。这个类的 <code>__enter__</code> 方法有如下作用：
</p>

<ul class="org-ul">
<li>调用生成器函数，保存生成器对象 (这里把它成为 gen)
</li>
<li>调用 <code>next(gen)</code> ，执行到 yield 关键字所在位置
</li>
<li>返回上一步 <code>next(gen)</code> 产出的值，以便把产出的值绑定到 with/as 语句中的目标变量上
</li>
</ul>

<p>
with 块终止时， <code>__exit__</code> 方法会做以下几件事：
</p>

<ul class="org-ul">
<li>检查有没有异常，如果有，调用 <code>gen.throw(ex)</code> ，在生成器函数定义体中包含 yield 关键字的那一行抛出异常
</li>
<li>否则，调用 <code>next(gen)</code> ，继续执行生成器函数定义体中 yield 语句之后的代码
</li>
</ul>


<p>
<b>注意:</b>
</p>

<p>
如果在 with 块中抛出了异常，Python 解释器会将其捕获，然后会在生成器函数中 yield 表达式处再次抛出。因此使用 @contextmanager 装饰器时，要把 yield 语句放在 try/finally 语句中 (或者放在 with 语句中) ，这是无法避免的，因为我们永远不知道使用上下文管理器的用户会在 with 块中做什么。
</p>

<p>
另外，@contextmanager 装饰器提供的 <code>__exit__</code> 方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。如果不想让 @contextmanager 压制异常，必须在被装饰的函数中显示重新抛出异常。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 协程</h2>
<div class="outline-text-2" id="text-5">
<p>
协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。
</p>

<p>
协程中的关键字 yield 可以视作控制流程的方式。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 状态</h3>
<div class="outline-text-3" id="text-5-1">
<p>
可以使用 <code>inspect.getgeneratorstate()</code> 获取协程四个状态中的一个：
</p>

<ol class="org-ol">
<li>GEN_CREATED：等待开始执行
</li>
<li>GEN_RUNNING：正在执行
</li>
<li>GEN_SUSPENDED：在 yield 表达式处暂停
</li>
<li>GEN_CLOSED：执行结束
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> send()</h3>
<div class="outline-text-3" id="text-5-2">
<p>
仅当协程 cr 处于暂停状态才能调用 send 方法。
</p>

<p>
如果协程还没激活 (即状态是 GEN_CREATED) ，可以调用 <code>cr.send(None)</code> 激活协程，这和使用 <code>next(cr)</code> 效果一样。
</p>
</div>
</div>


<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 执行过程举例</h3>
<div class="outline-text-3" id="text-5-3">

<div id="coroutine" class="figure">
<p><img src="img/py3_coroutine.png" alt="py3_coroutine.png">
</p>
<p><span class="figure-number">Figure 1:</span> 协程执行过程</p>
</div>

<ol class="org-ol">
<li>调用 <code>next(my_coro2)</code> ，打印第一个消息，然后执行 yield a ，产出数字 14
</li>
<li>调用 <code>my_coro2.send(28)</code> ，把 28 赋值给 b ，打印第二个消息，然后执行 <code>yield a + b</code> ，产出 42
</li>
<li>调用 <code>my_coro2.send(99)</code> ，把 99 赋值给 c ，打印第三个消息，协程终止
</li>
</ol>

<p>
注意，各个阶段都在 yield 表达式中结束，而且下一个阶段都从那一行代码开始，然后再把 yield 表达式的值赋给变量。
</p>
</div>
</div>



<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 预激 (prime) 协程的装饰器</h3>
<div class="outline-text-3" id="text-5-4">
<p>
如果不预激，则协程没什么用，即调用 <code>send()</code> 之前，一定要先调用 <code>next()</code> 。
</p>

<p>
如果无需调用 <code>send()</code> ，即 yield 只是为了产出值的情况下，则不需要预激。
</p>

<p>
有时可以自定义一个预激装饰器以简化协程的用法：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> functools <span style="color: #a1db00;">import</span> wraps

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">coroutine</span>(func):

    <span style="color: #00d7af;">@wraps</span>(func)
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">primer</span>(*args, **kwargs):
        <span style="color: #ff8700;">gen</span> = func(*args, **kwargs)
        <span style="color: #d18aff;">next</span>(gen)
        <span style="color: #a1db00;">return</span> gen

    <span style="color: #a1db00;">return</span> primer
</pre>
</div>

<p>
<b>注意</b> ：
</p>

<p>
使用 yield from 调用协程时，会自动预激，因此与上面的做法不兼容。
标准库里的 asyncio.coroutine 装饰器不会预激协程，因此可以兼容 yield from 语法。
</p>
</div>
</div>


<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 终止协程和异常处理</h3>
<div class="outline-text-3" id="text-5-5">
<p>
协程中未处理的异常会向上冒泡，传给调用协程的对象，未处理的异常会导致协程终止。
</p>
</div>


<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1"><span class="section-number-4">5.5.1</span> generator.throw()</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
<code>generator.throw(exc_type[, exc_value[, traceback]])</code>
</p>

<p>
该方法会导致生成器在暂停的 yield 表达式处抛出指定的异常。
如果生成器内部处理了该异常，代码会向前执行到下一个 yield 表达式处，而产出的值会成为该方法的返回值。
如果生成器内部没有处理这个异常，异常会向上冒泡，传到调用方的上下文中。
</p>
</div>
</div>


<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2"><span class="section-number-4">5.5.2</span> generator.close()</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
该方法使得生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。
如果生成器内部没有处理这个异常，调用方不会报错。如果收到 GeneratorExit 异常，生成器不能产出值，否则解释器会抛出 RuntimeError 异常。
</p>

<p>
如果不管协程如何结束都需要做清理工作，需要把协程定义体中相关的代码放入 try/finally 块中。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 有返回值的协程</h3>
<div class="outline-text-3" id="text-5-6">
<p>
在 Python3.3 之前，如果生成器返回值，解释器会报错。
</p>

<p>
return 的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性。这样的做法有点奇怪，但是能保留住生成器对象的常规行为，即耗尽时抛出 StopIteration 异常。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> namedtuple
<span style="color: #ff8700;">Result</span> = namedtuple(<span style="color: #ff4ea3;">'Result'</span>, <span style="color: #ff4ea3;">'count average'</span>)

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">averager</span>():
    <span style="color: #ff8700;">total</span> = 0.0
    <span style="color: #ff8700;">count</span> = 0
    <span style="color: #ff8700;">average</span> = <span style="color: #5fafd7;">None</span>
    <span style="color: #a1db00;">while</span> <span style="color: #5fafd7;">True</span>:
        <span style="color: #ff8700;">term</span> = <span style="color: #a1db00;">yield</span>
        <span style="color: #a1db00;">if</span> term <span style="color: #a1db00;">is</span> <span style="color: #5fafd7;">None</span>:
            <span style="color: #a1db00;">break</span>
        <span style="color: #ff8700;">total</span> += term
        <span style="color: #ff8700;">count</span> += 1
        <span style="color: #ff8700;">average</span> = total / count
    <span style="color: #a1db00;">return</span> Result(count, average)

<span style="color: #ff8700;">c_avg</span> = averager()
<span style="color: #d18aff;">next</span>(c_avg)
c_avg.send(10)
c_avg.send(20)
<span style="color: #a1db00;">try</span>:
    c_avg.send(<span style="color: #5fafd7;">None</span>)
<span style="color: #a1db00;">except</span> <span style="color: #00d7af;">StopIteration</span> <span style="color: #a1db00;">as</span> exc:
    <span style="color: #ff8700;">result</span> = exc.value

log(<span style="color: #ff4ea3;">"result"</span>, result)
</pre>
</div>

<pre class="example">
=========== result ===========
Result(count=2, average=15.0)
</pre>
</div>
</div>


<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> yield from</h3>
<div class="outline-text-3" id="text-5-7">
<p>
在生成器 gen 中使用 <code>yield from subgen()</code> 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen 。与此同时，gen 会阻塞，等待 subgen 终止。
</p>

<p>
从定义上来说，yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常。
</p>
</div>


<div id="outline-container-sec-5-7-1" class="outline-4">
<h4 id="sec-5-7-1"><span class="section-number-4">5.7.1</span> 结构示意图</h4>
<div class="outline-text-4" id="text-5-7-1">

<div id="yield" class="figure">
<p><img src="img/py3_yield.png" alt="py3_yield.png">
</p>
<p><span class="figure-number">Figure 2:</span> yield from 工作原理</p>
</div>

<p>
委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。
子生成器返回之后，解释器抛出 StopIteration 异常，并把返回值附加到异常对象上，届时委派生成器恢复。
</p>

<p>
委派生成器相当于 <b>管道</b> ，可以吧任意数量的委派生成器连接在一起，
这个管道最终要以一个只使用 yield 表达式的简单生成器结束 (也能以任何可迭代对象结束) 。
任何 yield from 链都必须由客户驱动，即在最外层委派生成器上调用 <code>next()</code>, <code>send()</code> 方法，
也可以隐式调用，如使用 for 循环。
</p>
</div>
</div>


<div id="outline-container-sec-5-7-2" class="outline-4">
<h4 id="sec-5-7-2"><span class="section-number-4">5.7.2</span> yield from 意义</h4>
<div class="outline-text-4" id="text-5-7-2">
<ul class="org-ul">
<li>子生成器产出的值都直接传给委派生成器的调用方，即客户端。
</li>
<li>使用 <code>send()</code> 发给委派生成器的值都直接传给子生成器。如果发送的值是 None ，那么会调用子生成器的 <code>__next__()</code> 方法。如果不是 None ，那么会调用子生成器的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。
</li>
<li>生成器退出时，子生成器中的 <code>return expr</code> 表达式会触发 <code>StopIteration(expr)</code> 异常抛出。
</li>
<li>yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。
</li>
<li>传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 <code>throw()</code> 方法。如果调用 <code>throw()</code> 方法抛出 StopIteration 异常，委派生成器恢复运行。StopIteration 之外的异常会向上冒泡，传给委派生成器。
</li>
<li>如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用 <code>close()</code> 方法，则会在子生成器上调用 <code>close()</code> 方法 (如果它有的话) 。如果子生成器调用 <code>close()</code> 方法导致异常抛出，则异常会向上冒泡，传给委派生成器，如果没有异常抛出，则委派生成器会抛出 GeneratorExit 异常。
</li>
</ul>
</div>


<div id="outline-container-sec-5-7-2-1" class="outline-5">
<h5 id="sec-5-7-2-1"><span class="section-number-5">5.7.2.1</span> RESULT = yield from EXPR 执行逻辑</h5>
<div class="outline-text-5" id="text-5-7-2-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_i: The subgenerator</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_y: A value yielded from the subgenerator</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_r: The eventual result</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_s: A value sent by the caller to the delegating generator, which is forwarded to the subgenerator</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_e: An exception</span>

<span style="color: #ff8700;">_i</span> = <span style="color: #d18aff;">iter</span>(EXPR)
<span style="color: #a1db00;">try</span>:
    <span style="color: #ff8700;">_y</span> = <span style="color: #d18aff;">next</span>(_i)
<span style="color: #a1db00;">except</span> <span style="color: #00d7af;">StopIteration</span> <span style="color: #a1db00;">as</span> _e:
    <span style="color: #ff8700;">_r</span> = _e.value
<span style="color: #a1db00;">else</span>:
    <span style="color: #a1db00;">while</span> 1:
        <span style="color: #a1db00;">try</span>:
            <span style="color: #ff8700;">_s</span> = <span style="color: #a1db00;">yield</span> _y
        <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">GeneratorExit</span> <span style="color: #a1db00;">as</span> _e:
            <span style="color: #a1db00;">try</span>:
                <span style="color: #ff8700;">_m</span> = _i.close
            <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">AttributeError</span>:
                <span style="color: #a1db00;">pass</span>
            <span style="color: #a1db00;">else</span>:
                _m()
            <span style="color: #a1db00;">raise</span> _e
        <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">BaseException</span> <span style="color: #a1db00;">as</span> _e:
            <span style="color: #ff8700;">_x</span> = sys.exc_info()
            <span style="color: #a1db00;">try</span>:
                <span style="color: #ff8700;">_m</span> = _i.throw
            <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">AttributeError</span>:
                <span style="color: #a1db00;">raise</span> _e
            <span style="color: #a1db00;">else</span>:
                <span style="color: #a1db00;">try</span>:
                    <span style="color: #ff8700;">_y</span> = _m(*_x)
                <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">StopIteration</span> <span style="color: #a1db00;">as</span> _e:
                    <span style="color: #ff8700;">_r</span> = _e.value
                    <span style="color: #a1db00;">break</span>
        <span style="color: #a1db00;">else</span>:
            <span style="color: #a1db00;">try</span>:
                <span style="color: #a1db00;">if</span> _s <span style="color: #a1db00;">is</span> <span style="color: #5fafd7;">None</span>:
                    <span style="color: #ff8700;">_y</span> = <span style="color: #d18aff;">next</span>(_i)
                <span style="color: #a1db00;">else</span>:
                    <span style="color: #ff8700;">_y</span> = _i.send(_s)
            <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">StopIteration</span> <span style="color: #a1db00;">as</span> _e:
                <span style="color: #ff8700;">_r</span> = _e.value
                <span style="color: #a1db00;">break</span>

<span style="color: #ff8700;">RESULT</span> = _r
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> <a id="simulation" name="simulation"></a>使用协程进行离散事件仿真</h3>
<div class="outline-text-3" id="text-5-8">
<p>
这个例子是说明如何在一个主循环中处理事件，以及如何通过发送数据驱动协程。这是 asyncio 包底层的基本思想。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> namedtuple
<span style="color: #a1db00;">import</span> queue
<span style="color: #a1db00;">import</span> random

<span style="color: #ff8700;">Event</span> = namedtuple(<span style="color: #ff4ea3;">'Event'</span>, <span style="color: #ff4ea3;">'time proc action'</span>)

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">taxi_process</span>(proc, trips, start_time=0):
    <span style="color: #ff8700;">time</span> = <span style="color: #a1db00;">yield</span> Event(start_time, proc, <span style="color: #ff4ea3;">'leave garage'</span>)
    <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span> (trips):
        <span style="color: #ff8700;">time</span> = <span style="color: #a1db00;">yield</span> Event(time, proc, <span style="color: #ff4ea3;">'pick up passenger'</span>)
        <span style="color: #ff8700;">time</span> = <span style="color: #a1db00;">yield</span> Event(time, proc, <span style="color: #ff4ea3;">'drop off passenger'</span>)
    <span style="color: #a1db00;">yield</span> Event(time, proc, <span style="color: #ff4ea3;">'going home'</span>)

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Simulator</span>:

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__init__</span>(<span style="color: #a1db00;">self</span>, procs_map):
        <span style="color: #a1db00;">self</span>.events = queue.PriorityQueue()
        <span style="color: #a1db00;">self</span>.procs = <span style="color: #d18aff;">dict</span>(procs_map)

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">run</span>(<span style="color: #a1db00;">self</span>, end_time):
        <span style="color: #a1db00;">for</span> _, proc <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">sorted</span>(<span style="color: #a1db00;">self</span>.procs.items()):
            <span style="color: #ff8700;">first_event</span> = <span style="color: #d18aff;">next</span>(proc)
            <span style="color: #a1db00;">self</span>.events.put(first_event)

        <span style="color: #ff8700;">sim_time</span> = 0
        <span style="color: #a1db00;">while</span> sim_time &lt; end_time:
            <span style="color: #a1db00;">if</span> <span style="color: #a1db00;">self</span>.events.empty():
                <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'=== end of events ==='</span>)
                <span style="color: #a1db00;">break</span>

            <span style="color: #ff8700;">current_event</span> = <span style="color: #a1db00;">self</span>.events.get()
            <span style="color: #ff8700;">sim_time</span>, <span style="color: #ff8700;">proc_id</span>, <span style="color: #ff8700;">action</span> = current_event
            <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'taxi:'</span>, proc_id, proc_id * <span style="color: #ff4ea3;">'  '</span>, action, <span style="color: #ff4ea3;">' ['</span>, sim_time, <span style="color: #ff4ea3;">']'</span>)
            <span style="color: #ff8700;">active_proc</span> = <span style="color: #a1db00;">self</span>.procs[proc_id]
            <span style="color: #ff8700;">next_time</span> = sim_time + random.randint(1, 10)
            <span style="color: #a1db00;">try</span>:
                <span style="color: #ff8700;">next_event</span> = active_proc.send(next_time)
            <span style="color: #a1db00;">except</span> <span style="color: #00d7af;">StopIteration</span>:
                <span style="color: #a1db00;">del</span> <span style="color: #a1db00;">self</span>.procs[proc_id]
            <span style="color: #a1db00;">else</span>:
                <span style="color: #a1db00;">self</span>.events.put(next_event)
        <span style="color: #a1db00;">else</span>:
            <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'=== end of simulation time: {} events pending ==='</span>
                  .<span style="color: #d18aff;">format</span>(<span style="color: #a1db00;">self</span>.events.qsize()))

<span style="color: #ff8700;">num_taxis</span> = 3
<span style="color: #ff8700;">DEPARTURE_INTERVAL</span> = 5
<span style="color: #ff8700;">taxis</span> = {i: taxi_process(i, (i+1)*2, i*DEPARTURE_INTERVAL) <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(num_taxis)}
Simulator(taxis).run(100)
</pre>
</div>

<pre class="example">
taxi: 0  leave garage  [ 0 ]
taxi: 0  pick up passenger  [ 4 ]
taxi: 1    leave garage  [ 5 ]
taxi: 0  drop off passenger  [ 8 ]
taxi: 2      leave garage  [ 10 ]
taxi: 0  pick up passenger  [ 14 ]
taxi: 1    pick up passenger  [ 15 ]
taxi: 2      pick up passenger  [ 15 ]
taxi: 1    drop off passenger  [ 20 ]
taxi: 2      drop off passenger  [ 22 ]
taxi: 2      pick up passenger  [ 23 ]
taxi: 0  drop off passenger  [ 24 ]
taxi: 2      drop off passenger  [ 25 ]
taxi: 1    pick up passenger  [ 26 ]
taxi: 0  going home  [ 28 ]
taxi: 2      pick up passenger  [ 30 ]
taxi: 1    drop off passenger  [ 32 ]
taxi: 1    pick up passenger  [ 36 ]
taxi: 1    drop off passenger  [ 40 ]
taxi: 2      drop off passenger  [ 40 ]
taxi: 2      pick up passenger  [ 42 ]
taxi: 2      drop off passenger  [ 44 ]
taxi: 1    pick up passenger  [ 50 ]
taxi: 2      pick up passenger  [ 53 ]
taxi: 2      drop off passenger  [ 58 ]
taxi: 1    drop off passenger  [ 59 ]
taxi: 1    going home  [ 62 ]
taxi: 2      pick up passenger  [ 63 ]
taxi: 2      drop off passenger  [ 68 ]
taxi: 2      going home  [ 73 ]
=== end of events ===
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 数据结构</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 元组</h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> 基本用法</h4>
<div class="outline-text-4" id="text-6-1-1">
</div><div id="outline-container-sec-6-1-1-1" class="outline-5">
<h5 id="sec-6-1-1-1"><span class="section-number-5">6.1.1.1</span> 占位</h5>
<div class="outline-text-5" id="text-6-1-1-1">
<p>
<code>a, _ = (3, 4)</code>
</p>
</div>
</div>

<div id="outline-container-sec-6-1-1-2" class="outline-5">
<h5 id="sec-6-1-1-2"><span class="section-number-5">6.1.1.2</span> 星号(*)的使用</h5>
<div class="outline-text-5" id="text-6-1-1-2">
<div class="org-src-container">

<pre class="src src-ipython">a, b, *<span style="color: #ff8700;">rest1</span> = <span style="color: #d18aff;">range</span>(5)
log(<span style="color: #ff4ea3;">"rest1"</span>, rest1)

a, b, *<span style="color: #ff8700;">rest2</span> = <span style="color: #d18aff;">range</span>(3)
log(<span style="color: #ff4ea3;">"rest2"</span>, rest2)

a, b, *<span style="color: #ff8700;">rest3</span> = <span style="color: #d18aff;">range</span>(2)
log(<span style="color: #ff4ea3;">"rest3"</span>, rest3)
</pre>
</div>

<pre class="example">
=========== rest1 ============
[2, 3, 4]
=========== rest2 ============
[2]
=========== rest3 ============
[]
</pre>

<p>
<b>星号前缀只能用在一个变量名前，但是这个变量可以出现在赋值表达式的任意位置：</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython">a, *<span style="color: #ff8700;">body</span>, <span style="color: #ff8700;">c</span>, <span style="color: #ff8700;">d</span> = <span style="color: #d18aff;">range</span>(5)
log(<span style="color: #ff4ea3;">"body"</span>, body)

*<span style="color: #ff8700;">head</span>, <span style="color: #ff8700;">b</span>, <span style="color: #ff8700;">c</span>, <span style="color: #ff8700;">d</span> = <span style="color: #d18aff;">range</span>(5)
log(<span style="color: #ff4ea3;">"head"</span>, head)
</pre>
</div>

<pre class="example">
============ body ============
[1, 2]
============ head ============
[0, 1]
</pre>
</div>
</div>

<div id="outline-container-sec-6-1-1-3" class="outline-5">
<h5 id="sec-6-1-1-3"><span class="section-number-5">6.1.1.3</span> 嵌套拆包</h5>
<div class="outline-text-5" id="text-6-1-1-3">
<div class="org-src-container">

<pre class="src src-ipython">name, cc, pop, (latitude, longitude) = (<span style="color: #ff4ea3;">'Tokyo'</span>, <span style="color: #ff4ea3;">'JP'</span>, 36.933, (35.689722, 139.691667))
log(<span style="color: #ff4ea3;">"[name, cc, pop, latitude, longitude]"</span>, [name, cc, pop, latitude, longitude])
</pre>
</div>

<pre class="example">
 [name, cc, pop, latitude, longitude]
['Tokyo', 'JP', 36.933, 35.689722, 139.691667]
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 具名元组</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> namedtuple
<span style="color: #ff8700;">Point</span> = namedtuple(<span style="color: #ff4ea3;">'Point'</span>, [<span style="color: #ff4ea3;">'x'</span>, <span style="color: #ff4ea3;">'y'</span>])
<span style="color: #ff8700;">p</span> = Point(1, 2)
<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"x: {}, y: {}"</span>.<span style="color: #d18aff;">format</span>(p.x, p.y))
</pre>
</div>

<pre class="example">
x: 1, y: 2
</pre>

<p>
除了从普通元组继承来的属性之外，具名元祖还有一些自己专用的属性：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">_fields &#23646;&#24615;&#21253;&#21547;&#36825;&#20010;&#31867;&#25152;&#26377;&#23383;&#27573;&#21517;&#31216;&#30340;&#20803;&#32452;</span>
log(<span style="color: #ff4ea3;">"Point._fields"</span>, Point._fields)

<span style="color: #ff8700;">data</span> = (3, 4)
<span style="color: #ff8700;">pt</span> = Point._make(data)  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#20316;&#29992;&#31561;&#25928;&#20110; Point(*data)</span>
log(<span style="color: #ff4ea3;">"pt._asdict()"</span>, pt._asdict())
</pre>
</div>

<pre class="example">
======= Point._fields ========
('x', 'y')
======== pt._asdict() ========
OrderedDict([('x', 3), ('y', 4)])
</pre>
</div>
</div>


<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 列表</h3>
<div class="outline-text-3" id="text-6-3">
<p>
切片操作里不包含区间范围的最后一个元素是 Python 的风格，这个习惯带来的好处如下：
</p>

<ul class="org-ul">
<li>当只有最后一个位置信息时，可以快速看出有几个元素：=range(3)= 和 <code>my_list[:3]</code> 都返回 3 个元素
</li>
<li>当起止位置信息都可见时，可以快速计算出区间长度，即 <code>stop - start</code>
</li>
<li>可以利用任意一个下标把序列分割成不重叠的两部分，只需写成： <code>my_list[:3]</code> 和 <code>my_list[3:]</code>
</li>
</ul>
</div>

<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> 切片选择</h4>
<div class="outline-text-4" id="text-6-3-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">s</span> = <span style="color: #ff4ea3;">'bicycle'</span>
log(<span style="color: #ff4ea3;">"s[::3]"</span>, s[::3])

<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21453;&#24207;</span>
log(<span style="color: #ff4ea3;">"s[::-1]"</span>, s[::-1])

<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#22797;&#21046;&#24207;&#21015;</span>
log(<span style="color: #ff4ea3;">"s[:]"</span>, s[:])
</pre>
</div>

<pre class="example">
=========== s[::3] ===========
bye
========== s[::-1] ===========
elcycib
============ s[:] ============
bicycle
</pre>
</div>
</div>


<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><span class="section-number-4">6.3.2</span> 切片赋值</h4>
<div class="outline-text-4" id="text-6-3-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">l</span> = <span style="color: #d18aff;">list</span>(<span style="color: #d18aff;">range</span>(10))
log(<span style="color: #ff4ea3;">"l"</span>, l)

<span style="color: #ff8700;">l</span>[2:5] = [20, 30]
log(<span style="color: #ff4ea3;">"l[2:5] = [20, 30]"</span>, l)

<span style="color: #a1db00;">del</span> l[5:7]
log(<span style="color: #ff4ea3;">"del l[5:7]"</span>, l)

<span style="color: #ff8700;">l</span>[3::2] = [11, 22]
log(<span style="color: #ff4ea3;">"l[3::2] = [11, 22]"</span>, l)

<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'test exception'</span>.center(30, <span style="color: #ff4ea3;">'='</span>))
<span style="color: #a1db00;">try</span>:
    <span style="color: #ff8700;">l</span>[2:5] = 100
<span style="color: #a1db00;">except</span> <span style="color: #00d7af;">Exception</span> <span style="color: #a1db00;">as</span> e:
    <span style="color: #a1db00;">print</span>(e)

<span style="color: #ff8700;">l</span>[2:5] = [100]
log(<span style="color: #ff4ea3;">"l[2:5] = [100]"</span>, l)
</pre>
</div>

<pre class="example">
============= l ==============
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
===== l[2:5] = [20, 30] ======
[0, 1, 20, 30, 5, 6, 7, 8, 9]
========= del l[5:7] =========
[0, 1, 20, 30, 5, 8, 9]
===== l[3::2] = [11, 22] =====
[0, 1, 20, 11, 5, 22, 9]
========test exception========
can only assign an iterable
======= l[2:5] = [100] =======
[0, 1, 100, 22, 9]
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> bisect</h3>
<div class="outline-text-3" id="text-6-4">
</div><div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> 搜索</h4>
<div class="outline-text-4" id="text-6-4-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> bisect
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">grade</span>(score, breakpoints=[60, 70, 80, 90], grades=<span style="color: #ff4ea3;">'FDCBA'</span>):
    <span style="color: #ff8700;">i</span> = bisect.bisect(breakpoints, score)
    <span style="color: #a1db00;">return</span> grades[i]

<span style="color: #ff8700;">result</span> = [grade(score) <span style="color: #a1db00;">for</span> score <span style="color: #a1db00;">in</span> [33, 99, 77, 70, 89, 90, 100]]
log(<span style="color: #ff4ea3;">"result"</span>, result)
</pre>
</div>

<pre class="example">
=========== result ===========
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</pre>
</div>
</div>


<div id="outline-container-sec-6-4-2" class="outline-4">
<h4 id="sec-6-4-2"><span class="section-number-4">6.4.2</span> 插入新元素</h4>
<div class="outline-text-4" id="text-6-4-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> bisect
<span style="color: #a1db00;">import</span> random
random.seed(1729)
<span style="color: #ff8700;">SIZE</span> = 20
<span style="color: #ff8700;">my_list</span> = []
<span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(SIZE):
    <span style="color: #ff8700;">new_value</span> = random.randrange(SIZE*2)
    bisect.insort(my_list, new_value)

log(<span style="color: #ff4ea3;">"my_list"</span>, my_list)
</pre>
</div>

<pre class="example">
========== my_list ===========
[0, 2, 3, 9, 10, 11, 13, 18, 18, 23, 23, 25, 26, 29, 29, 31, 32, 33, 35, 39]
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 数组</h3>
<div class="outline-text-3" id="text-6-5">
<p>
如果需要一个只包含数字的列表，使用 array.array 比 list 更高效。
</p>

<p>
创建数组需要一个类型码，用来表示底层的 C 语言应存放怎样的数据类型。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> array <span style="color: #a1db00;">import</span> array
<span style="color: #a1db00;">from</span> random <span style="color: #a1db00;">import</span> random
<span style="color: #ff8700;">floats</span> = array(<span style="color: #ff4ea3;">'d'</span>, (random() <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(1000)))  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">'d' &#34920;&#31034;&#21452;&#31934;&#24230;&#28014;&#28857;</span>
log(<span style="color: #ff4ea3;">"floats[-1]"</span>, floats[-1])
</pre>
</div>

<pre class="example">
========= floats[-1] =========
0.970088201571867
</pre>
</div>
</div>


<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> 内存视图</h3>
<div class="outline-text-3" id="text-6-6">
<p>
memoryview 是一个内置类，能让用户在不复制内容的情况下，在数据结构之间共享内存，
<b>这个功能在处理大型数据集合时非常重要。</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#36890;&#36807;&#25913;&#21464;&#25968;&#32452;&#20013;&#30340;&#19968;&#20010;&#23383;&#33410;&#26469;&#26356;&#26032;&#25968;&#32452;&#37324;&#26576;&#20010;&#20803;&#32032;&#30340;&#20540;</span>
<span style="color: #a1db00;">import</span> array
<span style="color: #ff8700;">numbers</span> = array.array(<span style="color: #ff4ea3;">'h'</span>, [-2, -1, 0, 1, 2])  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">'h' &#34920;&#31034; 16 &#20301;&#20108;&#36827;&#21046;&#25972;&#25968;</span>
<span style="color: #ff8700;">memv</span> = <span style="color: #d18aff;">memoryview</span>(numbers)

<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">memoryview.cast &#20250;&#25226;&#21516;&#19968;&#22359;&#20869;&#23384;&#37324;&#30340;&#20869;&#23481;&#25171;&#21253;&#25104;&#19968;&#20010;&#20840;&#26032;&#30340; memoryview</span>
<span style="color: #ff8700;">memv_oct</span> = memv.cast(<span style="color: #ff4ea3;">'B'</span>)   <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">'B' &#34920;&#31034;&#26080;&#31526;&#21495;&#23383;&#31526;</span>
<span style="color: #ff8700;">memv_oct</span>[5] = 4

log(<span style="color: #ff4ea3;">"numbers"</span>, numbers)
</pre>
</div>

<pre class="example">
========== numbers ===========
array('h', [-2, -1, 1024, 1, 2])
</pre>
</div>
</div>


<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> 双向队列</h3>
<div class="outline-text-3" id="text-6-7">
<p>
collection.deque 是一个线程安全，可以快速从两端添加或删除元素的数据类型。
</p>

<p>
使用 list 存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，
因为 list 是线性存储，数据量大的时候，插入和删除效率很低。
deque 是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。
</p>

<p>
如果想要一种数据结构来存放 <b>最近用到的几个元素</b> ，deque 是一个很好的选择。
</p>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> deque
<span style="color: #ff8700;">dq</span> = deque(<span style="color: #d18aff;">range</span>(10), maxlen=10)
log(<span style="color: #ff4ea3;">"dq"</span>, dq)

dq.rotate(3)
log(<span style="color: #ff4ea3;">"dq.rotate(3)"</span>, dq)

dq.rotate(-4)
log(<span style="color: #ff4ea3;">"dq.rotate(-4)"</span>, dq)

dq.appendleft(-1)
log(<span style="color: #ff4ea3;">"dq.appendleft(-1)"</span>, dq)

dq.extend([11, 22, 33])
log(<span style="color: #ff4ea3;">"dq.extend([11, 22, 33])"</span>, dq)
</pre>
</div>

<pre class="example">
============= dq =============
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
======== dq.rotate(3) ========
deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
======= dq.rotate(-4) ========
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)
===== dq.appendleft(-1) ======
deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
== dq.extend([11, 22, 33]) ===
deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)
</pre>
</div>
</div>


<div id="outline-container-sec-6-8" class="outline-3">
<h3 id="sec-6-8"><span class="section-number-3">6.8</span> 生成器</h3>
<div class="outline-text-3" id="text-6-8">
<p>
<b>生成器保存的是算法</b> ，每次调用 <code>next(g)</code> ，就计算出 g 的下一个元素的值，
直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 异常。
</p>
</div>

<div id="outline-container-sec-6-8-1" class="outline-4">
<h4 id="sec-6-8-1"><span class="section-number-4">6.8.1</span> 生成器函数</h4>
<div class="outline-text-4" id="text-6-8-1">
<p>
当 Python 函数定义体中有 yield 关键字，该函数就是生成器函数。
调用生成器函数时，会返回一个生成器对象。也就是说生成器函数是生成器工厂，
<b>而生成器表达式是生成器函数的语法糖。</b>
</p>
</div>
</div>


<div id="outline-container-sec-6-8-2" class="outline-4">
<h4 id="sec-6-8-2"><span class="section-number-4">6.8.2</span> 标准库中的生成器函数</h4>
<div class="outline-text-4" id="text-6-8-2">
</div><div id="outline-container-sec-6-8-2-1" class="outline-5">
<h5 id="sec-6-8-2-1"><span class="section-number-5">6.8.2.1</span> 用于过滤的生成器函数</h5>
<div class="outline-text-5" id="text-6-8-2-1">
<ul class="org-ul">
<li>itertools.compress(it, selector_it)

<p>
并行处理两个可迭代对象：如果 selector_it 中的元素是真值，产出 it 中对应的元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> itertools
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">vowel</span>(c):
    <span style="color: #a1db00;">return</span> c.lower() <span style="color: #a1db00;">in</span> <span style="color: #ff4ea3;">'aeiou'</span>

<span style="color: #ff8700;">result</span> = <span style="color: #d18aff;">list</span>(itertools.compress(<span style="color: #ff4ea3;">'Aardvark'</span>, (1, 0, 1, 1, 0, 1)))
<span style="color: #a1db00;">print</span>(result)
</pre>
</div>

<pre class="example">
['A', 'r', 'd', 'a']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>itertools.dropwhile(predicate, it)

<p>
处理 it ，跳过 predicate 计算结果为真值的元素，产出剩下的元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.dropwhile(vowel, <span style="color: #ff4ea3;">'Aardvark'</span>)))
</pre>
</div>

<pre class="example">
['r', 'd', 'v', 'a', 'r', 'k']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>builtin.filter(predicate, it)

<p>
如果 <code>predicate(item)</code> 返回真值，产出对应的元素，如果 predicate 是 None ，则只产出真值元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(<span style="color: #d18aff;">filter</span>(vowel, <span style="color: #ff4ea3;">'Aardvark'</span>)))
</pre>
</div>

<pre class="example">
['A', 'a', 'a']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>itertools.filterfalse(predicate, it)

<p>
如果 <code>predicate(item)</code> 返回假值，产出对应的元素。
</p>
</li>
</ul>


<ul class="org-ul">
<li>itertools.islice(it, [start], stop, step=1)

<p>
产出 it 的切片，类似于 <code>s[:stop]</code> 或 <code>s[start:stop:step]</code> 。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.islice(<span style="color: #ff4ea3;">'Aardvark'</span>, 4)))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.islice(<span style="color: #ff4ea3;">'Aardvark'</span>, 4, 7)))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.islice(<span style="color: #ff4ea3;">'Aardvark'</span>, 1, 7, 2)))
</pre>
</div>

<pre class="example">
['A', 'a', 'r', 'd']
['v', 'a', 'r']
['a', 'd', 'a']
</pre>
</li>

<li>itertools.takewhile(predicate, it)

<p>
如果 <code>predicate(item)</code> 返回真值，产出对应的元素，然后停止。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.takewhile(vowel, <span style="color: #ff4ea3;">'Aardvark'</span>)))
</pre>
</div>

<pre class="example">
['A', 'a']
</pre>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6-8-2-2" class="outline-5">
<h5 id="sec-6-8-2-2"><span class="section-number-5">6.8.2.2</span> 用于映射的生成器函数</h5>
<div class="outline-text-5" id="text-6-8-2-2">
<ul class="org-ul">
<li>itertools.accumulate(it, [func])

<p>
产出累计值，默认为求和；如果提供了 func ，则把前面两个元素传个 func ，
然后把计算结果和下一个元素传给它，以此类推，最后产出结果。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> operator <span style="color: #a1db00;">import</span> mul
<span style="color: #ff8700;">sample</span> = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1]

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.accumulate(sample)))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.accumulate(sample, <span style="color: #d18aff;">min</span>)))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.accumulate(sample, mul)))
</pre>
</div>

<pre class="example">
[5, 9, 11, 19, 26, 32, 35, 35, 44, 45]
[5, 4, 2, 2, 2, 2, 2, 0, 0, 0]
[5, 20, 40, 320, 2240, 13440, 40320, 0, 0, 0]
</pre>
</li>
</ul>


<ul class="org-ul">
<li>builtin.enumerate(it, start=0)

<p>
产出有两个元素组成的元组，结构是 (index, item) ，其中 index 从 start 开始计数，item 则从 iterable 中获取。
</p>
</li>

<li>builtin.map(func, it1, [it2, &#x2026;, itN])

<p>
如果传入 N 个 可迭代对象，则 func 必须能接受 N 个参数。
</p>
</li>

<li>itertools.starmap(func, it)

<p>
把 it 中各个元素传给 func ，产出结果。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.starmap(mul, <span style="color: #d18aff;">enumerate</span>(<span style="color: #ff4ea3;">'albatroz'</span>, 1))))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.starmap(<span style="color: #a1db00;">lambda</span> a, b: b/a,
                             <span style="color: #d18aff;">enumerate</span>(itertools.accumulate(sample), 1))))
</pre>
</div>

<pre class="example">
['a', 'll', 'bbb', 'aaaa', 'ttttt', 'rrrrrr', 'ooooooo', 'zzzzzzzz']
[5.0, 4.5, 3.6666666666666665, 4.75, 5.2, 5.333333333333333, 5.0, 4.375, 4.888888888888889, 4.5]
</pre>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6-8-2-3" class="outline-5">
<h5 id="sec-6-8-2-3"><span class="section-number-5">6.8.2.3</span> 用于合并可迭代对象的生成器函数</h5>
<div class="outline-text-5" id="text-6-8-2-3">
<ul class="org-ul">
<li>itertools.chain(it1, &#x2026;, itN)

<p>
无缝连接多个可迭代对象。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.chain(<span style="color: #ff4ea3;">'ABC'</span>, <span style="color: #d18aff;">range</span>(3))))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 0, 1, 2]
</pre>
</li>
</ul>


<ul class="org-ul">
<li>itertools.chain.from_iterable(it)

<p>
产出 it 生成的各个可迭代对象中的元素，无缝连接在一起。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.chain.from_iterable(<span style="color: #d18aff;">enumerate</span>(<span style="color: #ff4ea3;">'ABC'</span>))))
</pre>
</div>

<pre class="example">
[0, 'A', 1, 'B', 2, 'C']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>itertaools.product(it1, &#x2026;, itN, repeat=1)

<p>
计算笛卡尔积，合并成由 N 个元素组成的元组。
repeat 关键字参数告诉 product 函数重复 N 次处理输入的各个可迭代对象。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.product(<span style="color: #ff4ea3;">'ABC'</span>, <span style="color: #d18aff;">range</span>(2))))
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">list(itertools.product('ABC', 'ABC'))</span>
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.product(<span style="color: #ff4ea3;">'ABC'</span>, repeat=2)))
</pre>
</div>

<pre class="example">
[('A', 0), ('A', 1), ('B', 0), ('B', 1), ('C', 0), ('C', 1)]
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]
</pre>
</li>

<li>builtin.zip(it1, .., itN)

<p>
产出由 N 个元素组成的元组，只要有一个可迭代对象到头了，即停止。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(<span style="color: #d18aff;">zip</span>(<span style="color: #ff4ea3;">'ABC'</span>, <span style="color: #d18aff;">range</span>(5), [10, 20, 30, 40, 50, 60])))
</pre>
</div>

<pre class="example">
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30)]
</pre>
</li>

<li>itertools.zip_longest(it1, &#x2026;, itN, fillvalue=None)

<p>
产出由 N 个元素组成的元组，等到最长的可迭代对象到头了，即停止。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.zip_longest(<span style="color: #ff4ea3;">'ABC'</span>,
                                 <span style="color: #d18aff;">range</span>(5),
                                 [10, 20, 30, 40, 50, 60],
                                 fillvalue=<span style="color: #ff4ea3;">'?'</span>)))
</pre>
</div>

<pre class="example">
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30), ('?', 3, 40), ('?', 4, 50), ('?', '?', 60)]
</pre>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6-8-2-4" class="outline-5">
<h5 id="sec-6-8-2-4"><span class="section-number-5">6.8.2.4</span> 用于扩展输出元素的生成器函数</h5>
<div class="outline-text-5" id="text-6-8-2-4">
<ul class="org-ul">
<li>itertools.combinations(it, out_len)

<p>
把 it 产出的 out_len 个元素组合在一起，然后产出。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.combinations(<span style="color: #ff4ea3;">'ABC'</span>, 2)))
</pre>
</div>

<pre class="example">
[('A', 'B'), ('A', 'C'), ('B', 'C')]
</pre>
</li>

<li>itertools.combinations_with_replacement(it, out_len)

<p>
把 it 产出的 out_len 个元素组合在一起，然后产出，包含相同元素的组合。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.combinations_with_replacement(<span style="color: #ff4ea3;">'ABC'</span>, 2)))
</pre>
</div>

<pre class="example">
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]
</pre>
</li>

<li>itertools.permutation(it, out_len=None)

<p>
把 out_len 个 it 产出元素排列在一起，然后产出这些排列；out_len 的默认值等于 <code>len(list(it))</code> 。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.permutations(<span style="color: #ff4ea3;">'ABC'</span>, 2)))
</pre>
</div>

<pre class="example">
[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
</pre>
</li>

<li>itertools.count(start=0, step=1)

<p>
从 start 开支不断产出数字，按 step 步幅增加。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.islice(itertools.count(1, .3), 3)))
</pre>
</div>

<pre class="example">
[1, 1.3, 1.6]
</pre>
</li>

<li>itertools.cycle(it)

<p>
从 it 中产出元素，存储各个元素的 <b>副本</b> ，然后按顺序重复不断地产出各个元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.islice(itertools.cycle(<span style="color: #ff4ea3;">'ABC'</span>), 7)))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 'A', 'B', 'C', 'A']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>itertools.repeat(item, [times])

<p>
不断产出指定元素，除非指定次数。常见用途，为 map 函数提供固定参数：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(<span style="color: #d18aff;">map</span>(mul, <span style="color: #d18aff;">range</span>(11), itertools.repeat(5))))
</pre>
</div>

<pre class="example">
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
</pre>
</li>
</ul>


<ul class="org-ul">
<li>builtin.iter(callable, sentinel)

<p>
第一个参数是一个没有参数的可调用对象，用于不断调用，产出各个值；第二个值是哨符，当可调用对象返回这个值时，迭代结束 (不产出哨符) 。
</p>

<p>
iter 的<a href="https://docs.python.org/3/library/functions.html#iter">文档</a>中有个实用的例子，这段代码逐行读取文件，直到遇到空行或到达文件末尾为止：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">with</span> <span style="color: #d18aff;">open</span>(<span style="color: #ff4ea3;">'mydata.txt'</span>) <span style="color: #a1db00;">as</span> fp:
    <span style="color: #a1db00;">for</span> line <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">iter</span>(fp.readline, <span style="color: #ff4ea3;">''</span>):
        process_line(line)
</pre>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6-8-2-5" class="outline-5">
<h5 id="sec-6-8-2-5"><span class="section-number-5">6.8.2.5</span> 用于重新排列元素的生成器函数</h5>
<div class="outline-text-5" id="text-6-8-2-5">
<ul class="org-ul">
<li>itertools.groupby(it, key=None)

<p>
产出由两个元素组成的元组，形式为 (key, group) ，其中 key 是分组标准，group 是生成器，用于产出分组里的元素。
</p>

<p>
注意， <code>itertool.groupby</code> 假定输入的可迭代对象已使用指定的 key 分组了各个元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.groupby(<span style="color: #ff4ea3;">'LLLAAGGG'</span>)))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(itertools.groupby(<span style="color: #ff4ea3;">'LLAALAAGGG'</span>)))
</pre>
</div>

<pre class="example">
[('L', &lt;itertools._grouper object at 0x108724dd8&gt;), ('A', &lt;itertools._grouper object at 0x108724cf8&gt;), ('G', &lt;itertools._grouper object at 0x1087244e0&gt;)]
[('L', &lt;itertools._grouper object at 0x1087249b0&gt;), ('A', &lt;itertools._grouper object at 0x108724cf8&gt;), ('L', &lt;itertools._grouper object at 0x1087244e0&gt;), ('A', &lt;itertools._grouper object at 0x108724080&gt;), ('G', &lt;itertools._grouper object at 0x1087247f0&gt;)]
</pre>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">animals</span> = [<span style="color: #ff4ea3;">'duck'</span>, <span style="color: #ff4ea3;">'eagle'</span>, <span style="color: #ff4ea3;">'rat'</span>, <span style="color: #ff4ea3;">'giraffe'</span>, <span style="color: #ff4ea3;">'bear'</span>, <span style="color: #ff4ea3;">'bat'</span>, <span style="color: #ff4ea3;">'dolphin'</span>, <span style="color: #ff4ea3;">'shark'</span>, <span style="color: #ff4ea3;">'lion'</span>]
animals.sort(key=<span style="color: #d18aff;">len</span>)
<span style="color: #a1db00;">for</span> length, group <span style="color: #a1db00;">in</span> itertools.groupby(animals, <span style="color: #d18aff;">len</span>):
    <span style="color: #a1db00;">print</span>(length, <span style="color: #ff4ea3;">'-&gt;'</span>, <span style="color: #d18aff;">list</span>(group))
</pre>
</div>

<pre class="example">
3 -&gt; ['rat', 'bat']
4 -&gt; ['duck', 'bear', 'lion']
5 -&gt; ['eagle', 'shark']
7 -&gt; ['giraffe', 'dolphin']
</pre>
</li>
</ul>


<ul class="org-ul">
<li>builtin.reversed(seq)

<p>
seq 必须是序列，或是实现了 <code>__reversed__</code> 特殊方法的对象。
</p>
</li>

<li>itertools.tee(it, n=2)

<p>
产出一个由 n 个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(<span style="color: #d18aff;">zip</span>(*itertools.tee(<span style="color: #ff4ea3;">'ABC'</span>))))
</pre>
</div>

<pre class="example">
[('A', 'A'), ('B', 'B'), ('C', 'C')]
</pre>
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-6-8-3" class="outline-4">
<h4 id="sec-6-8-3"><span class="section-number-4">6.8.3</span> yield from 语法</h4>
<div class="outline-text-4" id="text-6-8-3">
<p>
这个语句的作用是把不同的生成器结合在一起使用。
</p>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">chain</span>(*iterables):
    <span style="color: #a1db00;">for</span> it <span style="color: #a1db00;">in</span> iterables:
        <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> it:
            <span style="color: #a1db00;">yield</span> i

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(chain(<span style="color: #ff4ea3;">'ABC'</span>, <span style="color: #d18aff;">range</span>(3))))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 0, 1, 2]
</pre>


<p>
<b>等效于：</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">chain</span>(*iterables):
    <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> iterables:
        <span style="color: #a1db00;">yield</span> <span style="color: #a1db00;">from</span> i

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">list</span>(chain(<span style="color: #ff4ea3;">'ABC'</span>, <span style="color: #d18aff;">range</span>(3))))
</pre>
</div>

<pre class="example">
['A', 'B', 'C', 0, 1, 2]
</pre>
</div>
</div>

<div id="outline-container-sec-6-8-4" class="outline-4">
<h4 id="sec-6-8-4"><span class="section-number-4">6.8.4</span> 把生成器当成协程</h4>
<div class="outline-text-4" id="text-6-8-4">
<p>
<a href="https://www.python.org/dev/peps/pep-0342/">PEP 342</a> 为生成器对象添加了 <code>send()</code> 方法，该方法使得生成器前进到下一个 yield 语句。
</p>

<p>
<code>send()</code> 方法还允许使用生成器的客户把数据发给自己，传给 <code>send()</code> 方法的参数，
会成为生成器函数定义体中对应 yield 表达式的值。
也就是说，=send()= 方法允许在客户代码和生成器之间 <b>双向交换数据。</b>
</p>

<p>
<b>生成器用于生成供迭代的数据，而协程是数据的消费者，协程与迭代无关。</b>
</p>
</div>
</div>
</div>


<div id="outline-container-sec-6-9" class="outline-3">
<h3 id="sec-6-9"><span class="section-number-3">6.9</span> 字典</h3>
<div class="outline-text-3" id="text-6-9">
</div><div id="outline-container-sec-6-9-1" class="outline-4">
<h4 id="sec-6-9-1"><span class="section-number-4">6.9.1</span> 广义映射类型</h4>
<div class="outline-text-4" id="text-6-9-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> abc
<span style="color: #ff8700;">d</span> = {}
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">isinstance</span>(d, abc.Mapping))
</pre>
</div>

<pre class="example">
True
</pre>
</div>
</div>

<div id="outline-container-sec-6-9-2" class="outline-4">
<h4 id="sec-6-9-2"><span class="section-number-4">6.9.2</span> 字典构造</h4>
<div class="outline-text-4" id="text-6-9-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">a</span> = <span style="color: #d18aff;">dict</span>(one=1, two=2, three=3)
<span style="color: #ff8700;">b</span> = {<span style="color: #ff4ea3;">'one'</span>: 1, <span style="color: #ff4ea3;">'two'</span>: 2, <span style="color: #ff4ea3;">'three'</span>: 3}
<span style="color: #ff8700;">c</span> = <span style="color: #d18aff;">dict</span>(<span style="color: #d18aff;">zip</span>([<span style="color: #ff4ea3;">'one'</span>, <span style="color: #ff4ea3;">'two'</span>, <span style="color: #ff4ea3;">'three'</span>], [1, 2, 3]))
<span style="color: #ff8700;">d</span> = <span style="color: #d18aff;">dict</span>([(<span style="color: #ff4ea3;">'two'</span>, 2), (<span style="color: #ff4ea3;">'one'</span>, 1), (<span style="color: #ff4ea3;">'three'</span>, 3)])
<span style="color: #ff8700;">e</span> = <span style="color: #d18aff;">dict</span>({<span style="color: #ff4ea3;">'three'</span>: 3, <span style="color: #ff4ea3;">'one'</span>: 1, <span style="color: #ff4ea3;">'two'</span>: 2})
<span style="color: #a1db00;">print</span>(a == b == c == d == e)
</pre>
</div>

<pre class="example">
True
</pre>
</div>
</div>


<div id="outline-container-sec-6-9-3" class="outline-4">
<h4 id="sec-6-9-3"><span class="section-number-4">6.9.3</span> 字典推导</h4>
<div class="outline-text-4" id="text-6-9-3">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">CODES</span> = [
    (86, <span style="color: #ff4ea3;">'China'</span>),
    (91, <span style="color: #ff4ea3;">'India'</span>),
    (1, <span style="color: #ff4ea3;">'USA'</span>)
]
<span style="color: #a1db00;">print</span>({country: code <span style="color: #a1db00;">for</span> code, country <span style="color: #a1db00;">in</span> CODES})
</pre>
</div>

<pre class="example">
{'China': 86, 'USA': 1, 'India': 91}
</pre>
</div>
</div>

<div id="outline-container-sec-6-9-4" class="outline-4">
<h4 id="sec-6-9-4"><span class="section-number-4">6.9.4</span> 弹性键查询</h4>
<div class="outline-text-4" id="text-6-9-4">
</div><div id="outline-container-sec-6-9-4-1" class="outline-5">
<h5 id="sec-6-9-4-1"><span class="section-number-5">6.9.4.1</span> defaultdict</h5>
<div class="outline-text-5" id="text-6-9-4-1">
<p>
在实例化一个 defaultdict 的时候，需要给构造方法提供一个可调用对象，
这个可调用对象会在 <code>__getitem__</code> 找不到键的时候被调用，以便 <code>__getitem__</code> 返回默认值。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> collections
<span style="color: #ff8700;">d</span> = collections.defaultdict(<span style="color: #d18aff;">list</span>)
d[<span style="color: #ff4ea3;">'a'</span>].append(<span style="color: #ff4ea3;">'b'</span>)
d[<span style="color: #ff4ea3;">'c'</span>].append(<span style="color: #ff4ea3;">'d'</span>)
log(<span style="color: #ff4ea3;">"d"</span>, d)
</pre>
</div>

<pre class="example">
============= d ==============
defaultdict(&lt;class 'list'&gt;, {'a': ['b'], 'c': ['d']})
</pre>
</div>
</div>


<div id="outline-container-sec-6-9-4-2" class="outline-5">
<h5 id="sec-6-9-4-2"><span class="section-number-5">6.9.4.2</span> 使用特殊方法</h5>
<div class="outline-text-5" id="text-6-9-4-2">
<p>
映射类型在处理找不到的键的时候，都会涉及 <code>__missing__</code> 方法。
虽然基类 dict 没有定义这个方法，但是如果一个类继承了 dict ，然后提供了 <code>__missing__</code> 方法，
那么当 <code>__getitem__</code> 遇到找不到键的时候，Python 会自动调用它，而不是抛出 KeyError 异常。
</p>

<p>
<b><span class="underline"><span class="underline">missing</span></span> 方法只会被 <span class="underline"><span class="underline">getitem</span></span> 调用（即使用表达式 d[k] ）</b>
</p>
</div>
</div>
</div>



<div id="outline-container-sec-6-9-5" class="outline-4">
<h4 id="sec-6-9-5"><span class="section-number-4">6.9.5</span> OrderedDict</h4>
<div class="outline-text-4" id="text-6-9-5">
<p>
这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。
</p>

<p>
OrderedDict 的 popitem 方法默认删除并返回字典里最后一个元素，
但是如果调用 <code>popitem(last=False)</code> ，则删除并返回第一个被添加进去的元素。
</p>
</div>
</div>


<div id="outline-container-sec-6-9-6" class="outline-4">
<h4 id="sec-6-9-6"><span class="section-number-4">6.9.6</span> ChainMap</h4>
<div class="outline-text-4" id="text-6-9-6">
<p>
该类型可以容纳多个不同的映射对象，在进行键查找操作时，会逐个查找这些映射对象，直到键被找到为止。
</p>

<p>
这个功能在给有嵌套作用域的语言做解释器的时候很有用，可以用一个映射对象来代表一个作用域上下文。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> builtins
<span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> ChainMap
<span style="color: #ff8700;">pylookup</span> = ChainMap(<span style="color: #d18aff;">locals</span>(), <span style="color: #d18aff;">globals</span>(), <span style="color: #d18aff;">vars</span>(builtins))
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-6-9-7" class="outline-4">
<h4 id="sec-6-9-7"><span class="section-number-4">6.9.7</span> Counter</h4>
<div class="outline-text-4" id="text-6-9-7">
<p>
这个映射类型会给键准备一个整数计数器，每次更新一个键的时候会增加这个计数器。
</p>

<p>
Counter 实现了 + 和 - 运算符来合并记录。 <code>most_common([n])</code> 方法会返回最常见的 n 个键和它们的计数。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> Counter
<span style="color: #ff8700;">ct</span> = Counter(<span style="color: #ff4ea3;">'abracadabra'</span>)
<span style="color: #a1db00;">print</span>(ct)
ct.update(<span style="color: #ff4ea3;">'aaaaazzz'</span>)
<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'after update'</span>.center(30, <span style="color: #ff4ea3;">'='</span>))
<span style="color: #a1db00;">print</span>(ct)
<span style="color: #a1db00;">print</span>(ct.most_common(2))
</pre>
</div>

<pre class="example">
Counter({'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1})
=========after update=========
Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'd': 1, 'c': 1})
[('a', 10), ('z', 3)]
</pre>
</div>
</div>


<div id="outline-container-sec-6-9-8" class="outline-4">
<h4 id="sec-6-9-8"><span class="section-number-4">6.9.8</span> UserDict</h4>
<div class="outline-text-4" id="text-6-9-8">
<p>
这个类其实是把标准 dict 用纯 Python 又实现了一遍，主要的用途是让用户继承写子类的。
</p>

<p>
更倾向于从 UserDict 而不是从 dict 继承的主要原因是后者有时会在某些方法的实现上走一些捷径，
导致不得不在子类中重写这些方法（比如 dict 的子类实现的 <code>__getitem__</code> 方法不会被 get() 方法所调用），
但是 UserDict 就不会有这个问题。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">MyDict</span>(<span style="color: #d18aff;">dict</span>):
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__setitem__</span>(<span style="color: #a1db00;">self</span>, key, value):
        <span style="color: #d18aff;">super</span>().__setitem__(key, value*2)

<span style="color: #ff8700;">d</span> = MyDict(one=1)
<span style="color: #a1db00;">print</span>(d)

<span style="color: #ff8700;">d</span>[<span style="color: #ff4ea3;">'two'</span>] = 2
<span style="color: #a1db00;">print</span>(d)
</pre>
</div>

<pre class="example">
{'one': 1}
{'one': 1, 'two': 4}
</pre>


<p>
继承自 dict 的 <code>__init__</code> 方法忽略了子类的 <code>__setitem__</code> 方法。
</p>

<div class="org-src-container">

<pre class="src src-ipython">d.update(three=3)
<span style="color: #a1db00;">print</span>(d)
</pre>
</div>

<pre class="example">
{'one': 1, 'three': 3, 'two': 4}
</pre>

<p>
继承自 dict 的 update 方法也忽略了子类的 <code>__setitem__</code> 方法。
</p>

<p>
另外一个值得注意的地方是，UserDict 并不是 dict 的子类。
UserDict 有一个 data 属性，是 dict 的实例，这个属性实际上是 UserDict 最终存储数据的地方。
</p>
</div>
</div>


<div id="outline-container-sec-6-9-9" class="outline-4">
<h4 id="sec-6-9-9"><span class="section-number-4">6.9.9</span> 不可变映射类型</h4>
<div class="outline-text-4" id="text-6-9-9">
<p>
types.MappingProxyType 会返回一个只读的映射视图。
虽然是只读视图，但是它是动态的，如果对原映射做出改动，
通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> types <span style="color: #a1db00;">import</span> MappingProxyType
<span style="color: #ff8700;">d</span> = {1: <span style="color: #ff4ea3;">'A'</span>}
<span style="color: #ff8700;">d_proxy</span> = MappingProxyType(d)
<span style="color: #a1db00;">print</span>(d_proxy)

log(<span style="color: #ff4ea3;">"d_proxy[1]"</span>, d_proxy[1])

<span style="color: #a1db00;">try</span>:
    <span style="color: #ff8700;">d_proxy</span>[2] = <span style="color: #ff4ea3;">'x'</span>
<span style="color: #a1db00;">except</span> <span style="color: #00d7af;">Exception</span> <span style="color: #a1db00;">as</span> e:
    <span style="color: #a1db00;">print</span>(e)

<span style="color: #ff8700;">d</span>[2] = <span style="color: #ff4ea3;">'B'</span>
<span style="color: #a1db00;">print</span>(d_proxy)
</pre>
</div>

<pre class="example">
{1: 'A'}
========= d_proxy[1] =========
A
'mappingproxy' object does not support item assignment
{1: 'A', 2: 'B'}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-10" class="outline-3">
<h3 id="sec-6-10"><span class="section-number-3">6.10</span> 集合</h3>
<div class="outline-text-3" id="text-6-10">
</div><div id="outline-container-sec-6-10-1" class="outline-4">
<h4 id="sec-6-10-1"><span class="section-number-4">6.10.1</span> 创建</h4>
<div class="outline-text-4" id="text-6-10-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">s</span> = {1, 2, 3, 1, 2, 3}
<span style="color: #a1db00;">print</span>(s)
<span style="color: #ff8700;">s</span> = <span style="color: #d18aff;">set</span>()  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#31354;&#38598;&#39035;&#20889;&#25104; set()</span>
<span style="color: #a1db00;">print</span>(s)
<span style="color: #ff8700;">s</span> = <span style="color: #d18aff;">frozenset</span>(<span style="color: #d18aff;">range</span>(10))
<span style="color: #a1db00;">print</span>(s)
<span style="color: #ff8700;">s</span> = { c <span style="color: #a1db00;">for</span> c <span style="color: #a1db00;">in</span> <span style="color: #ff4ea3;">'helloworld'</span>}
<span style="color: #a1db00;">print</span>(s)
</pre>
</div>

<pre class="example">
{1, 2, 3}
set()
frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})
{'h', 'w', 'l', 'd', 'r', 'o', 'e'}
</pre>
</div>
</div>

<div id="outline-container-sec-6-10-2" class="outline-4">
<h4 id="sec-6-10-2"><span class="section-number-4">6.10.2</span> 合集，交集，差集</h4>
<div class="outline-text-4" id="text-6-10-2">
<ul class="org-ul">
<li>合集： <code>a | b</code>
</li>
<li>交集： <code>a &amp; b</code>
</li>
<li>差集： <code>a - b</code>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6-10-3" class="outline-4">
<h4 id="sec-6-10-3"><span class="section-number-4">6.10.3</span> Hash 算法</h4>
<div class="outline-text-4" id="text-6-10-3">

<div class="figure">
<p><img src="img/p3_hash.png" alt="p3_hash.png">
</p>
</div>

<p>
如果实现了一个类的 <code>__eq__</code> 方法，并且希望它是可散列的，
则一定需要有一个恰当的 <code>__hash__</code> 方法，保证在 a == b 为真的情况下 hash(a)==hash(b) 也必定为真。
</p>

<p>
如果一个含有自定义 <code>__eq__</code> 方法的类处于可变的状态，就不要在这个类中实现 <code>__hash__</code> 方法，
因为它的实例是不可散列的。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 函数</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 提取函数签名</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> inspect <span style="color: #a1db00;">import</span> signature

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">foo</span>(a, b=1, **c):
    <span style="color: #a1db00;">pass</span>

<span style="color: #ff8700;">sig</span> = signature(foo)
log(<span style="color: #ff4ea3;">"sig"</span>, sig)

<span style="color: #ff8700;">result</span> = [(name, param.default) <span style="color: #a1db00;">for</span> name, param <span style="color: #a1db00;">in</span> sig.parameters.items()]
log(<span style="color: #ff4ea3;">"result"</span>, result)
</pre>
</div>

<pre class="example">
============ sig =============
(a, b=1, **c)
=========== result ===========
[('a', &lt;class 'inspect._empty'&gt;), ('b', 1), ('c', &lt;class 'inspect._empty'&gt;)]
</pre>


<p>
inspect.Signature 对象有个 bind 方法，可以把任意个参数绑定到签名中的形参上，
所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证函数：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #ff8700;">args</span> = {<span style="color: #ff4ea3;">'a'</span>: <span style="color: #ff4ea3;">'aaa'</span>, <span style="color: #ff4ea3;">'b'</span>: <span style="color: #ff4ea3;">'bbb'</span>, <span style="color: #ff4ea3;">'x'</span>: <span style="color: #ff4ea3;">'xxx'</span>, <span style="color: #ff4ea3;">'y'</span>: <span style="color: #ff4ea3;">'yyy'</span>}
<span style="color: #ff8700;">bound_args</span> = sig.bind(**args)
<span style="color: #ff8700;">result</span> = [(name, value) <span style="color: #a1db00;">for</span> name, value <span style="color: #a1db00;">in</span> bound_args.arguments.items()]
<span style="color: #a1db00;">print</span>(result)
</pre>
</div>

<pre class="example">
[('a', 'aaa'), ('b', 'bbb'), ('c', {'y': 'yyy', 'x': 'xxx'})]
</pre>


<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">del</span> args[<span style="color: #ff4ea3;">'a'</span>]
<span style="color: #a1db00;">try</span>:
    sig.bind(**args)
<span style="color: #a1db00;">except</span> <span style="color: #00d7af;">Exception</span> <span style="color: #a1db00;">as</span> e:
    <span style="color: #a1db00;">print</span>(e)
</pre>
</div>

<pre class="example">
missing a required argument: 'a'
</pre>
</div>
</div>


<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 支持函数式编程的模块</h3>
<div class="outline-text-3" id="text-7-2">
<p>
得益于 operator 和 functools 等模块的支持，可以编写函数式风格的 Python 代码。
</p>
</div>

<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> operator 模块</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
operator 模块为多个算术运算符提供了对应的函数，
从而避免编写类似 <code>lambda a, b: a * b</code> 这种平凡的匿名函数：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> functools <span style="color: #a1db00;">import</span> <span style="color: #d18aff;">reduce</span>
<span style="color: #a1db00;">from</span> operator <span style="color: #a1db00;">import</span> mul

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">reduce</span>(mul, <span style="color: #d18aff;">range</span>(1, 6)))
</pre>
</div>

<pre class="example">
120
</pre>
</div>


<div id="outline-container-sec-7-2-1-1" class="outline-5">
<h5 id="sec-7-2-1-1"><span class="section-number-5">7.2.1.1</span> itemgetter</h5>
<div class="outline-text-5" id="text-7-2-1-1">
<p>
operator 模块中还有一类函数，能替代从序列中取出元素或读取对象属性的 lambda 表达式：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> operator <span style="color: #a1db00;">import</span> itemgetter

<span style="color: #ff8700;">data</span> = [
    (<span style="color: #ff4ea3;">'c'</span>, 2),
    (<span style="color: #ff4ea3;">'b'</span>, 3),
    (<span style="color: #ff4ea3;">'a'</span>, 1)
]

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">sorted</span>(data, key=itemgetter(0)))
</pre>
</div>

<pre class="example">
[('a', 1), ('b', 3), ('c', 2)]
</pre>

<p>
如果把多个参数传给 itemgetter ，它构建的函数会返回提取的值构成的元组：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>([itemgetter(1, 0)(t) <span style="color: #a1db00;">for</span> t <span style="color: #a1db00;">in</span> data])
</pre>
</div>

<pre class="example">
[(2, 'c'), (3, 'b'), (1, 'a')]
</pre>
</div>
</div>


<div id="outline-container-sec-7-2-1-2" class="outline-5">
<h5 id="sec-7-2-1-2"><span class="section-number-5">7.2.1.2</span> attrgetter</h5>
<div class="outline-text-5" id="text-7-2-1-2">
<p>
attrgetter 与 itemgetter 作用类似，它创建的函数根据名称提取对象的属性。
如果把多个属性名传给 attrgetter ，它也会返回提取的值构成的元组。
</p>

<p>
此外，如果参数名中包含 <b>.</b> ，attrgetter 会深入嵌套对象，获取指定的属性。
</p>
</div>
</div>



<div id="outline-container-sec-7-2-1-3" class="outline-5">
<h5 id="sec-7-2-1-3"><span class="section-number-5">7.2.1.3</span> methodcall</h5>
<div class="outline-text-5" id="text-7-2-1-3">
<p>
methodcall 会自行创建函数，该函数会在对象上调用参数指定的方法：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> operator <span style="color: #a1db00;">import</span> methodcaller
<span style="color: #ff8700;">s</span> = <span style="color: #ff4ea3;">"hello world"</span>
<span style="color: #ff8700;">upcase</span> = methodcaller(<span style="color: #ff4ea3;">'upper'</span>)
<span style="color: #a1db00;">print</span>(upcase(s))

<span style="color: #ff8700;">hiphenate</span> = methodcaller(<span style="color: #ff4ea3;">'replace'</span>, <span style="color: #ff4ea3;">' '</span>, <span style="color: #ff4ea3;">'-'</span>)
<span style="color: #a1db00;">print</span>(hiphenate(s))
</pre>
</div>

<pre class="example">
HELLO WORLD
hello-world
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 闭包</h3>
<div class="outline-text-3" id="text-7-3">
<p>
闭包是一种函数，它会保留定义函数时存在的 <b>自由变量(free variable)</b> 的绑定，
这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">make_averager</span>():
    <span style="color: #ff8700;">series</span> = []

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">averager</span>(new_value):
        series.append(new_value)
        <span style="color: #ff8700;">total</span> = <span style="color: #d18aff;">sum</span>(series)
        <span style="color: #a1db00;">return</span> total/<span style="color: #d18aff;">len</span>(series)

    <span style="color: #a1db00;">return</span> averager

<span style="color: #ff8700;">avg</span> = make_averager()
avg(10)
avg(11)
avg(12)

log(<span style="color: #ff4ea3;">"avg.__code__.co_varnames"</span>, avg.__code__.co_varnames)

log(<span style="color: #ff4ea3;">"avg.__code__.co_freevars"</span>, avg.__code__.co_freevars)
</pre>
</div>

<pre class="example">
== avg.__code__.co_varnames ==
('new_value', 'total')
== avg.__code__.co_freevars ==
('series',)
</pre>

<p>
<code>__closure__</code> 中的各个元素对应于 <code>__code__.co_freevars</code> 中的一个名称：
</p>

<div class="org-src-container">

<pre class="src src-ipython">log(<span style="color: #ff4ea3;">"avg.__closure__"</span>, avg.__closure__)

log(<span style="color: #ff4ea3;">"avg.__closure__[0].cell_contents"</span>,
    avg.__closure__[0].cell_contents)
</pre>
</div>

<pre class="example">
====== avg.__closure__ =======
(&lt;cell at 0x109454b28: list object at 0x1078d8208&gt;,)
 avg.__closure__[0].cell_contents
[10, 11, 12]
</pre>
</div>

<div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1"><span class="section-number-4">7.3.1</span> nonlocal</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
nonlocal 的作用是把变量标记为自由变量。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">make_averager</span>():
    <span style="color: #ff8700;">count</span> = 0
    <span style="color: #ff8700;">total</span> = 0

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">averager</span>(new_value):
        <span style="color: #a1db00;">nonlocal</span> count, total
        <span style="color: #ff8700;">count</span> += 1
        <span style="color: #ff8700;">total</span> += new_value
        <span style="color: #a1db00;">return</span> total / count

    <span style="color: #a1db00;">return</span> averager

<span style="color: #ff8700;">avg</span> = make_averager()
avg(1)
avg(2)
<span style="color: #a1db00;">print</span>(avg(3))
</pre>
</div>

<pre class="example">
2.0
</pre>
</div>
</div>


<div id="outline-container-sec-7-3-2" class="outline-4">
<h4 id="sec-7-3-2"><span class="section-number-4">7.3.2</span> 闭包的陷阱</h4>
<div class="outline-text-4" id="text-7-3-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">count</span>():
    <span style="color: #ff8700;">fs</span> = []
    <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(1, 4):
        <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">f</span>():
             <span style="color: #a1db00;">return</span> i*i
        fs.append(f)
    <span style="color: #a1db00;">return</span> fs

<span style="color: #ff8700;">f1</span>, <span style="color: #ff8700;">f2</span>, <span style="color: #ff8700;">f3</span> = count()

<span style="color: #a1db00;">print</span>(f1(), f2(), f3())
</pre>
</div>

<pre class="example">
9 9 9
</pre>

<p>
需注意： <b>闭包中不要引用任何可能会变化的变量。</b> 如果一定要引用会变化的变量，可以再创建一个函数：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">count</span>():
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">f</span>(j):
        <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">g</span>():
            <span style="color: #a1db00;">return</span> j*j
        <span style="color: #a1db00;">return</span> g
    <span style="color: #ff8700;">fs</span> = []
    <span style="color: #a1db00;">for</span> i <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">range</span>(1, 4):
        fs.append(f(i))
    <span style="color: #a1db00;">return</span> fs

<span style="color: #ff8700;">f1</span>, <span style="color: #ff8700;">f2</span>, <span style="color: #ff8700;">f3</span> = count()
<span style="color: #a1db00;">print</span>(f1(), f2(), f3())
</pre>
</div>

<pre class="example">
1 4 9
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 装饰器</h3>
<div class="outline-text-3" id="text-7-4">
</div><div id="outline-container-sec-7-4-1" class="outline-4">
<h4 id="sec-7-4-1"><span class="section-number-4">7.4.1</span> functool.wraps</h4>
<div class="outline-text-4" id="text-7-4-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> functools
<span style="color: #a1db00;">import</span> time

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">clock</span>(func):
    <span style="color: #00d7af;">@functools.wraps</span>(func)
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">wrapper</span>(*args, **kw):
        <span style="color: #ff8700;">t0</span> = time.perf_counter()
        <span style="color: #ff8700;">result</span> = func(*args, **kw)
        <span style="color: #ff8700;">elapsed</span> = time.perf_counter() - t0
        <span style="color: #ff8700;">name</span> = func.<span style="color: #d18aff;">__name__</span>
        <span style="color: #ff8700;">arg_lst</span> = []
        <span style="color: #a1db00;">if</span> args:
            arg_lst.append(<span style="color: #ff4ea3;">', '</span>.join(<span style="color: #d18aff;">repr</span>(arg) <span style="color: #a1db00;">for</span> arg <span style="color: #a1db00;">in</span> args))
        <span style="color: #a1db00;">if</span> kw:
            <span style="color: #ff8700;">pairs</span> = [<span style="color: #ff4ea3;">'{}={}'</span>.<span style="color: #d18aff;">format</span>(k, w) <span style="color: #a1db00;">for</span> k, w <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">sorted</span>(kw.items())]
            arg_lst.append(<span style="color: #ff4ea3;">', '</span>.join(pairs))
        <span style="color: #ff8700;">arg_str</span> = <span style="color: #ff4ea3;">', '</span>.join(arg_lst)
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"[{:0.8f}] {}({}) -&gt; {}"</span>.<span style="color: #d18aff;">format</span>(elapsed, name, arg_str, result))
        <span style="color: #a1db00;">return</span> result
    <span style="color: #a1db00;">return</span> wrapper

<span style="color: #00d7af;">@clock</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">snooze</span>():
    time.sleep(1)

snooze()
</pre>
</div>

<pre class="example">
[1.00260337] snooze() -&gt; None
</pre>
</div>
</div>


<div id="outline-container-sec-7-4-2" class="outline-4">
<h4 id="sec-7-4-2"><span class="section-number-4">7.4.2</span> functools.lru_cache</h4>
<div class="outline-text-4" id="text-7-4-2">
<p>
这是一项优化技术，它把耗时的函数的结果缓存起来，避免传入相同的参数时重复计算。
lru_cache 可以使用两个可选的参数来配置：
</p>

<p>
<b>functools.lru_cache(maxsize=128, typed=False)</b>
</p>

<p>
maxsize 指定存储多少个调用的结果。缓存满了之后，旧的结果会被删除，腾出空间。
为了得到最佳性能，maxsize 应设为 2 的幂。
typed 参数如果设为 True ，把不同参数类型得到的结果分开保存，
即把通常认为相等的浮点数和整数参数(如 1 和 1.0)区分开。
</p>

<p>
因为 lru_cache 使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，
因此被 lru_cache 装饰的函数，它的所有参数必须是可散列的。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #00d7af;">@clock</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">fib</span>(n):
    <span style="color: #a1db00;">if</span> n &lt; 2: <span style="color: #a1db00;">return</span> n
    <span style="color: #a1db00;">return</span> fib(n-2) + fib(n-1)

<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"result: "</span>, fib(6))
</pre>
</div>

<pre class="example">
[0.00000053] fib(0) -&gt; 0
[0.00000139] fib(1) -&gt; 1
[0.00048608] fib(2) -&gt; 1
[0.00000071] fib(1) -&gt; 1
[0.00000073] fib(0) -&gt; 0
[0.00000128] fib(1) -&gt; 1
[0.00026001] fib(2) -&gt; 1
[0.00068066] fib(3) -&gt; 2
[0.00180270] fib(4) -&gt; 3
[0.00000048] fib(1) -&gt; 1
[0.00000042] fib(0) -&gt; 0
[0.00000045] fib(1) -&gt; 1
[0.00023044] fib(2) -&gt; 1
[0.00044458] fib(3) -&gt; 2
[0.00000055] fib(0) -&gt; 0
[0.00000056] fib(1) -&gt; 1
[0.00013973] fib(2) -&gt; 1
[0.00000068] fib(1) -&gt; 1
[0.00000061] fib(0) -&gt; 0
[0.00000055] fib(1) -&gt; 1
[0.00019276] fib(2) -&gt; 1
[0.00042393] fib(3) -&gt; 2
[0.00084947] fib(4) -&gt; 3
[0.00146238] fib(5) -&gt; 5
[0.00373957] fib(6) -&gt; 8
result:  8
</pre>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> functools

<span style="color: #00d7af;">@functools.lru_cache</span>()
<span style="color: #00d7af;">@clock</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">fib</span>(n):
    <span style="color: #a1db00;">if</span> n &lt; 2:
        <span style="color: #a1db00;">return</span> n
    <span style="color: #a1db00;">return</span> fib(n-2) + fib(n-1)

<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"result:"</span>, fib(6))
</pre>
</div>

<pre class="example">
[0.00000083] fib(0) -&gt; 0
[0.00000146] fib(1) -&gt; 1
[0.00060118] fib(2) -&gt; 1
[0.00000328] fib(3) -&gt; 2
[0.00147045] fib(4) -&gt; 3
[0.00000202] fib(5) -&gt; 5
[0.00207811] fib(6) -&gt; 8
result: 8
</pre>
</div>
</div>

<div id="outline-container-sec-7-4-3" class="outline-4">
<h4 id="sec-7-4-3"><span class="section-number-4">7.4.3</span> functools.singledispatch</h4>
<div class="outline-text-4" id="text-7-4-3">
<p>
使用 @singledispatch 装饰的普通函数会变成分派函数，
或称为泛函数 (generic function) ： <b>根据第一个参数的类型，选择对应的函数。</b>
</p>

<p>
分派函数：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">handle_value</span>(value):
    <span style="color: #a1db00;">if</span> <span style="color: #d18aff;">isinstance</span>(value, <span style="color: #d18aff;">int</span>):
        handle_value_int(value)
    <span style="color: #a1db00;">elif</span> <span style="color: #d18aff;">isinstance</span>(value, <span style="color: #d18aff;">str</span>):
        handle_value_str(value)
    <span style="color: #a1db00;">else</span>:
        handle_value_defalut(value)
</pre>
</div>


<p>
@singledispatch 的优点是支持模块化扩展：各个模块可以为它支持的各个类型注册一个专门的函数。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">from</span> functools <span style="color: #a1db00;">import</span> singledispatch
<span style="color: #a1db00;">from</span> collections <span style="color: #a1db00;">import</span> abc
<span style="color: #a1db00;">import</span> numbers

<span style="color: #00d7af;">@singledispatch</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">fun</span>(arg, verbose=<span style="color: #5fafd7;">False</span>):
    <span style="color: #a1db00;">if</span> verbose:
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"Let me just say,"</span>, end=<span style="color: #ff4ea3;">" "</span>)
    <span style="color: #a1db00;">print</span>(arg)

<span style="color: #00d7af;">@fun.register</span>(numbers.Integral)
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">_</span>(arg, verbose=<span style="color: #5fafd7;">False</span>):  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#20989;&#25968;&#21517;&#31216;&#26080;&#20851;&#32039;&#35201;</span>
    <span style="color: #a1db00;">if</span> verbose:
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"Strength in numbers, eh?"</span>, end=<span style="color: #ff4ea3;">" "</span>)
    <span style="color: #a1db00;">print</span>(arg)

<span style="color: #00d7af;">@fun.register</span>(abc.MutableSequence)
<span style="color: #00d7af;">@fun.register</span>(<span style="color: #d18aff;">tuple</span>)  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21487;&#20197;&#21472;&#25918;&#22810;&#20010; register &#35013;&#39280;&#22120;&#65292;&#20197;&#25903;&#25345;&#19981;&#21516;&#30340;&#31867;&#22411;</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">handle_seq</span>(arg, verbose=<span style="color: #5fafd7;">False</span>):
    <span style="color: #a1db00;">if</span> verbose:
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"Enumerate this:"</span>)
    <span style="color: #a1db00;">for</span> i, elem <span style="color: #a1db00;">in</span> <span style="color: #d18aff;">enumerate</span>(arg):
        <span style="color: #a1db00;">print</span>(i, elem)

fun(<span style="color: #ff4ea3;">"3"</span>, <span style="color: #5fafd7;">True</span>)
fun(3, <span style="color: #5fafd7;">True</span>)
fun((3,), <span style="color: #5fafd7;">True</span>)

log(<span style="color: #ff4ea3;">"fun.dispatch(tuple)"</span>, fun.dispatch(<span style="color: #d18aff;">tuple</span>))
log(<span style="color: #ff4ea3;">"fun.registry.keys()"</span>, fun.registry.keys())
</pre>
</div>

<pre class="example">
Let me just say, 3
Strength in numbers, eh? 3
Enumerate this:
0 3
==== fun.dispatch(tuple) =====
&lt;function handle_seq at 0x10b3bf598&gt;
==== fun.registry.keys() =====
dict_keys([&lt;class 'numbers.Integral'&gt;, &lt;class 'collections.abc.MutableSequence'&gt;, &lt;class 'tuple'&gt;, &lt;class 'object'&gt;])
</pre>


<p>
注册的专门函数应该处理抽象基类 (如 numbers.Integral 和 abc.MutableSequence) ，
不要处理具体实现 (如 int 和 list) ，这样，代码支持的兼容类型更广泛。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> 参数</h3>
<div class="outline-text-3" id="text-7-5">
<p>
在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，
这 5 种参数都可以组合使用。
</p>

<p>
组合参数定义的 <b>顺序</b> 必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
</p>
</div>

<div id="outline-container-sec-7-5-1" class="outline-4">
<h4 id="sec-7-5-1"><span class="section-number-4">7.5.1</span> 命名关键字参数</h4>
<div class="outline-text-4" id="text-7-5-1">
<p>
命名关键字参数可以用于限制关键字参数的名字。
命名关键字参数必须传入参数名，如果没有传入参数名，调用将报错。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21482;&#25509;&#25910; city &#21644; job &#20316;&#20026;&#20851;&#38190;&#23383;&#21442;&#25968;</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">person</span>(name, age, *, city, job):             <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21629;&#21517;&#20851;&#38190;&#23383;&#21442;&#25968;&#38656;&#35201;&#19968;&#20010;&#29305;&#27530;&#20998;&#38548;&#31526; *</span>
    <span style="color: #a1db00;">print</span>(name, age, city, job)                  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">* &#21518;&#38754;&#30340;&#21442;&#25968;&#34987;&#35270;&#20026;&#21629;&#21517;&#20851;&#38190;&#23383;&#21442;&#25968;</span>

<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">person2</span>(name, age, *, city=<span style="color: #ff4ea3;">'Beijing'</span>, job):  <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21487;&#20197;&#26377;&#40664;&#35748;&#20540;</span>
    <span style="color: #a1db00;">print</span>(name, age, city, job)

<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#22914;&#26524;&#20989;&#25968;&#23450;&#20041;&#20013;&#24050;&#32463;&#26377;&#20102;&#19968;&#20010;&#21487;&#21464;&#21442;&#25968;</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#21518;&#38754;&#36319;&#30528;&#30340;&#21629;&#21517;&#20851;&#38190;&#23383;&#21442;&#25968;&#23601;&#19981;&#20877;&#38656;&#35201;&#19968;&#20010;&#29305;&#27530;&#20998;&#38548;&#31526; * &#20102;</span>
<span style="color: #a1db00;">def</span> <span style="color: #ffd700;">person</span>(name, age, *args, city, job):
    <span style="color: #a1db00;">print</span>(name, age, args, city, job)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-5-2" class="outline-4">
<h4 id="sec-7-5-2"><span class="section-number-4">7.5.2</span> 默认参数</h4>
<div class="outline-text-4" id="text-7-5-2">
<p>
<b>定义默认参数时，默认参数必须指向不可变对象。</b>
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">add_end</span>(L=[]):
    L.append(<span style="color: #ff4ea3;">'END'</span>)
    <span style="color: #a1db00;">return</span> L

<span style="color: #a1db00;">print</span>(add_end())
<span style="color: #a1db00;">print</span>(add_end())
<span style="color: #a1db00;">print</span>(add_end())
</pre>
</div>

<pre class="example">
['END']
['END', 'END']
['END', 'END', 'END']
</pre>

<p>
原因：
</p>

<p>
函数在定义的时候，默认参数 L 的值就被计算出来了，即 [] ，且保存在函数对象中。
每次调用该函数，如果改变了 L 的内容，则下次调用时，默认参数的内容就变了。
</p>

<p>
可以用 None 这个不可变对象来实现：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">add_end</span>(L=<span style="color: #5fafd7;">None</span>):
    <span style="color: #a1db00;">if</span> L <span style="color: #a1db00;">is</span> <span style="color: #5fafd7;">None</span>:
        <span style="color: #ff8700;">L</span> = []
        L.append(<span style="color: #ff4ea3;">'END'</span>)
        <span style="color: #a1db00;">return</span> L
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 模块</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 包目录结构</h3>
<div class="outline-text-3" id="text-8-1">
<pre class="example">
cisco
├── __init__.py
├── csg
│   ├── __init__.py
│   ├── modA.py
│   └── modB.py
├── modA.py
└── modB.py
</pre>

<p>
每一个包目录下面都会有一个 <code>__init__.py</code> 的文件，这个文件是必须存在的，
否则，Python 就把这个目录当成普通目录，而不是一个包。
</p>

<p>
<code>__init__.py</code> 可以是空文件，也可以有 Python 代码，
因为 <code>__init__.py</code> 本身就是一个模块，而它的模块名就是目录名。
</p>
</div>
</div>
</div>



<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 对象</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> == 与 is</h3>
<div class="outline-text-3" id="text-9-1">
<p>
== 比较两个对象的值 (对象中保存的数据)，而 is 比较对象的标识。
</p>

<p>
a==b 等同于 <code>a.__eq__(b)</code> 。
继承自 object 的 <code>__eq__</code> 方法比较两个对象的 ID ，结果与 is 一样。
但多数内置类型使用更有意义的方式覆盖了 <code>__eq__</code> 方法，会考虑对象属性的值。
</p>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 弱引用</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>弱引用不会增加对象的引用数量，不会妨碍所指对象被当作垃圾回收
</li>
<li>弱引用是可调用对象，如果对象存在，调用弱引用可以获取对象，否则返回 None
</li>
<li>弱引用在缓存应用中很有用，因为一般不希望由于被缓存引用着而始终保存缓存对象
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> weakref
<span style="color: #ff8700;">a</span> = {0, 1}
<span style="color: #ff8700;">wref</span> = weakref.ref(a)
<span style="color: #a1db00;">print</span>(wref())
</pre>
</div>

<pre class="example">
{0, 1}
</pre>

<p>
weakref.ref 类是低层接口，
<b>应该多使用 WeakKeyDictionary, WeakValueDictionary, WeakSet 和 finalize ，</b>
不要自己动手创建并处理 weakref.ref 实例。
</p>
</div>


<div id="outline-container-sec-9-2-1" class="outline-4">
<h4 id="sec-9-2-1"><span class="section-number-4">9.2.1</span> weakref.finalize</h4>
<div class="outline-text-4" id="text-9-2-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> weakref
<span style="color: #ff8700;">s</span> = {1, 2, 3}
<span style="color: #ff8700;">ender</span> = weakref.finalize(s, <span style="color: #a1db00;">lambda</span>: <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"Gone with the wind ..."</span>))
<span style="color: #a1db00;">print</span>(ender.alive)
</pre>
</div>

<pre class="example">
True
</pre>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">del &#19981;&#20250;&#21024;&#38500;&#23545;&#35937;&#65292;&#20294;&#26159;&#25191;&#34892; del &#21518;&#21487;&#33021;&#20250;&#23548;&#33268;&#23545;&#35937;&#19981;&#21487;&#33719;&#21462;&#65292;&#20174;&#32780;&#34987;&#21024;&#38500;</span>
<span style="color: #a1db00;">del</span> s
</pre>
</div>

<pre class="example">
Gone with the wind ...
</pre>
</div>
</div>


<div id="outline-container-sec-9-2-2" class="outline-4">
<h4 id="sec-9-2-2"><span class="section-number-4">9.2.2</span> weakref.WeakValueDictionary</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
WeakValueDictionary 类实现的是一种可变映射， <b>里面的值是对象的弱引用</b> 。
被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。因此，WeakValueDictionary 经常用于缓存。
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> weakref

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Cheese</span>:

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__init__</span>(<span style="color: #a1db00;">self</span>, kind):
        <span style="color: #a1db00;">self</span>.kind = kind

<span style="color: #ff8700;">stock</span> = weakref.WeakValueDictionary()
<span style="color: #ff8700;">catalog</span> = [Cheese(<span style="color: #ff4ea3;">'Read Leicester'</span>), Cheese(<span style="color: #ff4ea3;">'Tilsit'</span>), Cheese(<span style="color: #ff4ea3;">'Brie'</span>), Cheese(<span style="color: #ff4ea3;">'Parmesan'</span>)]
<span style="color: #a1db00;">for</span> cheese <span style="color: #a1db00;">in</span> catalog:
    <span style="color: #ff8700;">stock</span>[cheese.kind] = cheese

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">sorted</span>(stock.keys()))

<span style="color: #a1db00;">del</span> catalog
<span style="color: #a1db00;">del</span> cheese
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">sorted</span>(stock.keys()))
</pre>
</div>

<pre class="example">
['Brie', 'Parmesan', 'Read Leicester', 'Tilsit']
[]
</pre>
</div>
</div>


<div id="outline-container-sec-9-2-3" class="outline-4">
<h4 id="sec-9-2-3"><span class="section-number-4">9.2.3</span> weakref.WeakKeyDictionary</h4>
<div class="outline-text-4" id="text-9-2-3">
<p>
与 WeakValueDictionary 对应的是 WeakKeyDictionary ，后者的键是弱引用。
</p>
</div>
</div>

<div id="outline-container-sec-9-2-4" class="outline-4">
<h4 id="sec-9-2-4"><span class="section-number-4">9.2.4</span> weakref.WeakSet</h4>
<div class="outline-text-4" id="text-9-2-4">
<p>
保存元素弱引用的集合类。元素没有强引用时，集合会把它删除。
</p>

<p>
如果一个类需要知道所有实例，一种好的方案是创建一个 WeakSet 类型的类属性，用以保存实例的引用。
</p>
</div>
</div>

<div id="outline-container-sec-9-2-5" class="outline-4">
<h4 id="sec-9-2-5"><span class="section-number-4">9.2.5</span> 弱引用的局限</h4>
<div class="outline-text-4" id="text-9-2-5">
<p>
不是每个 Python 对象都可以作为弱引用的目标 (或称所指对象) 。
list 和 dict 实例不能作为所指对象，但是它们的子类可以。
int 和 tuple 实例不能作为弱引用的目标，甚至它们的子类也不行。这些局限是内部优化导致的结果。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> <span class="underline"><span class="underline">slots</span></span></h3>
<div class="outline-text-3" id="text-9-3">
<p>
默认情况下，Python 在各个实例中名为 <code>__dict__</code> 的字典里存储实例属性。
为了使用底层的散列表提升访问速度，字典会消耗大量内存。
如果要处理数百万个属性不多的实例，通过 <code>__slots__</code> 类属性，能节省大量内存。
<b>其本质是让解释器在元组中存储实例属性，而不是使用字典。</b>
</p>

<p>
继承自超类的 <code>__slots__</code> 属性 <b>没有效果</b> ，Python 只会使用 <b>各个类中自己定义</b> 的 <code>__slots__</code> 属性。
</p>

<p>
不要使用 <code>__slots__</code> 禁止类的用户新增实例属性，使用 <code>__slots__</code> 是 <b>为了优化，不是为了约束。</b>
</p>
</div>

<div id="outline-container-sec-9-3-1" class="outline-4">
<h4 id="sec-9-3-1"><span class="section-number-4">9.3.1</span> 节省的内存也可能被再次吃掉</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
如果把 <code>__dict__</code> 这个名称添加到 <code>__slots__</code> 中，
实例会在元祖中保存各个实例的属性，同时还支持动态创建属性，但这样就失去了节省内存的功效。
</p>
</div>
</div>


<div id="outline-container-sec-9-3-2" class="outline-4">
<h4 id="sec-9-3-2"><span class="section-number-4">9.3.2</span> 让对象支持弱引用</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
为了让对象支持弱引用，必须要有 <code>__weakref__</code> 这个属性。
</p>

<p>
用户定义的类中默认就有这个属性。如果类中定义了 <code>__slots__</code> 属性，
而且想把实例作为弱引用的目标，那么必须把 <code>__weakref__</code> 添加到 <code>__slots__</code> 中。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 元编程</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> <span class="underline"><span class="underline">new</span></span></h3>
<div class="outline-text-3" id="text-10-1">
<p>
我们通常把 <code>__init__</code> 称为构造方法，其实，用于构建实例的是特殊方法 <code>__new__</code> ：
这是个类方法，由于使用了特殊方式处理，因此不必使用 @classmethod 装饰器，该方法必须返回一个实例。
返回的实例会作为第一个参数 (即 self) 传给 <code>__init__</code> 方法。
</p>

<p>
因为调用 <code>__init__</code> 方法时要传入实例，而且禁止返回任何值，所以 <code>__init__</code> 其实称为初始化方法更为合适。
<b>真正的构造方法是</b> <code>__new__</code> 。
几乎不需要自己编写 <code>__new__</code> 方法，因为从 object 类继承的实现已经足够了。
</p>

<p>
<b>注意</b> ： <code>__new__</code> 方法也可以返回其他类的实例，此时，解释器不会调用 <code>__init__</code> 方法。
</p>

<p>
Python 构建对象的过程可以用下述伪代码概括：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">object_maker</span>(the_class, some_arg):
    <span style="color: #ff8700;">new_object</span> = the_class.__new__(some_arg)
    <span style="color: #a1db00;">if</span> <span style="color: #d18aff;">isinstance</span>(new_object, the_class):
        the_class.__init__(new_object, some_arg)
    <span style="color: #a1db00;">return</span> new_object

<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">&#19979;&#36848;&#20004;&#20010;&#35821;&#21477;&#20316;&#29992;&#31561;&#25928;</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">x = Foo('bar')</span>
<span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">x = object_maker(Foo, 'bar')</span>
</pre>
</div>

<p>
在 <code>__new__</code> 方法中调用 <code>super().__new__(cls)</code> 会调用 <code>object.__new__(cls)</code> ，
而 object 类构建的实例其实是 cls 实例，即实例的 <code>__class__</code> 属性存储的是 cls 类的引用。
(真正的构建操作由解释器调用 C 语言实现的 <code>object.__new__</code> 方法执行)
</p>
</div>
</div>


<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 描述符</h3>
<div class="outline-text-3" id="text-10-2">
</div><div id="outline-container-sec-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> 属性查找</h4>
<div class="outline-text-4" id="text-10-2-1">
</div><div id="outline-container-sec-10-2-1-1" class="outline-5">
<h5 id="sec-10-2-1-1"><span class="section-number-5">10.2.1.1</span> 从类中查找属性</h5>
<div class="outline-text-5" id="text-10-2-1-1">
<p>
使用 C.name 引用类对象 C 的一个属性时，查询操作如下：
</p>

<ol class="org-ol">
<li>当 name 是 <code>C.__dict__</code> 中的一个键时， C.name 将从 <code>C.__dict__['name']</code> 中提取值 v。如果 v 是一个描述器，则 C.name 的值就是 <code>type(v).__get__(v, None, C)</code> ，否则，C.name 的值为 v
</li>
<li>否则，C.name 将委托查找 C 的基类
</li>
<li>否则引发 AttributeError
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-10-2-1-2" class="outline-5">
<h5 id="sec-10-2-1-2"><span class="section-number-5">10.2.1.2</span> 从实例中查找属性</h5>
<div class="outline-text-5" id="text-10-2-1-2">
<p>
<code>obj.attr</code> 这样的表达式 <b>不会从 obj 开始寻找 attr</b> ，而是从 <code>obj.__class__</code> 开始，
<b>仅当类中没有名为 attr 的描述符时，才会在 obj 实例中寻找。</b>
</p>

<p>
使用 x.name 引用类 C 的实例 x 的一个属性时，查询操作如下：
</p>

<ol class="org-ol">
<li>当 name 作为一个覆盖描述器 v 的名称在类 C （或 C 的某个祖先类）中被找到，x.name 的值就是 <code>type(v).__get__(v, x, C)</code>
</li>
<li>否则，当 name 是 <code>x.__dict__</code> 中的一个键时，返回 <code>x.__dict__['name']</code>
</li>
<li>否则，x.name 将委托查找 x 的类，即查找 C.name
</li>
<li>如果 C 定义或继承了特殊方法 <code>__getattr__</code> ，则调用 <code>C.__getattr__(x, 'name')</code> ，而不是引发 AttributeError，然后根据 <code>__getattr__</code> 返回一个合适的值或者引发 AttributeError
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-sec-10-2-2" class="outline-4">
<h4 id="sec-10-2-2"><span class="section-number-4">10.2.2</span> 覆盖型描述符</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
也叫作数据描述符或强制描述符。
</p>

<p>
实现 <code>__set__</code> 方法的描述符属于覆盖型描述符，虽然描述符是类属性，
但是实现了 <code>__set__</code> 方法的话，会覆盖对实例属性的赋值操作。
</p>

<p>
内置的 property 类创建的其实是覆盖型描述符， <code>__set__</code> 方法和 <code>__get__</code> 方法都实现了，
<code>__set__</code> 方法默认抛出 AttributeError 异常。
</p>
</div>

<div id="outline-container-sec-10-2-2-1" class="outline-5">
<h5 id="sec-10-2-2-1"><span class="section-number-5">10.2.2.1</span> 没有 <span class="underline"><span class="underline">get</span></span> 方法的覆盖型描述符</h5>
<div class="outline-text-5" id="text-10-2-2-1">
<p>
通过实例读取描述符会返回描述符对象本身。如果直接通过实例的 <code>__dict__</code> 属性创建同名实例属性，
以后再设置那个属性时，仍会由 <code>__set__</code> 方法接管，
但是读取那个属性时，会直接从实例中返回新赋的值，而不会返回描述符对象。
也就是说，实例属性会遮盖描述符，不过只有读操作如此。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-10-2-3" class="outline-4">
<h4 id="sec-10-2-3"><span class="section-number-4">10.2.3</span> 非覆盖型描述符</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
也叫作非数据描述符或遮盖型描述符。
</p>

<p>
没有实现 <code>__set__</code> 方法的描述符是非覆盖型描述符。
如果设置了同名的实例属性，描述符会被覆盖，致使描述符无法处理那个实例的那个属性。
<b>方法是</b> 以非覆盖型描述符实现的 (只有 <code>__get__</code> 方法) 。
</p>

<p>
非覆盖型描述符可以用来实现缓存，执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。
同名属性会遮盖描述符，因此后续访问会直接从实例的 <code>__dict__</code> 属性中获取值，不会触发描述符的 <code>__get__</code> 方法。
</p>
</div>
</div>
</div>



<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> 元类</h3>
<div class="outline-text-3" id="text-10-3">
</div><div id="outline-container-sec-10-3-1" class="outline-4">
<h4 id="sec-10-3-1"><span class="section-number-4">10.3.1</span> 使用 type 动态创建类</h4>
<div class="outline-text-4" id="text-10-3-1">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">def</span> <span style="color: #ffd700;">fn</span>(<span style="color: #a1db00;">self</span>, name=<span style="color: #ff4ea3;">'world'</span>):
    <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'Hello, %s.'</span> % name)

<span style="color: #ff8700;">Hello</span> = <span style="color: #d18aff;">type</span>(<span style="color: #ff4ea3;">'Hello'</span>, (<span style="color: #d18aff;">object</span>,), <span style="color: #d18aff;">dict</span>(hello=fn))

<span style="color: #ff8700;">h</span> = Hello()
<span style="color: #a1db00;">print</span>((<span style="color: #d18aff;">type</span>(Hello), <span style="color: #d18aff;">type</span>(h)))
</pre>
</div>

<pre class="example">
(&lt;class 'type'&gt;, &lt;class '__main__.Hello'&gt;)
</pre>
</div>
</div>


<div id="outline-container-sec-10-3-2" class="outline-4">
<h4 id="sec-10-3-2"><span class="section-number-4">10.3.2</span> 使用 metaclass 控制类的创建</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
所有类都是 type 的实例，元类是 type 的子类，可以作为制造类的工厂。
具体来说，元类可以通过实现 <code>__init__</code> 方法定制实例。
元类的 <code>__init__</code> 方法可以做到类装饰器能做的任何事情。
(如果想进一步定制类，可以在元类中实现 <code>__new__</code> 方法。不过，通常情况下实现 <code>__init__</code> 方法就够了)
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">MetaFoo</span>(<span style="color: #d18aff;">type</span>):

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__new__</span>(metacls, name, bases, attrs):
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"metacls: {}, name: {}, bases: {}, attrs: {}"</span>.<span style="color: #d18aff;">format</span>(metacls, name, bases, attrs))
        <span style="color: #a1db00;">return</span> <span style="color: #d18aff;">type</span>.__new__(metacls, name, bases, attrs)

    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__init__</span>(cls, name, bases, attrs): <span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">name, bases, attrs: &#19982;&#26500;&#24314;&#31867;&#26102;&#20256;&#32473; type &#30340;&#21442;&#25968;&#19968;&#26679;</span>
        <span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">"cls: {}, name: {}, bases: {}, attrs: {}"</span>.<span style="color: #d18aff;">format</span>(cls, name, bases, attrs))

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Foo</span>(<span style="color: #d18aff;">str</span>, metaclass=MetaFoo):
    <span style="color: #a1db00;">pass</span>

<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">dir</span>(Foo))
</pre>
</div>

<pre class="example">
metacls: &lt;class '__main__.MetaFoo'&gt;, name: Foo, bases: (&lt;class 'str'&gt;,), attrs: {'__qualname__': 'Foo', '__module__': '__main__'}
cls: &lt;class '__main__.Foo'&gt;, name: Foo, bases: (&lt;class 'str'&gt;,), attrs: {'__qualname__': 'Foo', '__module__': '__main__'}
['__add__', '__class__', '__contains__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
</pre>
</div>
</div>


<div id="outline-container-sec-10-3-3" class="outline-4">
<h4 id="sec-10-3-3"><span class="section-number-4">10.3.3</span> <span class="underline"><span class="underline">prepare</span></span></h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
type 构造方法及元类的 <code>__new__</code> 和 <code>__init__</code> 方法都会收到要计算的类的定义体，
形式是名称到属性的映射，默认情况下，那个映射所使用的数据结构是字典。
</p>

<p>
Python3 引入了特殊方法 <code>__prepare__</code> ，这个特殊方法只在元类中有用，且必须声明为类方法。
解释器调用元类的 <code>__new__</code> 方法前会先调用该方法。
<code>__prepare__</code> 方法的第一个参数时元类，随后两个参数分别是要构建的类的名称和基类组成的元组，
返回值必须是映射类型。 <code>__prepare__</code> 返回的映射对象会传给 <code>__new__</code> 方法的最后一个参数，
然后再传给 <code>__init__</code> 方法。
</p>

<p>
<code>__prepare__</code> 的用法一般都比较简单，比如想要控制类的属性定义的顺序：
</p>

<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">import</span> collections

<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">EntityMeta</span>(<span style="color: #d18aff;">type</span>):

    <span style="color: #00d7af;">@classmethod</span>
    <span style="color: #a1db00;">def</span> <span style="color: #ffd700;">__prepare__</span>(cls, name, bases):
        <span style="color: #a1db00;">return</span> collections.OrderedDict()
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Unicode</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 字符编码工作方式</h3>
<div class="outline-text-3" id="text-11-1">
<p>
在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。
</p>

<p>
<b>Python 的字符串在内存中以 Unicode 表示</b> ，一个字符对应若干个字节。
如果要在网络上传输，或者保存到磁盘上， <b>就需要把字符串变为以字节为单位的 bytes</b> 。
</p>


<pre class="example">
+---------------------------------------+
|            Memory (Unicode)           |
+-----------+----------------^----------+
            |                |
            |                |
+-----------v----------------+----------+
|            File (UTF-8)               |
+---------------------------------------+
</pre>
</div>
</div>


<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> Code Point 转换</h3>
<div class="outline-text-3" id="text-11-2">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">ord</span>(<span style="color: #ff4ea3;">'A'</span>))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">ord</span>(<span style="color: #ff4ea3;">'&#20013;'</span>))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">chr</span>(66))
<span style="color: #a1db00;">print</span>(<span style="color: #d18aff;">chr</span>(25991))
</pre>
</div>

<pre class="example">
65
20013
B
文
</pre>
</div>
</div>


<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> 编解码</h3>
<div class="outline-text-3" id="text-11-3">
<div class="org-src-container">

<pre class="src src-ipython"><span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'ABC'</span>.encode(<span style="color: #ff4ea3;">'ascii'</span>))
<span style="color: #a1db00;">print</span>(<span style="color: #ff4ea3;">'&#20013;&#25991;'</span>.encode(<span style="color: #ff4ea3;">'utf-8'</span>))
<span style="color: #a1db00;">print</span>(b<span style="color: #ff4ea3;">'ABC'</span>.decode(<span style="color: #ff4ea3;">'ascii'</span>))
<span style="color: #a1db00;">print</span>(b<span style="color: #ff4ea3;">'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span style="color: #ff4ea3;">'utf-8'</span>))
</pre>
</div>

<pre class="example">
b'ABC'
b'\xe4\xb8\xad\xe6\x96\x87'
ABC
中文
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 参考资料</h2>
</div>
</div>
</body>
</html>